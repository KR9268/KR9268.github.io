[
  {
    "objectID": "index_dashboards.html",
    "href": "index_dashboards.html",
    "title": "Dashboards",
    "section": "",
    "text": "No matching items\n\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "[MStudy_과제개선2] 신용카드 이상거래 탐지 모델링\n\n\n\n파이썬\n\n\n딥러닝\n\n\nMStudy\n\n\nFDS\n\n\nKeras tuner\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-07-16\n\n\n\n\n\n\n\n\n\n\n\n\n[MStudy_과제개선1] 신용카드 이상거래 탐지 모델링\n\n\n\n파이썬\n\n\n딥러닝\n\n\nMStudy\n\n\nFDS\n\n\nStratifiedKFold\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-07-15\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_최종과제 피드백/이론] 신용카드 이상거래 탐지 모델링\n\n\n\n파이썬\n\n\n딥러닝\n\n\nMStudy\n\n\nFDS\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-07-14\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_최종과제] 신용카드 이상거래 탐지 모델링\n\n\n\n파이썬\n\n\n딥러닝\n\n\nMStudy\n\n\nFDS\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-07-11\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_별도 공부] Keras Tuner\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\nFDS\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-07-10\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_6주차] 자연어처리 및 RNN관련 기초내용\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-30\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-24\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_5주차] Overfitting Control & Hyper-Parameter\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-23\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_4주차과제] CNN으로 MNIST다루기\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\nMNIST\n\n\nTensorflow\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-22\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-6(니켈기준 Plot짜보기)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-21\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-5(UN Comtrade API)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\nUN ComtradeAPI\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-16\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_4주차] Convolutional Neural Network\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-16\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-4(모델에 대한 Feature개발 및 평가지표)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-15\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_3주차과제1] Softmax로 MNIST다루기\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\nMNIST\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-15\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_3주차과제2] Neural Network로 MNIST다루기\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\nMNIST\n\n\nTensorflow\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-15\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-3(사용할 피쳐 재분석)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n공공데이터API\n\n\ngithub\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-10\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_3주차] Multi-class Classification / Artificial Neural Network\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-09\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-2(github온라인db)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n공공데이터API\n\n\ngithub\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-08\n\n\n\n\n\n\n\n\n\n\n\n\n[공모전] 공공데이터 공모전-1(대상광물 분석, 공공데이터API)\n\n\n\n공모전\n\n\n공공데이터\n\n\n분석\n\n\n공공데이터API\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-06\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_2주차] Multiple Regression / Logistic Regression\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-06-02\n\n\n\n\n\n\n\n\n\n\n\n\n[M_Study_1주차] Tensorflow / Linear Regression\n\n\n\n파이썬\n\n\n머신러닝\n\n\n딥러닝\n\n\nMStudy\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-05-26\n\n\n\n\n\n\n\n\n\n\n\n\n[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기\n\n\n\n프로그래머스/SQL\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-03-21\n\n\n\n\n\n\n\n\n\n\n\n\n[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기\n\n\n\n프로그래머스/SQL\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-03-20\n\n\n\n\n\n\n\n\n\n\n\n\n[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기\n\n\n\n프로그래머스/SQL\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-03-19\n\n\n\n\n\n\n\n\n\n\n\n\n[프로그래머스SQL] 가장 비싼 상품 구하기\n\n\n\n프로그래머스/SQL\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-03-18\n\n\n\n\n\n\n\n\n\n\n\n\n[프로그래머스SQL] 평균 일일 대여 요금 구하기\n\n\n\n프로그래머스/SQL\n\n\n\n\n\n\n\nKibok Park\n\n\n2024-03-17\n\n\n\n\n\n\n\n\n\n\n\n\n[간단분석] 공공데이터 상권정보로 인터랙티브 맵 시각화(folium)\n\n\n\n파이썬\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2023-11-07\n\n\n\n\n\n\n\n\n\n\n\n\n[한빛앤] GitHub Copilot 세미나 정리\n\n\n\nCopilot\n\n\nCodeium\n\n\n\n\n\n\n\nKibok Park\n\n\n2023-09-13\n\n\n\n\n\n\n\n\n\n\n\n\n[Pycon2023] 짠내나는 데이터 다루기 세션 정리\n\n\n\n파이썬\n\n\n파이콘\n\n\n\n\n\n\n\nKibok Park\n\n\n2023-08-13\n\n\n\n\n\n\n\n\n\n\n\n\n[Scikit-learn] Kaggle 집값예측 실습\n\n\n\n파이썬\n\n\n머신러닝\n\n\n\n\n\n\n\nKibok Park\n\n\n2023-05-06\n\n\n\n\n\n\n\n\n\n\n\n\n[Pytorch] MNIST 실습\n\n\n\n파이썬\n\n\n머신러닝\n\n\n\n\n\n\n\nKibok Park\n\n\n2023-02-19\n\n\n\n\n\n\n\n\n\n\n\n\n[간단분석] KOSIS 온라인쇼핑 해외직접판매액 간단분석 (타 주제 Choropleth시각화)\n\n\n\n파이썬\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2022-11-13\n\n\n\n\n\n\n\n\n\n\n\n\n[간단분석] 공공데이터포털 건강검진정보 활용\n\n\n\n파이썬\n\n\n분석\n\n\n\n\n\n\n\nKibok Park\n\n\n2022-11-06\n\n\n\n\n\n\n\n\nNo matching items\n\n\n  \n\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "index_miniprojects.html",
    "href": "index_miniprojects.html",
    "title": "Mini Projects",
    "section": "",
    "text": "[Python] Github, API활용한 공공데이터 저장소 만들기\n\n\n\nPython\n\n\nrequests\n\n\njson\n\n\nsubprocess\n\n\npandas\n\n\n\n[Python] requests(공공데이터API호출용), json(json규격 자료저장), subprocess(github push자동화), pandas(csv저장)\n\n\n\nKibok Park\n\n\n2024-06-10\n\n\n\n\n\n\n\n\n\n\n\n\n[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool\n\n\n\nPython\n\n\nSAP Scripting\n\n\n\nPython, win32를 활용한 SAP Scripting\n\n\n\nKibok Park\n\n\n2024-03-06\n\n\n\n\n\n\n\n\n\n\n\n\n[Python] COO발급관리용 Tool\n\n\n\nPython\n\n\nwin11toast\n\n\nsqlite3\n\n\nstreamlit\n\n\npandas\n\n\nselenium\n\n\n\n[Python] selenium(웹스크레핑), sqlite3(db), win11toast(알림), streamlit(UI)\n\n\n\nKibok Park\n\n\n2024-02-20\n\n\n\n\n\n\n\n\n\n\n\n\n[Python] LocalL/C 관리용 Tool\n\n\n\nPython\n\n\nSAP Scripting\n\n\nStreamlit\n\n\nsqlite3\n\n\nBeautifulSoup\n\n\n\nPython, Streamlit을 활용한 업무자동화\n\n\n\nKibok Park\n\n\n2024-01-22\n\n\n\n\n\n\n\n\n\n\n\n\n[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록\n\n\n\nPython\n\n\nre\n\n\nxlwings\n\n\npandas\n\n\npdfminer\n\n\n\n[Python] re(regex), xlwings(암호화 Excel리딩), pdfminer(pdf리딩), pywin32(outlook)\n\n\n\nKibok Park\n\n\n2023-12-15\n\n\n\n\n\n\n\n\n\n\n\n\n[Python] Peak타임 대응용 수출계약서pdf tabula리딩\n\n\n\nPython\n\n\ntabula\n\n\nxlwings\n\n\npathlib\n\n\npandas\n\n\n\n[Python] tabula(pdf리딩[표 형태], xlwings(암호화 Excel리딩)\n\n\n\nKibok Park\n\n\n2023-11-02\n\n\n\n\n\n\n\n\nNo matching items\n\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Kibok Park",
    "section": "",
    "text": "I’m Kibok Park. Welcome to my blog. I’m not an expert in my favorites yet, but I’m working on becoming one. I hope you to have nice time with my blog.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "about.html#hello",
    "href": "about.html#hello",
    "title": "Kibok Park",
    "section": "",
    "text": "I’m Kibok Park. Welcome to my blog. I’m not an expert in my favorites yet, but I’m working on becoming one. I hope you to have nice time with my blog."
  },
  {
    "objectID": "about.html#topics",
    "href": "about.html#topics",
    "title": "Kibok Park",
    "section": "Topics",
    "text": "Topics\nPython, MachineLearning, DeepLearning"
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "",
    "text": "공부할 겸 혼자서 구글링하면서 용어 정리해보는 포스팅입니다\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#프롤로그",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#프롤로그",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "프롤로그",
    "text": "프롤로그\n\n경제적 해자(enonomic moat) : 성 외곽에서 성을 보호해주는 해자처럼 경쟁우위를 갖게 해주는 요소 (a business’s ability to maintain a competitive edge over its competitors)\n자본배분(capital allocation) : 경제적 자원들을 효율증대/이익극대화를 위해 분배/투자 하는 것 (distributing and investing a company’s financial resources in ways that will increase its efficiency, and maximize its profits) &gt; 자본배분을 알면 워런버핏 사례의 캐피털시티를 이해할 수 있다\n플로트(float, 책임준비금) : 보험회사가 보험금을 지급하기 위해 적립시키는 돈(은행과 달리 자산운용준칙에 따라 자율적으로 사용 가능)\n\n플로트라는 단어의 다른 뜻 : 일반 대중이 거래할 수 있게 발행한 보통주 (the regular shares a company has issued to the public that are available for investors to trade) &gt; 플로트를 알면 워런버핏 사례의 가이코를 이해할 수 있다 (내셔널 인뎀너티와 블루칩스탬프의 플로트를 활용한 투자법 등)\n\n재보험 : 보험계약상 책임의 전부 또는 일부를 다른 보험자에게 인수시킴 (위험의 분산과 인수능력의 극대화를 위해 필요, 위험 대비 자산이 충분치 않은 경우 재보험으로 보험금액의 전부 인수가능)\n영업이익(operating income/earnings) : 기업의 핵심사업(영업활동)으로 얻은 이익 (a measure of the amount of profit realized from a business’s core operations)\n연간 영업활동 순이익(operating earnings) : 영업활동에 필요한 차입금 등 부채의 이자비용도 차감한 이익(영업활동에서 발생한 순이익)\n\n일반 회계기준(GAAP, Generally Accepted Accounting Principles, GAAP)\n\n일반적으로 인정된 회계원칙. 회계규정 자체 또는 회계실무 지침 등 광범위하게 인정되는 회계기준 &gt; GAAP관련 추가로 알아보기\n\n\n**IFRS(International Financial Reporting Standards) : 국제회계기준위원회에서 공표한 회계기준. IFRS를 공부하면 IFRS를 차용한 국가의 회사 재무제표는 같은 형식으로 이해 가능\n\n규칙기반의 GAAP vs 원칙기반의 IFRS\n\nIFRS는 원칙에 따라 작성해 형태 차이가 거의 없으나, GAAP는 세부적인 사안에 대해 자세히 기술(IFRS도 주석 부분에 기술)\n\n\n내용을 세세하게 다루거나, 공정가치를 계산하지않아 IFRS보다 현재가치를 크게 하고 싶을때 GAAP사용\n\n\n\nNon-GAAP\n\n반복적으로 발생하지 않는 1회적 비용은 제외하고 회계처리. 비용이 줄어 순수익이 늘어남\n\n\n미국의 경우 Non-GAAP로 다양한 비용을 제외시켜 표시하는 것이 불법은 아님(기업에 유리) 참고한 링크"
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-섬유공장",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-섬유공장",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "1장. 섬유공장",
    "text": "1장. 섬유공장\n\n\n총자산이익률(ROA, Return on assets) : 순이익 / 총자산(자기자본 + 타인자본). 얼마나 순이익이 창출되는지 판단할 수 있음. ROA의 높고 낮음에 따라 주가의 높낮이도 따를 가능성이 큼 산업의 성숙기[성장/성숙/사양 등]에 따라 ROA는 달라질 수 있음\n자기자본이익률(ROE, Return on equity) : 순이익 / 자본총계(자산-부채) ROA가 높은 경우 적정 수준으로 부채확대를 통해 총자산 자체를 늘리면 ROE를 높일 수 있음 참고한 링크 참고한 링크\n\n\n\n운전자본(Working Capital, =유동자본?) : 회사를 운영하는데 들어가는 돈(매출채권, 선급금, 재고자산 등 유동자산과 매입채무, 선수금 등 유동부채가 해당함)\n순운전자본(Net Working Capital, 운전자본-총부채) : ?? (클럽 설명) 벤자민 그레이엄이 ’현명한 투자자’에서 주창한 투자 전략 즉시 현금화할 수 있는 자산과 비교함으로써 보수적인 기준에서 주가의 저(고)평가 여부를 판단하는 척도로 사용\n장부가치\n주가순자산배수(PBR, price to book value)\n주주환원\n자사주 매입\n감가상각비\n자산 대체원가\n무형자산상각비 차감 전 이익(EBITDA)\n투하자본이익률(ROIC, return on invested capital)\n배당의 이중과세 : 연간이익에 대한 기업의 법인세 + 배당금에 대한 주주의 소득세\n자사주 매입을 통한 주주의 세금 이연(은 주주이익에 도움)"
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-투자-1962-1965년",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-투자-1962-1965년",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "2장. 투자: 1962-1965년",
    "text": "2장. 투자: 1962-1965년\n\n무한책임 파트너(general partner) : 펀드 운용에 관한 무한책임을 지는 출자자, 보통 운용자를 말함\n헤지펀드 :\n환매 :\n이월결손금\n손익계산서\n유동성소요\n**내재 사업가치(intrinsic business value)\n유한책임조합"
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-전환-1965-1967년",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-전환-1965-1967년",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "3장. 전환: 1965-1967년",
    "text": "3장. 전환: 1965-1967년\n\n자본배분\n투하자본이익률\n매출원가\n특별항목 (’특별항목 반영 전 순이익’에서 사용된 의미, ’1964년 특별항목은 유휴설비비용 22만 달러를 포함했다’와 같이 사용)\n유휴설비비용(idle plant expense): 비영업용 제조설비의 유지보수 및 감가상각비\n**기대손실\n손상차손 write-down\n유형자산 손상차손\n이익잉여금\n총포괄손익\n총창출자본(total capital generated)"
  },
  {
    "objectID": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-인수-1967-1969년",
    "href": "posts/yyyymmdd-bk-BerkshireHathaway-1/index.html#장.-인수-1967-1969년",
    "title": "[버크셔 해서웨이의 재탄생 읽고] 용어 정리",
    "section": "4장. 인수: 1967-1969년",
    "text": "4장. 인수: 1967-1969년\n\n완전 소유 기업(wholly-owned-subsidiary) : 1개 기업이 단독 투자하여 100% 소유 지문을 가지는것\n상환청구권 :\n\n\n플로트(책임준비금) : + 지급준비금(lost reserve) + 손해사정비 준비금(lost adjustment expense reserve) + 미경과보험료 적립금(unearned premium reserve) - 대리점 미수금(agents’ balance) - 선급 신계약비(prepaid acquisition cost) - 출재보험 준비금(deferred charges applicable to assumed reinsurance)"
  },
  {
    "objectID": "posts/vba-noname-yyyymmdd/index.html",
    "href": "posts/vba-noname-yyyymmdd/index.html",
    "title": "NH증권 직무인터뷰를 읽고(트레이딩&빅데이터)",
    "section": "",
    "text": "관심이 생겨서 관련 공고 등을 보고 있는데, 직무이해 겸 모르는 단어를 정리해봅니다.\n\n\n\n\n\n\n참고한 공고 (클릭해서 펼치기)\n\n\n\n\n\nNH투자증권 채용공고-Trading\nNH투자증권 채용공고-빅데이터 분석\nNH투자증권 직무인터뷰\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/vba-noname-yyyymmdd/index.html#참고한-공고-인터뷰-자료",
    "href": "posts/vba-noname-yyyymmdd/index.html#참고한-공고-인터뷰-자료",
    "title": "NH증권 직무인터뷰를 읽고(트레이딩&빅데이터)",
    "section": "",
    "text": "관심이 생겨서 관련 공고 등을 보고 있는데, 직무이해 겸 모르는 단어를 정리해봅니다.\n\n\n\n\n\n\n참고한 공고 (클릭해서 펼치기)\n\n\n\n\n\nNH투자증권 채용공고-Trading\nNH투자증권 채용공고-빅데이터 분석\nNH투자증권 직무인터뷰"
  },
  {
    "objectID": "posts/vba-noname-yyyymmdd/index.html#트레이딩-직무-단어정리",
    "href": "posts/vba-noname-yyyymmdd/index.html#트레이딩-직무-단어정리",
    "title": "NH증권 직무인터뷰를 읽고(트레이딩&빅데이터)",
    "section": "트레이딩 직무 단어정리",
    "text": "트레이딩 직무 단어정리\n\n프랍 트레이딩(Proprietary Trading) : 고객이 아닌 금융회사의 돈으로 주식이나 파생상품 등 금융상품을 거래하는 것 (=자기계정거래, 자기계좌거래, 고유계정거래, 고유계좌거래)\n\n\n프랍트레이딩은 통상 선물·옵션 등 파생상품 부문, 일반적 주식투자 같은 방향성 매매, 알고리즘에 따라 투자하는 시스템 매매, 채권투자, 부동산이나 인프라 등의 대체투자 등으로 나뉜다. 보통 자기매매 비중이 높은 중소형 증권사에는 많게는 50여명에 이르는 프랍트레이더들이 있다. 이 가운데 80% 이상이 파생 트레이더다.중소형 증권사들의 파생상품투자 비중이 높은 것은 비용이 싸기 때문이다. 증권사의 경우 선물·옵션 거래시 사후 증거금 제도가 적용된다. 장중 거래에는 증거금이 따로 필요 없고 장 마감 후 포지션 규모에 따라 증거금을 마련하면 된다. 따라서 장중에는 활발히 거래하고 장 마감 직전 파생상품을 보유하지 않았으면 증거금 부담은 없다. 하루 단위로 청산하는 경우 사실상 금융비용은 없다.\n상기내용 참고한 서울경제 기사링크 거래증거금vs위탁증거금 내용 참고할 수 있는 블로그\n\n\n장내거래 vs 장외거래 : 정규시장 외 체결되는 거래\n매크로 지식 : Macro economics지식 (↔︎ Micro economics)\n서킷브레이커(일시매매정지, Trading Curb) : 가격 변동이 지나친 경우 일시적으로 거래를 중단하는 것\n틱 : 체결량에 따른 단위 (5틱 = 체결 5회 기준)\n셀사이드(Sell-side|은행, 증권사 등) : 금융 서비스 등을 제공하여 수익 창출\n바이사이드(Buy-side|자산운용사, 연기금, 보험사, 헤지펀드 등) : 투자를 하여 수익 창출\n\n\n참고글:셀사이드와 바이사이드의 금융공학\n\n\n하우스 : 증권사, 금융사 등 단체를 칭함"
  },
  {
    "objectID": "posts/vba-noname-yyyymmdd/index.html#빅데이터-직무-단어정리",
    "href": "posts/vba-noname-yyyymmdd/index.html#빅데이터-직무-단어정리",
    "title": "NH증권 직무인터뷰를 읽고(트레이딩&빅데이터)",
    "section": "빅데이터 직무 단어정리",
    "text": "빅데이터 직무 단어정리\n\nMTS : Mobile Trading System (HTS : Home Trading System)\n원장 : 증권사가 고객계좌나 거래내역, 매매 등을 관리하는 프로그램"
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html",
    "href": "posts/coach-ml-20240505/index.html",
    "title": "[Pytorch] MNIST 실습",
    "section": "",
    "text": "파이토치로 MNIST 머신러닝 실습해본 코드 기록용으로 남깁니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html#pytorch활용한-mnist-데이터셋-로딩",
    "href": "posts/coach-ml-20240505/index.html#pytorch활용한-mnist-데이터셋-로딩",
    "title": "[Pytorch] MNIST 실습",
    "section": "Pytorch활용한 MNIST 데이터셋 로딩",
    "text": "Pytorch활용한 MNIST 데이터셋 로딩\n\n\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nimport torchvision\nimport torchvision.datasets as dset\nimport torchvision.transforms as transforms\n\nroot = './data'\nmnist_train = dset.MNIST (root=root, train=True, transform=transforms.ToTensor(), download=True )\nmnist_test = dset.MNIST (root=root, train=False, transform=transforms.ToTensor(), download=True)\n\n# Train용 / Test용 데이터셋\ntrain_loader = DataLoader(mnist_train, batch_size=10, shuffle=True)\ntest_loader = DataLoader(mnist_test, batch_size=10, shuffle=True)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html#학습준비가중치-초기화-등",
    "href": "posts/coach-ml-20240505/index.html#학습준비가중치-초기화-등",
    "title": "[Pytorch] MNIST 실습",
    "section": "학습준비(가중치 초기화 등)",
    "text": "학습준비(가중치 초기화 등)\n\nMNIST의 크기 : 28 * 28\nLoss : Cross Entropy\nOptimizer - SGD(Stochastic Gradient Descent)\nLearning rate = 0.1\n\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n\n# 모델 구현 (28*28 = 784 / 0~9라서 10개 / 가중치 사용하므로 bias)\nlinear = torch.nn.Linear(784, 10, bias=True).to(device) \n\n# weight init 가중치 초기화\ntorch.nn.init.normal_(linear.weight)\n\n# Loss fn - Cross Entropy Loss\ncriterion = torch.nn.CrossEntropyLoss().to(device)\n\n# optimizer - SGD\noptimizer = torch.optim.SGD(linear.parameters(), lr=0.1)"
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html#모델-학습",
    "href": "posts/coach-ml-20240505/index.html#모델-학습",
    "title": "[Pytorch] MNIST 실습",
    "section": "모델 학습",
    "text": "모델 학습\n\ntraining_epochs = 20 # training 반복 횟수\n\nfor epoch in range(training_epochs):\n  for i, (imgs, labels) in enumerate(train_loader):\n    labels = labels.to(device)\n    imgs = imgs.view(-1, 28 * 28).to(device)\n\n    outputs = linear(imgs) \n    loss = criterion(outputs, labels) \n\n    optimizer.zero_grad()# optimzier zero grad\n\n    loss.backward() # loss backward\n    optimizer.step() # optimzier step\n\n    _,argmax = torch.max(outputs, 1)\n    accuracy = (labels == argmax).float().mean()\n\n  if (i+1) % 100 == 0:\n    print('Epoch [{}/{}], Step [{}/{}], Loss: {: .4f}, Accuracy: {: .2f}%'.format(\n    epoch+1, training_epochs, i+1, len(train_loader), loss.item(), accuracy.item()* 100))\n\nEpoch [1/20], Step [6000/6000], Loss:  0.0273, Accuracy:  100.00%\nEpoch [2/20], Step [6000/6000], Loss:  0.0762, Accuracy:  100.00%\nEpoch [3/20], Step [6000/6000], Loss:  0.5928, Accuracy:  80.00%\nEpoch [4/20], Step [6000/6000], Loss:  0.2854, Accuracy:  90.00%\nEpoch [5/20], Step [6000/6000], Loss:  0.1373, Accuracy:  90.00%\nEpoch [6/20], Step [6000/6000], Loss:  0.0668, Accuracy:  100.00%\nEpoch [7/20], Step [6000/6000], Loss:  0.0253, Accuracy:  100.00%\nEpoch [8/20], Step [6000/6000], Loss:  0.0542, Accuracy:  100.00%\nEpoch [9/20], Step [6000/6000], Loss:  0.9203, Accuracy:  80.00%\nEpoch [10/20], Step [6000/6000], Loss:  0.1244, Accuracy:  90.00%\nEpoch [11/20], Step [6000/6000], Loss:  0.6108, Accuracy:  90.00%\nEpoch [12/20], Step [6000/6000], Loss:  0.1312, Accuracy:  100.00%\nEpoch [13/20], Step [6000/6000], Loss:  0.0705, Accuracy:  100.00%\nEpoch [14/20], Step [6000/6000], Loss:  1.6259, Accuracy:  70.00%\nEpoch [15/20], Step [6000/6000], Loss:  0.0538, Accuracy:  100.00%\nEpoch [16/20], Step [6000/6000], Loss:  0.2435, Accuracy:  80.00%\nEpoch [17/20], Step [6000/6000], Loss:  0.0061, Accuracy:  100.00%\nEpoch [18/20], Step [6000/6000], Loss:  0.1091, Accuracy:  100.00%\nEpoch [19/20], Step [6000/6000], Loss:  0.0157, Accuracy:  100.00%\nEpoch [20/20], Step [6000/6000], Loss:  0.1413, Accuracy:  90.00%"
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html#학습된-모델-테스트",
    "href": "posts/coach-ml-20240505/index.html#학습된-모델-테스트",
    "title": "[Pytorch] MNIST 실습",
    "section": "학습된 모델 테스트",
    "text": "학습된 모델 테스트\n\nlinear.eval()\nwith torch.no_grad():\n    correct = 0\n    total = 0\n    for i, (imgs, labels) in enumerate(test_loader):\n        imgs, labels = imgs.to(device), labels.to(device)\n        imgs = imgs.view(-1, 28 * 28)\n\n        outputs = linear(imgs) # 구현\n\n        _, argmax = torch.max(outputs, 1) # max()를 통해 최종 출력이 가장 높은 class 선택\n        total += imgs.size(0)\n        correct += (labels == argmax). sum().item()\n\n    print('Test accuracy for {} images: {: .2f}%'.format(total, correct / total * 100))\n\nTest accuracy for 10000 images:  91.99%"
  },
  {
    "objectID": "posts/coach-ml-20240505/index.html#개요",
    "href": "posts/coach-ml-20240505/index.html#개요",
    "title": "[Pytorch] MNIST 실습",
    "section": "",
    "text": "파이토치로 MNIST 머신러닝 실습해본 코드 기록용으로 남깁니다."
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html",
    "href": "posts/coach-ml-kaggle-20230506/index.html",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "",
    "text": "Kaggle Korea - House price prediction 실습 기록용으로 남깁니다.\nKaggle 원문 링크\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#개요",
    "href": "posts/coach-ml-kaggle-20230506/index.html#개요",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "",
    "text": "Kaggle Korea - House price prediction 실습 기록용으로 남깁니다.\nKaggle 원문 링크"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#pytorch활용한-mnist-데이터셋-로딩",
    "href": "posts/coach-ml-kaggle-20230506/index.html#pytorch활용한-mnist-데이터셋-로딩",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "Pytorch활용한 MNIST 데이터셋 로딩",
    "text": "Pytorch활용한 MNIST 데이터셋 로딩\n\n\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nimport torchvision\nimport torchvision.datasets as dset\nimport torchvision.transforms as transforms\n\nroot = './data'\nmnist_train = dset.MNIST (root=root, train=True, transform=transforms.ToTensor(), download=True )\nmnist_test = dset.MNIST (root=root, train=False, transform=transforms.ToTensor(), download=True)\n\n# Train용 / Test용 데이터셋\ntrain_loader = DataLoader(mnist_train, batch_size=10, shuffle=True)\ntest_loader = DataLoader(mnist_test, batch_size=10, shuffle=True)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#학습준비가중치-초기화-등",
    "href": "posts/coach-ml-kaggle-20230506/index.html#학습준비가중치-초기화-등",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "학습준비(가중치 초기화 등)",
    "text": "학습준비(가중치 초기화 등)\n\nMNIST의 크기 : 28 * 28\nLoss : Cross Entropy\nOptimizer - SGD(Stochastic Gradient Descent)\nLearning rate = 0.1\n\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n\n# 모델 구현 (28*28 = 784 / 0~9라서 10개 / 가중치 사용하므로 bias)\nlinear = torch.nn.Linear(784, 10, bias=True).to(device) \n\n# weight init 가중치 초기화\ntorch.nn.init.normal_(linear.weight)\n\n# Loss fn - Cross Entropy Loss\ncriterion = torch.nn.CrossEntropyLoss().to(device)\n\n# optimizer - SGD\noptimizer = torch.optim.SGD(linear.parameters(), lr=0.1)"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#모델-학습",
    "href": "posts/coach-ml-kaggle-20230506/index.html#모델-학습",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "모델 학습",
    "text": "모델 학습\n\ntraining_epochs = 20 # training 반복 횟수\n\nfor epoch in range(training_epochs):\n  for i, (imgs, labels) in enumerate(train_loader):\n    labels = labels.to(device)\n    imgs = imgs.view(-1, 28 * 28).to(device)\n\n    outputs = linear(imgs) \n    loss = criterion(outputs, labels) \n\n    optimizer.zero_grad()# optimzier zero grad\n\n    loss.backward() # loss backward\n    optimizer.step() # optimzier step\n\n    _,argmax = torch.max(outputs, 1)\n    accuracy = (labels == argmax).float().mean()\n\n  if (i+1) % 100 == 0:\n    print('Epoch [{}/{}], Step [{}/{}], Loss: {: .4f}, Accuracy: {: .2f}%'.format(\n    epoch+1, training_epochs, i+1, len(train_loader), loss.item(), accuracy.item()* 100))\n\nEpoch [1/20], Step [6000/6000], Loss:  0.0273, Accuracy:  100.00%\nEpoch [2/20], Step [6000/6000], Loss:  0.0762, Accuracy:  100.00%\nEpoch [3/20], Step [6000/6000], Loss:  0.5928, Accuracy:  80.00%\nEpoch [4/20], Step [6000/6000], Loss:  0.2854, Accuracy:  90.00%\nEpoch [5/20], Step [6000/6000], Loss:  0.1373, Accuracy:  90.00%\nEpoch [6/20], Step [6000/6000], Loss:  0.0668, Accuracy:  100.00%\nEpoch [7/20], Step [6000/6000], Loss:  0.0253, Accuracy:  100.00%\nEpoch [8/20], Step [6000/6000], Loss:  0.0542, Accuracy:  100.00%\nEpoch [9/20], Step [6000/6000], Loss:  0.9203, Accuracy:  80.00%\nEpoch [10/20], Step [6000/6000], Loss:  0.1244, Accuracy:  90.00%\nEpoch [11/20], Step [6000/6000], Loss:  0.6108, Accuracy:  90.00%\nEpoch [12/20], Step [6000/6000], Loss:  0.1312, Accuracy:  100.00%\nEpoch [13/20], Step [6000/6000], Loss:  0.0705, Accuracy:  100.00%\nEpoch [14/20], Step [6000/6000], Loss:  1.6259, Accuracy:  70.00%\nEpoch [15/20], Step [6000/6000], Loss:  0.0538, Accuracy:  100.00%\nEpoch [16/20], Step [6000/6000], Loss:  0.2435, Accuracy:  80.00%\nEpoch [17/20], Step [6000/6000], Loss:  0.0061, Accuracy:  100.00%\nEpoch [18/20], Step [6000/6000], Loss:  0.1091, Accuracy:  100.00%\nEpoch [19/20], Step [6000/6000], Loss:  0.0157, Accuracy:  100.00%\nEpoch [20/20], Step [6000/6000], Loss:  0.1413, Accuracy:  90.00%"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#학습된-모델-테스트",
    "href": "posts/coach-ml-kaggle-20230506/index.html#학습된-모델-테스트",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "학습된 모델 테스트",
    "text": "학습된 모델 테스트\n\nlinear.eval()\nwith torch.no_grad():\n    correct = 0\n    total = 0\n    for i, (imgs, labels) in enumerate(test_loader):\n        imgs, labels = imgs.to(device), labels.to(device)\n        imgs = imgs.view(-1, 28 * 28)\n\n        outputs = linear(imgs) # 구현\n\n        _, argmax = torch.max(outputs, 1) # max()를 통해 최종 출력이 가장 높은 class 선택\n        total += imgs.size(0)\n        correct += (labels == argmax). sum().item()\n\n    print('Test accuracy for {} images: {: .2f}%'.format(total, correct / total * 100))\n\nTest accuracy for 10000 images:  91.99%"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#개념",
    "href": "posts/coach-ml-kaggle-20230506/index.html#개념",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "개념",
    "text": "개념\nRMSE(Root Mean Squeare Error)\nRoot    (4)\nMean    (3)\nSquare  (2)\nError   (1)\n(1) 실제값에서 예측값을 뺀 '오차'를\n(2) 합했을 때 음수의 영향을 제거하기 위해 '제곱'하고\n(3) '평균'오차로 만든 후\n(4) '루트'를 씌워 값의 크기를 작게 한다 (값을 작게하여 연산속도에 이점이 있다)"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#파일-다운로드-및-알아보기",
    "href": "posts/coach-ml-kaggle-20230506/index.html#파일-다운로드-및-알아보기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "파일 다운로드 및 알아보기",
    "text": "파일 다운로드 및 알아보기\nFile descriptions\ntrain.csv - 예측 모델을 만들기 위해 사용하는 학습 데이터입니다. \n    집의 정보와 예측할 변수인 가격(Price) 변수를 가지고 있습니다.\ntest.csv - 학습셋으로 만든 모델을 가지고 예측할 가격(Price) 변수를 제외한 집의 정보가\n    담긴 테스트 데이터 입니다.\nsample_submission.csv - 제출시 사용할 수 있는 예시 submission.csv 파일입니다.\nData fields\nID : 집을 구분하는 번호\ndate : 집을 구매한 날짜\nprice : 집의 가격(Target variable)\nbedrooms : 침실의 수\nbathrooms : 화장실의 수\nsqft_living : 주거 공간의 평방 피트(면적)\nsqft_lot : 부지의 평방 피트(면적)\nfloors : 집의 층 수\nwaterfront : 집의 전방에 강이 흐르는지 유무 (a.k.a. 리버뷰)\nview : 집이 얼마나 좋아 보이는지의 정도\ncondition : 집의 전반적인 상태\ngrade : King County grading 시스템 기준으로 매긴 집의 등급\nsqft_above : 지하실을 제외한 평방 피트(면적)\nsqft_basement : 지하실의 평방 피트(면적)\nyr_built : 지어진 년도\nyr_renovated : 집을 재건축한 년도\nzipcode : 우편번호\nlat : 위도\nlong : 경도\nsqft_living15 : 2015년 기준 주거 공간의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)\nsqft_lot15 : 2015년 기준 부지의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#패키지-및-데이터-불러오기",
    "href": "posts/coach-ml-kaggle-20230506/index.html#패키지-및-데이터-불러오기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "패키지 및 데이터 불러오기",
    "text": "패키지 및 데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ntrain_data_path = './data/train.csv'\ntest_data_path = './data/test.csv'\n\ndata = pd.read_csv(train_data_path)\ntest = pd.read_csv(test_data_path)\nprint('train data : {}'.format(data.shape))\nprint('test data : {}'.format(test.shape))\n\ntrain data : (15035, 21)\ntest data : (6555, 20)"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#데이터-전처리",
    "href": "posts/coach-ml-kaggle-20230506/index.html#데이터-전처리",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "데이터 전처리",
    "text": "데이터 전처리\n\n정답컬럼 분리\n\ntest데이터와 달리 train data에는 컬럼이 1개 더 있음 (정답컬럼인 price)\n별도의 정답 데이터(y)로 분리\n\n\nprint('컬럼 분리 전')\nprint(data.columns)\nprint(test.columns)\n\n컬럼 분리 전\nIndex(['id', 'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living',\n       'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',\n       'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',\n       'lat', 'long', 'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\n\n\n\n# y라는 변수에 price(정답)을 옮기고, 전체데이터를 백업(data_backup에 할당)하고 price컬럼 삭제\ny = data['price'] \ndata_backup = data.copy()\ndata.drop('price',axis=1, inplace=True)\n\n\nprint('컬럼 분리 후')\nprint(data.columns)\nprint(test.columns)\nprint(y.name)\n\n컬럼 분리 후\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nprice\n\n\n\n\n결측치 확인 및 제거\n\ntrain, test 데이터를 합쳐서 한번에 확인\n\n\n# 합치기\ndf_chk_missing = pd.concat((data, test), axis=0)\n\n# 향후 분할을 대비한 행 수 저장\ntrain_length = len(data)\ntest_length = len(test)\n\nprint(train_length, test_length)\n\n15035 6555\n\n\n\n결측치 확인방법1(pandas)\n\nisna()로 결측치를 확인\n\n\nprint(df_chk_missing.isna().sum())\n\nid               0\ndate             0\nbedrooms         0\nbathrooms        0\nsqft_living      0\nsqft_lot         0\nfloors           0\nwaterfront       0\nview             0\ncondition        0\ngrade            0\nsqft_above       0\nsqft_basement    0\nyr_built         0\nyr_renovated     0\nzipcode          0\nlat              0\nlong             0\nsqft_living15    0\nsqft_lot15       0\ndtype: int64\n\n\n\n\n결측치 확인방법2(missingno)\n\nmissingno 패키지로 컬럼별 결측치 시각화\n\n\nimport missingno\n\nmissingno.matrix(df_chk_missing)\n\n\n\n\n\n\n\n\n\n\n결측치 확인방법3(ydata_profiling)\n\nydata_profiling 패키지로 결측치 및 다양한 값 확인 가능\n렌더링 용량 문제로 실행결과는 이미지로 대체(RangeError: Maximum call stack size exceeded)\n\n\nfrom ydata_profiling import ProfileReport\n\nprofile = ProfileReport(df_chk_missing, title=\"Profiling Report\")\nprofile\n\n\n\n\n실행결과 샘플\n\n\n\n결측치가 없으므로 다음 과정을 진행\n\n\n\n\n불필요한 변수 제거, 데이터 변환 등\n\n단순식별용 데이터 삭제\n\n가격과 관계없는 단순식별용 데이터인 id 삭제\n\n\nmain_id = df_chk_missing['id'][:train_length]\ntest_id = df_chk_missing['id'][train_length:]\ndel df_chk_missing['id']\n\n\n\n불필요한 데이터 삭제\n\n날짜 뒤에 T00000과 같이 시간데이터(로 추정됨)가 있는데, 모두 T00000으로만 되어있으므로 삭제\n\n\n# T000000으로 되어있는 값 세기\ndf_chk_missing['date'].str.contains('T000000').value_counts()\n\ndate\nTrue    21590\nName: count, dtype: int64\n\n\n\n# apply로 lambda함수를 사용하여, date컬럼의 앞자리만 저장\ndf_chk_missing['date'] = df_chk_missing['date'].apply(lambda x : str(x[:6]))\ndf_chk_missing.head()\n\n\n\n\n\n\n\n\n\ndate\nbedrooms\nbathrooms\nsqft_living\nsqft_lot\nfloors\nwaterfront\nview\ncondition\ngrade\nsqft_above\nsqft_basement\nyr_built\nyr_renovated\nzipcode\nlat\nlong\nsqft_living15\nsqft_lot15\n\n\n\n\n0\n201410\n3\n1.00\n1180\n5650\n1.0\n0\n0\n3\n7\n1180\n0\n1955\n0\n98178\n47.5112\n-122.257\n1340\n5650\n\n\n1\n201502\n2\n1.00\n770\n10000\n1.0\n0\n0\n3\n6\n770\n0\n1933\n0\n98028\n47.7379\n-122.233\n2720\n8062\n\n\n2\n201502\n3\n2.00\n1680\n8080\n1.0\n0\n0\n3\n8\n1680\n0\n1987\n0\n98074\n47.6168\n-122.045\n1800\n7503\n\n\n3\n201406\n3\n2.25\n1715\n6819\n2.0\n0\n0\n3\n7\n1715\n0\n1995\n0\n98003\n47.3097\n-122.327\n2238\n6819\n\n\n4\n201501\n3\n1.50\n1060\n9711\n1.0\n0\n0\n3\n7\n1060\n0\n1963\n0\n98198\n47.4095\n-122.315\n1650\n9711\n\n\n\n\n\n\n\n\n\n\n로그변환\n\n치우친 분포를 정규분포에 가깝게 만들기\n\n\n분포가 치우쳐져 있는 항목 찾기(시각화)\n\nrow_plot = 5\ncol_plot = 4\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(24, 35)) \n\ncolumns = df_chk_missing.columns\ncolumns_idx = 1 # 첫 컬럼인 date(날짜)는 제외하기 위해 0이 아닌 1부터 시작\nfor row in range(row_plot):\n    for col in range(col_plot):\n        sns.kdeplot(data=df_chk_missing[columns[columns_idx]], ax=ax[row][col])\n        ax[row][col].set_title(columns[columns_idx])\n        columns_idx += 1\n        if columns_idx == len(columns) :\n            break\n\n\n\n\n\n\n\n\n\n아래의 항목들이 치우쳐져 있음\n\nsqft_living\nsqft_lot\nwaterfront (→유/무 지표로 0,1만 있는게 정상이므로 제외)\nsqft_above\nsqft_basement\nsqft_living15\nsqft_lot15\n\n\n\n# 변환대상 리스트에 저장\nskewed_columns = ['sqft_living', 'sqft_lot', 'sqft_above', 'sqft_basement', 'sqft_living15', 'sqft_lot15']\n\n# 그래프로 그리기 (변환 전/후 그래프를 함께 그릴 예정이므로 plot의 수는 두배)\nrow_plot = 6\ncol_plot = 2\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(15, 35)) \n\ncolumns = skewed_columns\ncolumns_idx = 0\n\n\nfor row in range(row_plot):\n    # 로그변환 대상만 식별 후 진행\n    if columns[row] in skewed_columns:\n        # 기존 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][0])\n        ax[row][0].set_title(columns[row])\n\n        # 로그변환\n        df_chk_missing[columns[row]] = np.log1p(df_chk_missing[columns[row]])\n\n        # 변환된 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][1])\n        ax[row][1].set_title(columns[row]+'_log')\n\n\n\n\n\n\n\n\n\n\n\ntrain, test 데이터로 정리\n\npreprocessed_train = df_chk_missing[:train_length].copy()\npreprocessed_test = df_chk_missing[train_length:].copy()\nprice_train = y.copy()\n\n# date(날짜)의 타입을 int로 변경 (변경하지 않는 경우 object타입으로 인한 오류 발생)\npreprocessed_train['date'] = preprocessed_train['date'].astype(int)\npreprocessed_test['date'] = preprocessed_test['date'].astype(int)\n\nprint(preprocessed_train.shape)\nprint(preprocessed_test.shape)\n\n(15035, 19)\n(6555, 19)"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#scikit-learn-등-관련-패키지-불러오기",
    "href": "posts/coach-ml-kaggle-20230506/index.html#scikit-learn-등-관련-패키지-불러오기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "Scikit-learn 등 관련 패키지 불러오기",
    "text": "Scikit-learn 등 관련 패키지 불러오기\n\n본래 사용하는 패키지는 모두 최상단에서 불러오는게 맞음!\n\n\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.model_selection import KFold, cross_val_score\nimport xgboost as xgb\nimport lightgbm as lgb\n\n\n모델 불러오고 Cross Validation으로 모델성능 측청\n\ngboost = GradientBoostingRegressor(random_state=1210)\nxgboost = xgb.XGBRegressor(random_state=1210)\nlightgbm = lgb.LGBMRegressor(random_state=1210)\n\nmodel_dict = {'GradientBoosting':gboost,\n              'XGBoost':xgboost,\n              'LigntGBM':lightgbm}\n\n# LightGBM의 메시지가 나오지 않도록 별도로 저장 후 출력\nmodel_cv_score = dict()\nfor model in model_dict.keys():\n    model_cv_score[model] = np.mean(cross_val_score(model_dict[model], X=preprocessed_train, y=price_train))\n\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.001070 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2296\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 540497.991270\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000462 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2327\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 542956.681826\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000355 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2331\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 543149.529265\n[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.000627 seconds.\nYou can set `force_row_wise=true` to remove the overhead.\nAnd if memory is not enough, you can set `force_col_wise=true`.\n[LightGBM] [Info] Total Bins 2332\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 542032.619305\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000316 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2298\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 534776.444047\n\n\n\nfor model in model_dict.keys():\n    print(f'{model} : {model_cv_score[model]}')\n\nGradientBoosting : 0.8613647608814923\nXGBoost : 0.8762617283884332\nLigntGBM : 0.8818569800403846\n\n\n\n\n모델학습 및 예측\n\nScore가 가장 높았던 lightGBM으로 진행해보기\n\n\nmodel_dict['LigntGBM'].fit(preprocessed_train.values, y)\nprediction = model_dict['LigntGBM'].predict(preprocessed_test.values)\nprediction\n\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000727 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2338\n[LightGBM] [Info] Number of data points in the train set: 15035, number of used features: 19\n[LightGBM] [Info] Start training from score 540682.653143\n\n\narray([1296687.09405506,  311847.90404507,  806735.28228208, ...,\n       1726006.82963994,  395020.94053356,  333594.29000994])\n\n\n\n\n제출용 DataFrame 및 csv파일 생성\n\ndf_submission = pd.DataFrame({'id' : test_id, \n                              'price' : prediction})\ndf_submission\n\n\n\n\n\n\n\n\n\nid\nprice\n\n\n\n\n0\n15208\n1.296687e+06\n\n\n1\n15209\n3.118479e+05\n\n\n2\n15210\n8.067353e+05\n\n\n3\n15211\n2.098083e+05\n\n\n4\n15212\n4.343237e+05\n\n\n...\n...\n...\n\n\n6550\n21758\n4.230647e+05\n\n\n6551\n21759\n5.111171e+05\n\n\n6552\n21760\n1.726007e+06\n\n\n6553\n21761\n3.950209e+05\n\n\n6554\n21762\n3.335943e+05\n\n\n\n\n6555 rows × 2 columns\n\n\n\n\n\ndf_submission.to_csv('submission.csv', index=False)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "",
    "text": "Local L/C 업무에 대해 아래의 문제점을 인식함\n\n정보와 기능이 각기 다른 ERP메뉴에 산재되어 비효율/불편함 발생\n\n주요기능 : L/C수신, L/C등록, 세금계산서 조회, 물품수령증 조회, 은행 네고(제출)\n\n전자화된 정보임에도 각 서류간에 동일한 항목이 일치되게 기입되어있는지 눈으로 확인중\n\n예를 들어, 4개의 서류에 24자리의 세금계산서번호가 모두 똑같게 들어있는지 확인 필요\n이러한 공통정보 중 하나라도 틀리면 물품의 대금의 전부를 지급받지 못하므로 중요함\n\n각 서류와 행위에 대한 법 조항이 있어 준수해야하나, 모두 인지하고있기 어려움\n\n예를 들어, A서류가 발행되면 몇일 이내에 B서류를 제출해야 함\n\n\n문제점을 해결하기 위해 아래의 방안을 도출함\n\nDB활용\n\n각 항목을 테이블로 Primary, 공통키를 지정하여 하나의 DB로 통합\nDB의 날짜조건과 서류존재여부를 활용해 준수사항에 대해 유저에게 지시\nDB의 정보를 대조하여 유저에게 결과를 공유\n대시보드용으로 많이 사용하는 streamlit으로 UI제공\n\n업무자동화\n\nDB내용을 기반으로 유저가 직접하던 등록이나 은행제출 자동화기능 수행\n\n\n\n\n[용어설명] L/C : 물품주문서이자 대금청구시 사용될 은행계좌와 비슷한 역할 (Letter of Credit, 신용장) 물품수령증 : 고객이 물건을 정상수령하였다는 서류, 대금청구에 사용할 수 있다 은행네고 : 정상수령했다는 서류 등을 제출하여, 은행에 준비되어있는 물품대금을 받을 수 있다\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#개요",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#개요",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "",
    "text": "추진배경\n\n\n모든 정보가 하나의 ERP에 있음에도, 기능 별로 메뉴가 구분되어 있어 비효율/불편함 ↑\n\nL/C수신, L/C등록, 세금계산서 조회, 물품수령증 조회, 은행네고\n\n모든 정보가 전자화되어있으나, 각 서류의 내용(주문번호 등)이 일치하는지 눈으로 확인중\n\n24자리 영문/숫자 혼합 등이 있으며, 틀리면 물품대금을 받지 못하므로 확인이 매우 중요함\n\n[용어설명]\n**L/C** : **물품주문서**이자 **대금청구시 사용될 은행계좌**와 비슷한 역할\n    (Letter of Credit, 신용장)\n**물품수령증** : 고객이 물건을 정상수령하였다는 서류, 대금청구에 사용할 수 있다\n**은행네고** : 정상수령했다는 서류 등을 제출하여, 은행에서 물품대금을 받을 수 있다\n\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting, win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드 : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#개념",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#개념",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "개념",
    "text": "개념\nRMSE(Root Mean Squeare Error)\nRoot    (4)\nMean    (3)\nSquare  (2)\nError   (1)\n(1) 실제값에서 예측값을 뺀 '오차'를\n(2) 합했을 때 음수의 영향을 제거하기 위해 '제곱'하고\n(3) '평균'오차로 만든 후\n(4) '루트'를 씌워 값의 크기를 작게 한다 (값을 작게하여 연산속도에 이점이 있다)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#파일-다운로드-및-알아보기",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#파일-다운로드-및-알아보기",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "파일 다운로드 및 알아보기",
    "text": "파일 다운로드 및 알아보기\nFile descriptions\ntrain.csv - 예측 모델을 만들기 위해 사용하는 학습 데이터입니다. 집의 정보와 예측할 변수인 가격(Price) 변수를 가지고 있습니다.\ntest.csv - 학습셋으로 만든 모델을 가지고 예측할 가격(Price) 변수를 제외한 집의 정보가 담긴 테스트 데이터 입니다.\nsample_submission.csv - 제출시 사용할 수 있는 예시 submission.csv 파일입니다.\nData fields\nID : 집을 구분하는 번호\ndate : 집을 구매한 날짜\nprice : 집의 가격(Target variable)\nbedrooms : 침실의 수\nbathrooms : 화장실의 수\nsqft_living : 주거 공간의 평방 피트(면적)\nsqft_lot : 부지의 평방 피트(면적)\nfloors : 집의 층 수\nwaterfront : 집의 전방에 강이 흐르는지 유무 (a.k.a. 리버뷰)\nview : 집이 얼마나 좋아 보이는지의 정도\ncondition : 집의 전반적인 상태\ngrade : King County grading 시스템 기준으로 매긴 집의 등급\nsqft_above : 지하실을 제외한 평방 피트(면적)\nsqft_basement : 지하실의 평방 피트(면적)\nyr_built : 지어진 년도\nyr_renovated : 집을 재건축한 년도\nzipcode : 우편번호\nlat : 위도\nlong : 경도\nsqft_living15 : 2015년 기준 주거 공간의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)\nsqft_lot15 : 2015년 기준 부지의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#패키지-및-데이터-불러오기",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#패키지-및-데이터-불러오기",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "패키지 및 데이터 불러오기",
    "text": "패키지 및 데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ntrain_data_path = './data/train.csv'\ntest_data_path = './data/test.csv'\n\ndata = pd.read_csv(train_data_path)\ntest = pd.read_csv(test_data_path)\nprint('train data : {}'.format(data.shape))\nprint('test data : {}'.format(test.shape))\n\ntrain data : (15035, 21)\ntest data : (6555, 20)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#데이터-전처리",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#데이터-전처리",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "데이터 전처리",
    "text": "데이터 전처리\n\n정답컬럼 분리\n\ntest데이터와 달리 train data에는 컬럼이 1개 더 있음 (정답컬럼인 price)\n별도의 정답 데이터(y)로 분리\n\n\nprint('컬럼 분리 전')\nprint(data.columns)\nprint(test.columns)\n\n컬럼 분리 전\nIndex(['id', 'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living',\n       'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',\n       'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',\n       'lat', 'long', 'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\n\n\n\n# y라는 변수에 price(정답)을 옮기고, 전체데이터를 백업(data_backup에 할당)하고 price컬럼 삭제\ny = data['price'] \ndata_backup = data.copy()\ndata.drop('price',axis=1, inplace=True)\n\n\nprint('컬럼 분리 후')\nprint(data.columns)\nprint(test.columns)\nprint(y.name)\n\n컬럼 분리 후\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nprice\n\n\n\n\n결측치 확인 및 제거\n\ntrain, test 데이터를 합쳐서 한번에 확인\n\n\n# 합치기\ndf_chk_missing = pd.concat((data, test), axis=0)\n\n# 향후 분할을 대비한 행 수 저장\ntrain_length = len(data)\ntest_length = len(test)\n\nprint(train_length, test_length)\n\n15035 6555\n\n\n\n결측치 확인방법1(pandas)\n\nisna()로 결측치를 확인\n\n\nprint(df_chk_missing.isna().sum())\n\nid               0\ndate             0\nbedrooms         0\nbathrooms        0\nsqft_living      0\nsqft_lot         0\nfloors           0\nwaterfront       0\nview             0\ncondition        0\ngrade            0\nsqft_above       0\nsqft_basement    0\nyr_built         0\nyr_renovated     0\nzipcode          0\nlat              0\nlong             0\nsqft_living15    0\nsqft_lot15       0\ndtype: int64\n\n\n\n\n결측치 확인방법2(missingno)\n\nmissingno 패키지로 컬럼별 결측치 시각화\n\n\nimport missingno\n\nmissingno.matrix(df_chk_missing)\n\n\n\n\n\n\n\n\n\n\n결측치 확인방법3(ydata_profiling)\n\nydata_profiling 패키지로 결측치 및 다양한 값 확인 가능\n렌더링 용량 문제로 실행결과는 이미지로 대체(RangeError: Maximum call stack size exceeded)\n\n\nfrom ydata_profiling import ProfileReport\n\nprofile = ProfileReport(df_chk_missing, title=\"Profiling Report\")\nprofile\n\n\n\n\n실행결과 샘플\n\n\n\n결측치가 없으므로 다음 과정을 진행\n\n\n\n\n불필요한 변수 제거, 데이터 변환 등\n\n단순식별용 데이터 삭제\n\n가격과 관계없는 단순식별용 데이터인 id 삭제\n\n\nmain_id = df_chk_missing['id'][:train_length]\ntest_id = df_chk_missing['id'][train_length:]\ndel df_chk_missing['id']\n\n\n\n불필요한 데이터 삭제\n\n날짜 뒤에 T00000과 같이 시간데이터(로 추정됨)가 있는데, 모두 T00000으로만 되어있으므로 삭제\n\n\n# T000000으로 되어있는 값 세기\ndf_chk_missing['date'].str.contains('T000000').value_counts()\n\ndate\nTrue    21590\nName: count, dtype: int64\n\n\n\n# apply로 lambda함수를 사용하여, date컬럼의 앞자리만 저장\ndf_chk_missing['date'] = df_chk_missing['date'].apply(lambda x : str(x[:6]))\ndf_chk_missing.head()\n\n\n\n\n\n\n\n\n\ndate\nbedrooms\nbathrooms\nsqft_living\nsqft_lot\nfloors\nwaterfront\nview\ncondition\ngrade\nsqft_above\nsqft_basement\nyr_built\nyr_renovated\nzipcode\nlat\nlong\nsqft_living15\nsqft_lot15\n\n\n\n\n0\n201410\n3\n1.00\n1180\n5650\n1.0\n0\n0\n3\n7\n1180\n0\n1955\n0\n98178\n47.5112\n-122.257\n1340\n5650\n\n\n1\n201502\n2\n1.00\n770\n10000\n1.0\n0\n0\n3\n6\n770\n0\n1933\n0\n98028\n47.7379\n-122.233\n2720\n8062\n\n\n2\n201502\n3\n2.00\n1680\n8080\n1.0\n0\n0\n3\n8\n1680\n0\n1987\n0\n98074\n47.6168\n-122.045\n1800\n7503\n\n\n3\n201406\n3\n2.25\n1715\n6819\n2.0\n0\n0\n3\n7\n1715\n0\n1995\n0\n98003\n47.3097\n-122.327\n2238\n6819\n\n\n4\n201501\n3\n1.50\n1060\n9711\n1.0\n0\n0\n3\n7\n1060\n0\n1963\n0\n98198\n47.4095\n-122.315\n1650\n9711\n\n\n\n\n\n\n\n\n\n\n로그변환\n\n치우친 분포를 정규분포에 가깝게 만들기\n\n\n분포가 치우쳐져 있는 항목 찾기(시각화)\n\nrow_plot = 5\ncol_plot = 4\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(24, 35)) \n\ncolumns = df_chk_missing.columns\ncolumns_idx = 1 # 첫 컬럼인 date(날짜)는 제외하기 위해 0이 아닌 1부터 시작\nfor row in range(row_plot):\n    for col in range(col_plot):\n        sns.kdeplot(data=df_chk_missing[columns[columns_idx]], ax=ax[row][col])\n        ax[row][col].set_title(columns[columns_idx])\n        columns_idx += 1\n        if columns_idx == len(columns) :\n            break\n\n\n\n\n\n\n\n\n\n아래의 항목들이 치우쳐져 있음\n\nsqft_living\nsqft_lot\nwaterfront (→유/무 지표로 0,1만 있는게 정상이므로 제외)\nsqft_above\nsqft_basement\nsqft_living15\nsqft_lot15\n\n\n\n# 변환대상 리스트에 저장\nskewed_columns = ['sqft_living', 'sqft_lot', 'sqft_above', 'sqft_basement', 'sqft_living15', 'sqft_lot15']\n\n# 그래프로 그리기 (변환 전/후 그래프를 함께 그릴 예정이므로 plot의 수는 두배)\nrow_plot = 6\ncol_plot = 2\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(15, 35)) \n\ncolumns = skewed_columns\ncolumns_idx = 0\n\n\nfor row in range(row_plot):\n    # 로그변환 대상만 식별 후 진행\n    if columns[row] in skewed_columns:\n        # 기존 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][0])\n        ax[row][0].set_title(columns[row])\n\n        # 로그변환\n        df_chk_missing[columns[row]] = np.log1p(df_chk_missing[columns[row]])\n\n        # 변환된 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][1])\n        ax[row][1].set_title(columns[row]+'_log')\n\n\n\n\n\n\n\n\n\n\n\ntrain, test 데이터로 정리\n\npreprocessed_train = df_chk_missing[:train_length].copy()\npreprocessed_test = df_chk_missing[train_length:].copy()\nprice_train = y.copy()\n\n# date(날짜)의 타입을 int로 변경 (변경하지 않는 경우 object타입으로 인한 오류 발생)\npreprocessed_train['date'] = preprocessed_train['date'].astype(int)\npreprocessed_test['date'] = preprocessed_test['date'].astype(int)\n\nprint(preprocessed_train.shape)\nprint(preprocessed_test.shape)\n\n(15035, 19)\n(6555, 19)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#scikit-learn-등-관련-패키지-불러오기",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#scikit-learn-등-관련-패키지-불러오기",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "Scikit-learn 등 관련 패키지 불러오기",
    "text": "Scikit-learn 등 관련 패키지 불러오기\n\n본래 사용하는 패키지는 모두 최상단에서 불러오는게 맞음!\n\n\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.model_selection import KFold, cross_val_score\nimport xgboost as xgb\nimport lightgbm as lgb\n\n\n모델 불러오고 Cross Validation으로 모델성능 측청\n\ngboost = GradientBoostingRegressor(random_state=1210)\nxgboost = xgb.XGBRegressor(random_state=1210)\nlightgbm = lgb.LGBMRegressor(random_state=1210)\n\nmodel_dict = {'GradientBoosting':gboost,\n              'XGBoost':xgboost,\n              'LigntGBM':lightgbm}\n\n# LightGBM의 메시지가 나오지 않도록 별도로 저장 후 출력\nmodel_cv_score = dict()\nfor model in model_dict.keys():\n    model_cv_score[model] = np.mean(cross_val_score(model_dict[model], X=preprocessed_train, y=price_train))\n\n\nfor model in model_dict.keys():\n    print(f'{model} : {model_cv_score[model]}')\n\nGradientBoosting : 0.8613647608814923\nXGBoost : 0.8762617283884332\nLigntGBM : 0.8818569800403846\n\n\n\n\n모델학습 및 예측\n\nScore가 가장 높았던 lightGBM으로 진행해보기\n\n\nmodel_dict['LigntGBM'].fit(preprocessed_train.values, y)\nprediction = model_dict['LigntGBM'].predict(preprocessed_test.values)\nprediction\n\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000583 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2338\n[LightGBM] [Info] Number of data points in the train set: 15035, number of used features: 19\n[LightGBM] [Info] Start training from score 540682.653143\n\n\narray([1296687.09405506,  311847.90404507,  806735.28228208, ...,\n       1726006.82963994,  395020.94053356,  333594.29000994])\n\n\n\n\n제출용 DataFrame 및 csv파일 생성\n\ndf_submission = pd.DataFrame({'id' : test_id, \n                              'price' : prediction})\ndf_submission\n\n\n\n\n\n\n\n\n\nid\nprice\n\n\n\n\n0\n15208\n1.296687e+06\n\n\n1\n15209\n3.118479e+05\n\n\n2\n15210\n8.067353e+05\n\n\n3\n15211\n2.098083e+05\n\n\n4\n15212\n4.343237e+05\n\n\n...\n...\n...\n\n\n6550\n21758\n4.230647e+05\n\n\n6551\n21759\n5.111171e+05\n\n\n6552\n21760\n1.726007e+06\n\n\n6553\n21761\n3.950209e+05\n\n\n6554\n21762\n3.335943e+05\n\n\n\n\n6555 rows × 2 columns\n\n\n\n\n\ndf_submission.to_csv('submission.csv', index=False)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#github-repository",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "",
    "text": "각 주문서에 나뉘어있는 사용빈도가 높은 정보가 여러 탭에 나뉘어 있음\n\n탭 내에서도 많은 정보를 보여주기 위해 좁은 프레임(4행만 보임)에 많은 정보를 넣어 복사 등을 하기엔 불편함\n4행만 보이는 물품내역 프레임에 50여건의 물품이 있는 경우 많은 시간 소요\n\n크게 조회가능한 모드로 보는 경우에는 제품/모델명/HSCODE의 형식으로 문단형식으로 혼재되어있어 중복제거 등 가공 필수\n\n출발/도착지/품명 등을 전체 주문에 대해 확인하고자 하는 경우 건별로 메뉴진입 필요 (일괄로 조회하는 메뉴는 일부 정보 제외되어있음)\n\n아래의 방안으로 해결하고자 함\n\n조회속도가 빠르므로 필요한 정보를 필요할때마다 일괄 크롤링하도록 설계\n유저의 복사/가공/중복제거의 작업이 패턴화되어있어 미리 진행하여 결과물만 제공\n\n대상정보 : Sales Org, Plant(Code,Name), POL(출발지), POD(도착지), HSCODE, Description(물품명세)\n\n\n\n\n[용어설명] SR : 하나의 기본 선적 단위, Shipping request HSCODE : 해외로 물건을 보내기 위해 수출신고할 때, (의약품, 전자기기 등)물품 종류를 알 수 있는 제품 코드\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#개요",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#개요",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "",
    "text": "필요한 정보가 여러 탭에 산재되어있거나, 줄 글로 뭉쳐져있어 별도의 가공/복사과정없이 주요정보를 바로 사용하게 해주는 Tool\n확인가능한 정보 : Sales Org, Plant(Code,Name), POL, POD, HSCODE, Description"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#github-repository",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#사용법",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#사용법",
    "title": "[Python] Shipping request내 주요정보 크롤링 & 정리용 파일",
    "section": "사용법",
    "text": "사용법\n\n1건 확인 * 두번째 박스 sr_no 변수에 SR번호 1개를 입력하면 주요 정보 확인\n여러 건 확인 * 세번째 박스 sr_no 변수의 ’‘’와’’’사이에 모든 SR번호 입력 (, 즉 엔터를 기준으로 구분한다) (엑셀 등에서 표 형태로 붙여넣는 경우가 많기때문에 사용성을 고려한 옵션)\n엑셀로 저장 * 확인한 내용을 엑셀로 저장하고 싶은 경우, 네번째 박스 실행, 지정된 파일명+오늘날짜를 기준으로 다운로드 함 (몇번이나 쓸까 싶긴 하지만, 언제나 의외의 상황때문에 필요해질 수 있으니 미리 구현해두는 기능)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#사용법-및-설계의도",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#사용법-및-설계의도",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "사용법 및 설계의도",
    "text": "사용법 및 설계의도\n\n1건 확인 * 두번째 박스 sr_no 변수에 SR번호 1개를 입력하면 주요 정보 확인\n여러 건 확인 * 세번째 박스 sr_no 변수의 ’‘’와’’’사이에 모든 SR번호 입력 (, 즉 엔터를 기준으로 구분한다) (엑셀 등에서 표 형태로 붙여넣는 경우가 많기때문에 사용성을 고려한 옵션)\n엑셀로 저장 * 확인한 내용을 엑셀로 저장하고 싶은 경우, 네번째 박스 실행, 지정된 파일명+오늘날짜를 기준으로 다운로드 함 (몇번이나 쓸까 싶긴 하지만, 언제나 의외의 상황때문에 필요해질 수 있으니 미리 구현해두는 기능)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#추진배경",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "",
    "text": "Local L/C 업무에 대해 아래의 문제점을 인식함\n\n정보와 기능이 각기 다른 ERP메뉴에 산재되어 비효율/불편함 발생\n\n주요기능 : L/C수신, L/C등록, 세금계산서 조회, 물품수령증 조회, 은행 네고(제출)\n\n전자화된 정보임에도 각 서류간에 동일한 항목이 일치되게 기입되어있는지 눈으로 확인중\n\n예를 들어, 4개의 서류에 24자리의 세금계산서번호가 모두 똑같게 들어있는지 확인 필요\n이러한 공통정보 중 하나라도 틀리면 물품의 대금의 전부를 지급받지 못하므로 중요함\n\n각 서류와 행위에 대한 법 조항이 있어 준수해야하나, 모두 인지하고있기 어려움\n\n예를 들어, A서류가 발행되면 몇일 이내에 B서류를 제출해야 함\n\n\n문제점을 해결하기 위해 아래의 방안을 도출함\n\nDB활용\n\n각 항목을 테이블로 Primary, 공통키를 지정하여 하나의 DB로 통합\nDB의 날짜조건과 서류존재여부를 활용해 준수사항에 대해 유저에게 지시\nDB의 정보를 대조하여 유저에게 결과를 공유\n대시보드용으로 많이 사용하는 streamlit으로 UI제공\n\n업무자동화\n\nDB내용을 기반으로 유저가 직접하던 등록이나 은행제출 자동화기능 수행\n\n\n\n\n[용어설명] L/C : 물품주문서이자 대금청구시 사용될 은행계좌와 비슷한 역할 (Letter of Credit, 신용장) 물품수령증 : 고객이 물건을 정상수령하였다는 서류, 대금청구에 사용할 수 있다 은행네고 : 정상수령했다는 서류 등을 제출하여, 은행에 준비되어있는 물품대금을 받을 수 있다"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#구현-목적내용-및-사용한-언어패키지",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#구현-목적내용-및-사용한-언어패키지",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "구현 목적/내용 및 사용한 언어/패키지",
    "text": "구현 목적/내용 및 사용한 언어/패키지\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting, win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드 : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#구현-목적내용-사용한-언어패키지",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#구현-목적내용-사용한-언어패키지",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "구현 목적/내용 & 사용한 언어/패키지",
    "text": "구현 목적/내용 & 사용한 언어/패키지\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting, win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드 : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#구현-내용-사용한-언어패키지",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#구현-내용-사용한-언어패키지",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "구현 내용 & 사용한 언어/패키지",
    "text": "구현 내용 & 사용한 언어/패키지\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting활용을 위한 win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup, sqlite3 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드(참고용 기록) : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#효과",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#효과",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "효과",
    "text": "효과\n\nDB화 및 정보대조를 통한 Human error제거 및 물품대금 전부에 대한 정상 입수\n법적 준수사항에 대한 미준수로 인한 여러 Risk제거\n유저가 기능별 메뉴를 이동할 필요없이 하나의 통합UI에서 업무를 해결\n\n편의기능 추가 : 조치대상 내역을 클립보드로 일괄복사해주는 기능 등"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#구현내용-사용한-언어패키지-등-세부내용",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#구현내용-사용한-언어패키지-등-세부내용",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "구현내용 & 사용한 언어/패키지 등 세부내용",
    "text": "구현내용 & 사용한 언어/패키지 등 세부내용\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting활용을 위한 win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup, sqlite3 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드(참고용 기록) : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-local-20240122/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-local-20240122/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] LocalL/C 관리용 Tool",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\n정보가 파편화되어있어 하나의 Tool로써 확인하고 관리하기 위해서 Streamlit 기반으로 만듦\n\n\n정보 저장 및 조회\n\n내부정보는 ERP에서 가져와서 db에 적재(SAP Scripting활용을 위한 win32com 사용)\n외부정보는 xml을 읽어서 Tag로 필요한 정보를 찾아 db에 적재(Beautifulsoup, sqlite3 사용) (외부정보라고는 하나, ERP에 저장되어있는 xml을 불러들여서 사용함)\n데이터 저장 및 최초 쿼리는 SQL문으로 가져오나, join등 필요한 사후처리는 pandas를 활용\n\n\n\nERP에 직접 입력하는 등의 수작업을 자동으로 수행\n\n\n자동화 기능\n\nERP 수주내역 등록(고정정보는 Master화, 변동정보는 Streamlit 텍스트박스 활용)\n준수사항(법령 등)의 자동체크\n\n특정 날짜 내에 완료해야한다던가, 일치해야하는 내용 등을 자동으로 검수\nStreamlit의 table내 체크박스표기(True,False)를 활용하여 이상여부를 직관적으로 확인 가능\n사용자가 어떤 행동을 해야하는지 참고사항란을 통해 지시(연장요청, 수령증발행요청 등)\n\n보유내역 및 관리대상(작업이 완료되지 않은 건)의 Filter 기능 제공(드롭박스로 선택)\nERP의 ID, PW를 입력해두어 작업 자동화 수행\n\n개인PC에서만 사용하는 Tool이며, 표기는 ***과 같이 암호화 표기되어 관리\n\n\n\n\n설계시 고려사항, 특이사항, 참고사항\n\n\n추가/삭제/변경 등 변동될 수 있는 정보는 Hardcoding이 아닌 db형태로 저장\n\n오류 등 상황에 대비하여 실행시 기존 db를 복사해두는 로직 구현해두었으나, 자주 실행시 과생성되어 향후 수정 예정\n\nERP관련 기능은 SAP메뉴(T-code)기준으로 함수화하여 관리\n정보조회 관련 기능은 기능별 dataframe 생성/변환하는 방향으로 함수화하여 관리\nERP제어(SAP Scripting) 주요기능을 구현한 ’NERP_PI_LC’는 자체제작한 것으로 정리하여 업로드 예정(pip 미등록)\n수익자기준 주요 EDI코드(참고용 기록) : 내국신용장(LOCADV), 물품수령증(LOCRCT)\n\nBeautifulSoup를 위해 정리해둔 딕셔너리(locrct_id, locadv_id)는 표준규격일 것으로 예상하여 재사용가능할 것으로 예상\n\n\n\nLocal L/C에 대한 세부정보 참고가능한 사이트\n\nKTNET - 이용안내 - 상세업무절차"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#추진배경",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "",
    "text": "각 주문서에 나뉘어있는 사용빈도가 높은 정보가 여러 탭에 나뉘어 있음\n\n탭 내에서도 많은 정보를 보여주기 위해 좁은 프레임(4행만 보임)에 많은 정보를 넣어 복사 등을 하기엔 불편함\n4행만 보이는 물품내역 프레임에 50여건의 물품이 있는 경우 많은 시간 소요\n\n크게 조회가능한 모드로 보는 경우에는 제품/모델명/HSCODE의 형식으로 문단형식으로 혼재되어있어 중복제거 등 가공 필수\n\n출발/도착지/품명 등을 전체 주문에 대해 확인하고자 하는 경우 건별로 메뉴진입 필요 (일괄로 조회하는 메뉴는 일부 정보 제외되어있음)\n\n아래의 방안으로 해결하고자 함\n\n조회속도가 빠르므로 필요한 정보를 필요할때마다 일괄 크롤링하도록 설계\n유저의 복사/가공/중복제거의 작업이 패턴화되어있어 미리 진행하여 결과물만 제공\n\n대상정보 : Sales Org, Plant(Code,Name), POL(출발지), POD(도착지), HSCODE, Description(물품명세)\n\n\n\n\n[용어설명] SR : 하나의 기본 선적 단위, Shipping request HSCODE : 해외로 물건을 보내기 위해 수출신고할 때, (의약품, 전자기기 등)물품 종류를 알 수 있는 제품 코드"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#효과",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#효과",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "효과",
    "text": "효과\n\n단건 또는 여러건의 주문(SR)에 대해 건당 1~2초 이내로 필요한 정보 수집\n클립보드 복사가 가능한 텍스트, 엑셀형태로 제공하여 요구사항에 대해 즉시대응 가능"
  },
  {
    "objectID": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-crawl_sr-20240306/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] ERP(SAP) 특정 메뉴의 주요정보 크롤링 & 정리 Tool",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\n단건 확인시, 코드셀에 붙여넣기 후 실행, 텍스트로 출력하며 pandas dataframe으로도 저장하여 필요시 엑셀도 제공\n여러건 확인시, 엑셀 등에서 복사한 표를 코드셀에 바로 붙여넣도록 설계(자동 분할, 편의성 고려함) 이후 작업은 단건 확인과 동일\n필요시 엑셀로 저장 (기존 업무유형상 출력텍스트가 더 많이 활용될 것으로 보여 별도 기능으로 추가함)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html",
    "href": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html",
    "title": "[Python] COO발급관리용 Tool",
    "section": "",
    "text": "부서원 모두의 공통 업무이며, 여러가지 불편사항이 존재하나 자동화방안에 대한 기존 고민X\n\n필요에 의해 ID가 3개로 나뉘어있으며, 공동인증서 활용으로 타이핑작업 및 ID/PW/공동인증서PW의 관리 및 입력 불편함\n여러 건의 COO를 발급하고 대응하지만, 각 업무는 COO 1건별로 메뉴에 진입하여 수행해야함\n\n심사완료여부, 발급거절시 사유확인, 출력 및 사본 저장 등\n\n\n발급실적 담당자는 월마다 부서 전체의 발급실적을 관리하기위해 별도의 작업을 수행\n\n3개의 ID에 접속하여 20여개 페이지의 표를 복사하고, 중복/심사거절건 제거 등 수작업 가공 진행\n\n위 2가지 문제를 해결할 방법에 대한 고민 및 해결방안 도출 : 데이터의 통합db화 및 편의기능 추가\n\n공용PC를 운영중인 부서로 주기적으로 활동하는 크롤러를 운영하여 db로 저장가능\nstreamlit을 활용해 db에 대한 검색과 확인 가능한 대시보드형 사이트 제작하여 일반유저도 손쉽게 사용\n희망시 심사번호를 streamlit사이트에 등록하여 대응상황 발생시 toast알림이 가도록 제작\n축적된 db에서 월 데이터를 추출할 수 있도록 버튼을 누르면 SQL쿼리 후 Excel저장기능 추가\n3개의 ID에 대한 접속버튼으로 자동로그인 기능 추가\n\nstreamlit사이트의 정보관리메뉴에서 접속ID/PW등을 수정하면 공용PC의 json파일을 수정하여 모든유저에게 반영\n\n\n\n\n[용어설명] COO : 원산지증명서, Country of Origin\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#추진배경",
    "title": "[Python] COO발급관리용 Tool",
    "section": "",
    "text": "부서원 모두의 공통 업무이며, 여러가지 불편사항이 존재하나 자동화방안에 대한 기존 고민X\n\n필요에 의해 ID가 3개로 나뉘어있으며, 공동인증서 활용으로 타이핑작업 및 ID/PW/공동인증서PW의 관리 및 입력 불편함\n여러 건의 COO를 발급하고 대응하지만, 각 업무는 COO 1건별로 메뉴에 진입하여 수행해야함\n\n심사완료여부, 발급거절시 사유확인, 출력 및 사본 저장 등\n\n\n발급실적 담당자는 월마다 부서 전체의 발급실적을 관리하기위해 별도의 작업을 수행\n\n3개의 ID에 접속하여 20여개 페이지의 표를 복사하고, 중복/심사거절건 제거 등 수작업 가공 진행\n\n위 2가지 문제를 해결할 방법에 대한 고민 및 해결방안 도출 : 데이터의 통합db화 및 편의기능 추가\n\n공용PC를 운영중인 부서로 주기적으로 활동하는 크롤러를 운영하여 db로 저장가능\nstreamlit을 활용해 db에 대한 검색과 확인 가능한 대시보드형 사이트 제작하여 일반유저도 손쉽게 사용\n희망시 심사번호를 streamlit사이트에 등록하여 대응상황 발생시 toast알림이 가도록 제작\n축적된 db에서 월 데이터를 추출할 수 있도록 버튼을 누르면 SQL쿼리 후 Excel저장기능 추가\n3개의 ID에 대한 접속버튼으로 자동로그인 기능 추가\n\nstreamlit사이트의 정보관리메뉴에서 접속ID/PW등을 수정하면 공용PC의 json파일을 수정하여 모든유저에게 반영\n\n\n\n\n[용어설명] COO : 원산지증명서, Country of Origin"
  },
  {
    "objectID": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#효과",
    "href": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#효과",
    "title": "[Python] COO발급관리용 Tool",
    "section": "효과",
    "text": "효과\n\n크롤러, db구축, 관리 및 편의기능을 포함한 대시보드형 사이트 구축으로 기존의 불편사항들을 해결\n\n자동로그인, 대응사항 toast알림으로 지속적인 새로고침 등 불필요한 작업제거\n월마다 진행되던 불필요한 데이터 가공작업 제거(SQL쿼리 월 조건등은 사용자가 strealit사이트에서 수정 가능)\n\n기존 발급거절 사유의 db화로 주요 케이스에 대한 분석 및 사전대응계획 수립가능\n\n주요 케이스는 사전에 신고한 제품의 단위와 신청시스템 단위의 차이로, 관련 담당자에 개선제언 예정"
  },
  {
    "objectID": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#github-repository",
    "title": "[Python] COO발급관리용 Tool",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-monitoringCOO-20240220/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] COO발급관리용 Tool",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\n저장할 db는 sqlite3으로 테이블 생성, 컬럼지정 등을 수행함 (컬럼별 조건은 하단 참조)\n\n\n접수번호 varchar PRIMARY KEY , → 대표Invoice와 고민했는데, 100% 유일값이라 Primary로 지정 증명서종류 varchar,  대표Invoice varchar(10), 접수일시 datetime,  처리상태 varchar,  Remark varchar\n\n\n각 기능은 아래의 파일로 나누어 개인/공용PC에서 실행\n\n\nMonitoringCOO(기본파일) : streamlit활용한 UI, json/pickle파일 읽기, 유저의 자동로그인, 월추출 데이터 저장 등\n\n마지막 스크레핑 시점을 표기하여 얼마나 최신화된 데이터인지 유저에게 공유\n\nMonitoringCOO_crawler : selenium으로 스크레핑, 스크레핑작업에 필요한 로그인 기능(pyautogui, pywin32로 이미지/키/윈도우 인식)\n\n유저가 기본파일에서 로그인기능을 사용하는 경우, 이 파일에서 import해서 사용하고 코드는 여기서 통합관리\n스크레핑작업은 기본적으로 Scheduler파일에서 실행되지만, 필요시 이 파일을 실행하여 수동 스크레핑 (코드는 여기서 통합관리)\n\nMonitoringCOO_push : 기본파일에서 유저가 등록해둔 대표Invoice번호를 db에서 조회하여, win11toast로 알림 (처음에는 파이썬과 호환성/속도가 좋은 pickle/list로 관리하고자 했으나, 사용자ID등 추가정보 관리가 필요하여 json/dict로 관리)\nScheduler : 스크레핑 주기/시간을 관리하는 파일. 주로 공용PC에서 작업 (9~17시 이후엔 데이터변경이 없으므로 이 시간대에만 작동하도록 설정, 서버설정 등을 고려하여 작업주기 반영 예정)"
  },
  {
    "objectID": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html",
    "href": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html",
    "title": "[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록",
    "section": "",
    "text": "아래의 문제점/현황에 대해 인식\n\npdf서류(PI)에 시스템 등록에 필요한 주소 등 정보가 늘 빠져있어 별도 테이블을 참고하여 등록\n드래그 가능한 pdf를 제공받아 마우스로 일일히 드래그하여 복사/붙여넣기 반복\n제공자의 내부규정 문제로 1서류:1메일로 건별 메일로 수령, 많아지면 작업량 증가\n향후 분쟁대비를 위해, 주문번호를 파일명으로 하여 별도의 공용폴더에 저장\n여러 서류를 등록하다가 교차하여 잘못넣을시, 고객의 수입절차문제나 오배송 등 발생\n\n위의 문제점/현황으로 수입문제로 인해 고객이 물품을 받지 못할수 있는 상황을 방지하고자 해결방안 마련\n\npdf서류의 regex를 활용한 추출 및 별도 테이블의 정보를 매칭하여 정확도/속도 증가\n\n정확도 상승으로 인한 고객의 수입문제, 오배송 문제 등을 미연에 방지\n추출된 정보에 대해 검증조건을 부여하여 문제있을시 작업을 멈추고 유저에게 공유\n\n한국에서 홍콩으로 수출하지만, 책임 및 보험가입구간이 한국에서 미국으로 작성된 경우 등 논리오류\n\n\nwin32로 아웃룩에서 조건부 추출하여 여러 건에도 바로 서류를 추출하도록 설계\n추출한 주문번호로 파일명 지정 및 아카이브 자동 저장\n\n\n\n[용어설명] PI : 수출납품계약서로 발주자의 양식 등을 사용함, Proforma Invoice regex : 정규표현식, 특정한 규칙을 통해 문자를 검색/편집하는데 사용\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#추진배경",
    "title": "[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록",
    "section": "",
    "text": "아래의 문제점/현황에 대해 인식\n\npdf서류(PI)에 시스템 등록에 필요한 주소 등 정보가 늘 빠져있어 별도 테이블을 참고하여 등록\n드래그 가능한 pdf를 제공받아 마우스로 일일히 드래그하여 복사/붙여넣기 반복\n제공자의 내부규정 문제로 1서류:1메일로 건별 메일로 수령, 많아지면 작업량 증가\n향후 분쟁대비를 위해, 주문번호를 파일명으로 하여 별도의 공용폴더에 저장\n여러 서류를 등록하다가 교차하여 잘못넣을시, 고객의 수입절차문제나 오배송 등 발생\n\n위의 문제점/현황으로 수입문제로 인해 고객이 물품을 받지 못할수 있는 상황을 방지하고자 해결방안 마련\n\npdf서류의 regex를 활용한 추출 및 별도 테이블의 정보를 매칭하여 정확도/속도 증가\n\n정확도 상승으로 인한 고객의 수입문제, 오배송 문제 등을 미연에 방지\n추출된 정보에 대해 검증조건을 부여하여 문제있을시 작업을 멈추고 유저에게 공유\n\n한국에서 홍콩으로 수출하지만, 책임 및 보험가입구간이 한국에서 미국으로 작성된 경우 등 논리오류\n\n\nwin32로 아웃룩에서 조건부 추출하여 여러 건에도 바로 서류를 추출하도록 설계\n추출한 주문번호로 파일명 지정 및 아카이브 자동 저장\n\n\n\n[용어설명] PI : 수출납품계약서로 발주자의 양식 등을 사용함, Proforma Invoice regex : 정규표현식, 특정한 규칙을 통해 문자를 검색/편집하는데 사용"
  },
  {
    "objectID": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#효과",
    "href": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#효과",
    "title": "[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록",
    "section": "효과",
    "text": "효과\n\n정확도 향상으로 고객의 수입절차문제나 오배송을 미연에 방지하여 추가비용위험 제거 및 고객만족 제고\n건별 메일열람 - 논리오류 검증 - 시스템 등록(복사/붙여넣기, 별도테이블 참고) - 파일명 변경 및 저장 등 프로세스 제거 및 유저편의성 증대\n\n백그라운드에서 실행되며, 작업이 완료되면 윈도우 toast메시지로 알려 특이사항 발생시 인지 가능"
  },
  {
    "objectID": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#github-repository",
    "title": "[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-autoPIforl001-20231215/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] 아웃룩 메일열람 & pdf regex리딩 & 시스템 자동등록",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\npywin32로 아웃룩을 제어하여 조건에 맞는 pdf첨부 열람 등 진행\n\nselenium은 chrome버전변경 등 영향이 커서 구현했다가 미사용\n\nxlwings로 Excel로 저장해둔 별도 참고용 테이블을 열람\n\nDRM암호화와 관계없이 파일을 읽을 수 있기 때문에 xlwings를 채택\n\nre로 pdf의 문자열을 검색하여 필요한 내용을 저장\nNERP_PI_LC(주요 ERP관련 기능에 대해 제작한 파이썬 패키지)으로 시스템 등록 등을 진행\nwin11toast로 모든 작업이 완료되면 알림\n[삭제기능] selenium으로 PI제공자에게 자동회신도 했었으나, chrome업데이트 등 안정성 문제로 제외\n\n아웃룩 등 smtp발송은 내부규정상 막혀있어 사용하지 않음"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231101/index.html",
    "href": "posts_miniprojects/sel-py-readPIAR-20231101/index.html",
    "title": "[Python] Peak타임 대응용 수출계약서(pdf) tabula리딩",
    "section": "",
    "text": "50~120건의 서류를 아침제공 후 오전 내 입력하도록 요청받아 다른 업무가 불가능할 정도의 피크타임 발생\n\n시차, 주문접수, 생산계획 등이 맞물려 조정이 불가능한 상황\n\n동일 양식의 내용이 다른 서류 50~120건이며, 일부 내용은 별도의 수주시스템에 시스템화되어 올려져 있음\n시스템 제약으로 글자수 제한이 있어, 주문번호를 줄이는 등 별도의 작업 수행\n정확도가 높은 수주시스템의 내용(엑셀로 저장)을 기반으로, pdf로 보완하여 자동화 추진\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#추진배경",
    "title": "[Python] Peak타임 대응용 수출계약서(pdf) tabula리딩",
    "section": "",
    "text": "50~120건의 서류를 아침제공 후 오전 내 입력하도록 요청받아 다른 업무가 불가능할 정도의 피크타임 발생\n\n시차, 주문접수, 생산계획 등이 맞물려 조정이 불가능한 상황\n\n동일 양식의 내용이 다른 서류 50~120건이며, 일부 내용은 별도의 수주시스템에 시스템화되어 올려져 있음\n시스템 제약으로 글자수 제한이 있어, 주문번호를 줄이는 등 별도의 작업 수행\n정확도가 높은 수주시스템의 내용(엑셀로 저장)을 기반으로, pdf로 보완하여 자동화 추진"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#효과",
    "href": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#효과",
    "title": "[Python] Peak타임 대응용 수출계약서(pdf) tabula리딩",
    "section": "효과",
    "text": "효과\n\nTool활용을 위한 기초작업(엑셀 다운로드, pdf저장)에 5~10분 정도 소요되어, 기존 작업시간(~4시간)대비 투입시간 감소\n피크타임 감소 및 생산계획 마감시간 단축"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#github-repository",
    "title": "[Python] Peak타임 대응용 수출계약서(pdf) tabula리딩",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-readPIAR-20231101/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] Peak타임 대응용 수출계약서(pdf) tabula리딩",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\njson으로 파일을 저장할 경로정보 및 변환할 코드정보를 관리\nxlwings로 Excel로 저장해둔 기본정보를 열람\n\nDRM암호화와 관계없이 파일을 읽을 수 있기 때문에 xlwings를 채택\n\ntabula로 pdf를 표 형태로 읽어, 지정된 자리의 정보를 읽고 json형태로 저장\njson형태로 저장된 정보를 pandas DataFrame으로 concat처리 후 저장\n시스템 등록을 위해 사용중인 별도의 VBA Tool에 저장된 Excel을 넘기면 업무 완료"
  },
  {
    "objectID": "posts/prgms-sql-20240317/index.html",
    "href": "posts/prgms-sql-20240317/index.html",
    "title": "[프로그래머스SQL] 평균 일일 대여 요금 구하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/prgms-sql-20240317/index.html#개요",
    "href": "posts/prgms-sql-20240317/index.html#개요",
    "title": "[프로그래머스SQL] 평균 일일 대여 요금 구하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크"
  },
  {
    "objectID": "posts/prgms-sql-20240317/index.html#문제-평균-일일-대여-요금-구하기",
    "href": "posts/prgms-sql-20240317/index.html#문제-평균-일일-대여-요금-구하기",
    "title": "[프로그래머스SQL] 평균 일일 대여 요금 구하기",
    "section": "문제 : 평균 일일 대여 요금 구하기",
    "text": "문제 : 평균 일일 대여 요금 구하기\n\n\n\n문제 이미지"
  },
  {
    "objectID": "posts/prgms-sql-20240317/index.html#작성답안",
    "href": "posts/prgms-sql-20240317/index.html#작성답안",
    "title": "[프로그래머스SQL] 평균 일일 대여 요금 구하기",
    "section": "작성답안",
    "text": "작성답안\n\n\n\nSELECT ROUND(AVG(DAILY_FEE)) AS AVERAGE_FEE\nFROM CAR_RENTAL_COMPANY_CAR\nWHERE CAR_TYPE = 'SUV'\n\n\nFigure 1"
  },
  {
    "objectID": "posts/prgms-sql-20240317/index.html#정리",
    "href": "posts/prgms-sql-20240317/index.html#정리",
    "title": "[프로그래머스SQL] 평균 일일 대여 요금 구하기",
    "section": "정리",
    "text": "정리\n\nROUND : 반올림\nAVG : 평균\nAS ??? : 컬럼명을 ???으로 가져온다 (Alias 라고 함)\nWHERE : 작성한 조건을 기준으로 가져온다\n\nWHERE의 여러 형태예시\n\nWHERE CAR_TYPE = 'SUV'\nWHERE CAR_TYPE != 'SUV'\nWHERE DAILY_FEE &gt; 14000\nWHERE DAILY_FEE BETWEEN 14000 AND 16000\nWHERE DAILY_FEE IN (14000, 16000)\nWHERE CAR_TYPE IN ('SUV', '세단')"
  },
  {
    "objectID": "posts/prgms-sql-20240318/index.html",
    "href": "posts/prgms-sql-20240318/index.html",
    "title": "[프로그래머스SQL] 가장 비싼 상품 구하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/prgms-sql-20240318/index.html#개요",
    "href": "posts/prgms-sql-20240318/index.html#개요",
    "title": "[프로그래머스SQL] 가장 비싼 상품 구하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부"
  },
  {
    "objectID": "posts/prgms-sql-20240318/index.html#문제-가장-비싼-상품-구하기",
    "href": "posts/prgms-sql-20240318/index.html#문제-가장-비싼-상품-구하기",
    "title": "[프로그래머스SQL] 가장 비싼 상품 구하기",
    "section": "문제 : 가장 비싼 상품 구하기",
    "text": "문제 : 가장 비싼 상품 구하기\n\n\n\n문제 이미지"
  },
  {
    "objectID": "posts/prgms-sql-20240318/index.html#작성답안",
    "href": "posts/prgms-sql-20240318/index.html#작성답안",
    "title": "[프로그래머스SQL] 가장 비싼 상품 구하기",
    "section": "작성답안",
    "text": "작성답안\n\n\n\nSELECT MAX(PRICE) AS MAX_PRICE\nFROM PRODUCT\n\n\nFigure 1"
  },
  {
    "objectID": "posts/prgms-sql-20240318/index.html#정리",
    "href": "posts/prgms-sql-20240318/index.html#정리",
    "title": "[프로그래머스SQL] 가장 비싼 상품 구하기",
    "section": "정리",
    "text": "정리\n\nMAX(컬럼명) : 최대값\nMIN(컬럼명) : 최소값"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231102/index.html",
    "href": "posts_miniprojects/sel-py-readPIAR-20231102/index.html",
    "title": "[Python] Peak타임 대응용 수출계약서pdf tabula리딩",
    "section": "",
    "text": "50~120건의 pdf서류를 아침제공 후 오전 내 입력하도록 요청받아 다른 업무가 불가능할 정도의 피크타임 발생\n\n서류제공은 해외의 시차, 고객의 주문시점으로 인해 아침에 제공\n생산을 하기위한 공장또한 다른 국가에 있고, 생산계획 마감시간 문제\n각자의 이유(고객이 다양해 시점을 조정하기 어려움, 생산투입자원 조정을 위한 마감시간의 존재)로 조정 어려움\n\n문제 개선을 위해 아래의 포인트를 확인하였음\n\n제공되는 pdf서류는 모두 1장의 동일한 양식이며, 드래그가 가능한 형태\n\n드래그가 가능하다면 컴퓨터가 인식하는데도 무리가 없을테니 자동화 도입이 가능할 것이라는 판단\n\n입력작업은 엑셀VBA를 활용한 자동화Tool이 개발되어있음\n시스템 글자수 제한으로 주문번호를 축약하는 별도작업 수행\n주문번호별로 지불조건 등이 내부시스템의 코드로 매칭되어있는 별도의 관리시스템이 있음\n\n확인한 사항을 바탕으로 아래의 개선을 수행\n\n관리시스템에 이미 있는 정확도가 높은 정보를 main으로 가져옴\n시스템에서 확인할 수 없는 pdf의 정보들을 크롤링하여 필요한 정보만 식별\n이미 개발되어있는 자동화입력Tool(엑셀VBA)에 연계가능한 형태로 데이터 가공\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#추진배경",
    "href": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#추진배경",
    "title": "[Python] Peak타임 대응용 수출계약서pdf tabula리딩",
    "section": "",
    "text": "50~120건의 pdf서류를 아침제공 후 오전 내 입력하도록 요청받아 다른 업무가 불가능할 정도의 피크타임 발생\n\n서류제공은 해외의 시차, 고객의 주문시점으로 인해 아침에 제공\n생산을 하기위한 공장또한 다른 국가에 있고, 생산계획 마감시간 문제\n각자의 이유(고객이 다양해 시점을 조정하기 어려움, 생산투입자원 조정을 위한 마감시간의 존재)로 조정 어려움\n\n문제 개선을 위해 아래의 포인트를 확인하였음\n\n제공되는 pdf서류는 모두 1장의 동일한 양식이며, 드래그가 가능한 형태\n\n드래그가 가능하다면 컴퓨터가 인식하는데도 무리가 없을테니 자동화 도입이 가능할 것이라는 판단\n\n입력작업은 엑셀VBA를 활용한 자동화Tool이 개발되어있음\n시스템 글자수 제한으로 주문번호를 축약하는 별도작업 수행\n주문번호별로 지불조건 등이 내부시스템의 코드로 매칭되어있는 별도의 관리시스템이 있음\n\n확인한 사항을 바탕으로 아래의 개선을 수행\n\n관리시스템에 이미 있는 정확도가 높은 정보를 main으로 가져옴\n시스템에서 확인할 수 없는 pdf의 정보들을 크롤링하여 필요한 정보만 식별\n이미 개발되어있는 자동화입력Tool(엑셀VBA)에 연계가능한 형태로 데이터 가공"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#효과",
    "href": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#효과",
    "title": "[Python] Peak타임 대응용 수출계약서pdf tabula리딩",
    "section": "효과",
    "text": "효과\n\n고객의 주문을 당기거나, 생산계획마감이 지연되거나, 담당자의 과도한 업무가중이 발생하지 않고 문제해결\n이미 개발된 자원(엑셀VBA)에 연동하여 큰 시간을 들이지 않고 개발했으며 업무 투입시간 또한 감소\n\n기존에는 4시간 이내의 투입시간이 있었지만, 이번 도입으로 5~10분 정도로 작업이 완료됨\n기존대비 빠른 완수로 생산담당자 만족, 생산계획이 미뤄지지 않아 납기 등 제품수령 고객도 만족"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#github-repository",
    "href": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#github-repository",
    "title": "[Python] Peak타임 대응용 수출계약서pdf tabula리딩",
    "section": "github repository",
    "text": "github repository\n관련 github레포"
  },
  {
    "objectID": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/sel-py-readPIAR-20231102/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] Peak타임 대응용 수출계약서pdf tabula리딩",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\njson으로 파일을 저장할 경로정보 및 변환할 코드정보를 관리\nxlwings로 Excel로 저장해둔 기본정보를 열람\n\nDRM암호화와 관계없이 파일을 읽을 수 있기 때문에 xlwings를 채택\n\ntabula로 pdf를 표 형태로 읽어, 지정된 자리의 정보를 읽고 json형태로 저장\njson형태로 저장된 정보를 pandas DataFrame으로 concat처리 후 저장\n시스템 등록을 위해 사용중인 별도의 VBA Tool에 저장된 Excel을 넘기면 업무 완료"
  },
  {
    "objectID": "posts/prgms-sql-20240321/index.html",
    "href": "posts/prgms-sql-20240321/index.html",
    "title": "[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/prgms-sql-20240321/index.html#개요",
    "href": "posts/prgms-sql-20240321/index.html#개요",
    "title": "[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부"
  },
  {
    "objectID": "posts/prgms-sql-20240321/index.html#문제-3월에-태어난-여성-회원-목록-출력하기",
    "href": "posts/prgms-sql-20240321/index.html#문제-3월에-태어난-여성-회원-목록-출력하기",
    "title": "[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기",
    "section": "문제 : 3월에 태어난 여성 회원 목록 출력하기",
    "text": "문제 : 3월에 태어난 여성 회원 목록 출력하기\n\n\n다음은 식당 리뷰 사이트의 회원 정보를 담은 MEMBER_PROFILE 테이블입니다. MEMBER_PROFILE 테이블은 다음과 같으며 MEMBER_ID, MEMBER_NAME, TLNO, GENDER, DATE_OF_BIRTH는 회원 ID, 회원 이름, 회원 연락처, 성별, 생년월일을 의미합니다.\n\n\n\n\n\nColumn name\n\n\nType\n\n\nNullable\n\n\n\n\n\n\nMEMBER_ID\n\n\nVARCHAR(100)\n\n\nFALSE\n\n\n\n\nMEMBER_NAME\n\n\nVARCHAR(50)\n\n\nFALSE\n\n\n\n\nTLNO\n\n\nVARCHAR(50)\n\n\nTRUE\n\n\n\n\nGENDER\n\n\nVARCHAR(1)\n\n\nTRUE\n\n\n\n\nDATE_OF_BIRTH\n\n\nDATE\n\n\nTRUE\n\n\n\n\n\n\n문제\n\n\nMEMBER_PROFILE 테이블에서 생일이 3월인 여성 회원의 ID, 이름, 성별, 생년월일을 조회하는 SQL문을 작성해주세요. 이때 전화번호가 NULL인 경우는 출력대상에서 제외시켜 주시고, 결과는 회원ID를 기준으로 오름차순 정렬해주세요.\n\n\n\n예시\n\n\nMEMBER_PROFILE 테이블이 다음과 같을 때\n\n\n\n\n\nMEMBER_ID\n\n\nMEMBER_NAME\n\n\nTLNO\n\n\nGENDER\n\n\nDATE_OF_BIRTH\n\n\n\n\n\n\njiho92@naver.com\n\n\n이지호\n\n\n01076432111\n\n\nW\n\n\n1992-02-12\n\n\n\n\njiyoon22@hotmail.com\n\n\n김지윤\n\n\n01032324117\n\n\nW\n\n\n1992-02-22\n\n\n\n\njihoon93@hanmail.net\n\n\n김지훈\n\n\n01023258688\n\n\nM\n\n\n1993-02-23\n\n\n\n\nseoyeons@naver.com\n\n\n박서연\n\n\n01076482209\n\n\nW\n\n\n1993-03-16\n\n\n\n\nyoonsy94@gmail.com\n\n\n윤서연\n\n\nNULL\n\n\nW\n\n\n1994-03-19\n\n\n\n\n\nSQL을 실행하면 다음과 같이 출력되어야 합니다.\n\n\n\n\n\nMEMBER_ID\n\n\nMEMBER_NAME\n\n\nGENDER\n\n\nDATE_OF_BIRTH\n\n\n\n\n\n\nseoyeons@naver.com\n\n\n박서연\n\n\nW\n\n\n1993-03-16\n\n\n\n\n\n\n주의사항\n\n\nDATE_OF_BIRTH의 데이트 포맷이 예시와 동일해야 정답처리 됩니다."
  },
  {
    "objectID": "posts/prgms-sql-20240321/index.html#작성답안",
    "href": "posts/prgms-sql-20240321/index.html#작성답안",
    "title": "[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기",
    "section": "작성답안",
    "text": "작성답안\n\n\n\nSELECT MEMBER_ID, MEMBER_NAME,  GENDER, TO_CHAR(DATE_OF_BIRTH, 'YYYY-MM-DD')\nFROM MEMBER_PROFILE\nWHERE GENDER = 'W'\n  AND TO_CHAR(DATE_OF_BIRTH, 'MON') = 'MAR'\n  AND TLNO IS NOT NULL\nORDER BY MEMBER_ID ASC\n\n\nFigure 1"
  },
  {
    "objectID": "posts/prgms-sql-20240321/index.html#정리",
    "href": "posts/prgms-sql-20240321/index.html#정리",
    "title": "[프로그래머스SQL] 3월에 태어난 여성 회원 목록 출력하기",
    "section": "정리",
    "text": "정리\n\nWHERE 컬럼명 IS NOT NULL\nWHERE NOT 컬럼명 IS NULL"
  },
  {
    "objectID": "posts/prgms-sql-20240319/index.html",
    "href": "posts/prgms-sql-20240319/index.html",
    "title": "[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/prgms-sql-20240319/index.html#개요",
    "href": "posts/prgms-sql-20240319/index.html#개요",
    "title": "[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부"
  },
  {
    "objectID": "posts/prgms-sql-20240319/index.html#문제-조건에-맞는-도서-리스트-출력하기",
    "href": "posts/prgms-sql-20240319/index.html#문제-조건에-맞는-도서-리스트-출력하기",
    "title": "[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기",
    "section": "문제 : 조건에 맞는 도서 리스트 출력하기",
    "text": "문제 : 조건에 맞는 도서 리스트 출력하기\n\n문제 설명\n다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK) 테이블입니다.\nBOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다.\nColumn name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일\n\n\n문제\nBOOK 테이블에서 2021년에 출판된 ‘인문’ 카테고리에 속하는 도서 리스트를 찾아서 도서 ID(BOOK_ID), 출판일 (PUBLISHED_DATE)을 출력하는 SQL문을 작성해주세요. 결과는 출판일을 기준으로 오름차순 정렬해주세요.\n예시 예를 들어 BOOK 테이블이 다음과 같다면\nBOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 2 9000 2021-02-05 3 인문 2 11000 2021-04-11 4 인문 3 10000 2021-03-15 5 생활 1 12000 2021-01-10 조건에 속하는 도서는 도서 ID 가 3, 4인 도서이므로 다음과 같습니다.\nBOOK_ID PUBLISHED_DATE 3 2021-04-11 4 2021-03-15 그리고 출판일 오름차순으로 정렬하여야 하므로 다음과 같은 결과가 나와야 합니다.\nBOOK_ID PUBLISHED_DATE 4 2021-03-15 3 2021-04-11\n\n\n주의사항\nPUBLISHED_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다."
  },
  {
    "objectID": "posts/prgms-sql-20240319/index.html#작성답안",
    "href": "posts/prgms-sql-20240319/index.html#작성답안",
    "title": "[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기",
    "section": "작성답안",
    "text": "작성답안\n\n\n\nSELECT BOOK_ID, TO_CHAR(PUBLISHED_DATE, 'YYYY-MM-DD')\nFROM BOOK\nWHERE CATEGORY = '인문' AND EXTRACT(YEAR FROM PUBLISHED_DATE) = 2021\nORDER BY PUBLISHED_DATE ASC\n\n\nFigure 1"
  },
  {
    "objectID": "posts/prgms-sql-20240319/index.html#정리",
    "href": "posts/prgms-sql-20240319/index.html#정리",
    "title": "[프로그래머스SQL] 조건에 맞는 도서 리스트 출력하기",
    "section": "정리",
    "text": "정리\n\nTO_CHAR(표시형식 변경)\n\n\nSELECT TO_CHAR(컬럼명, ‘표시형식’) FROM 테이블명 표시형식(연도 4자리) : TO_CHAR(컬럼명, ‘YYYY’) 표시형식(월) : TO_CHAR(컬럼명, ‘MM’) 표시형식(일, 연기준 1~366) : TO_CHAR(컬럼명, ‘DDD’) 표시형식(일, 일기준 1~31) : TO_CHAR(컬럼명, ‘DD’) 표시형식(일, 요일) : TO_CHAR(컬럼명, ‘D’) * 지역설정에 따라 시작요일이 달라짐  표시형식(분기) : TO_CHAR(컬럼명, ‘Q’) 표시형식(주, 연기준 1~53) : TO_CHAR(컬럼명, ‘WW’) 표시형식(주, 월기준 1~53) : TO_CHAR(컬럼명, ‘W’)  표시형식(요일, MON/월) : TO_CHAR(컬럼명, ‘DY’) 표시형식(요일, MONDAY/월요일) : TO_CHAR(컬럼명, ‘DAY’) 표시형식(월, JAN/1월) : TO_CHAR(컬럼명, ‘MON’) 표시형식(월, JANUARY/1월) : TO_CHAR(컬럼명, ‘MONTH’)  표시형식(시간, 12시간표기) : TO_CHAR(컬럼명, ‘HH12’) 표시형식(시간, 24시간표기) : TO_CHAR(컬럼명, ‘HH24’) 표시형식(분) : TO_CHAR(컬럼명, ‘MI’) 표시형식(초) : TO_CHAR(컬럼명, ‘SS’)\n\n\nAND(모두 만족) / OR(하나라도 만족) / NOT(조건과 맞지 않는)\n\n\n연산자 우선순위(참고용) 1 괄호 2 NOT 3 비교 (&gt; &lt; = !) 4 AND 5 OR\n\n\nORDER BY 컬럼명 ASC (오름차순)\nORDER BY 컬럼명 DESC (내림차순)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html",
    "href": "posts/meta-dl-creditcard-20240609/index.html",
    "title": "[M_Study_3주차] Multi-class Classification / Artificial Neural Network",
    "section": "",
    "text": "참여중인 딥러닝 스터디 3주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#주차-과제-logistic-regression-코드-작성한-것",
    "href": "posts/meta-dl-creditcard-20240609/index.html#주차-과제-logistic-regression-코드-작성한-것",
    "title": "[M_Study_3주차] Multi-class Classification / Artificial Neural Network",
    "section": "2주차 과제 Logistic regression 코드 작성한 것",
    "text": "2주차 과제 Logistic regression 코드 작성한 것\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tensorflow as tf\n\n# Train data\nX_train = np.array([[1., 1.],\n                   [1., 2.],\n                   [2., 1.],\n                   [3., 2.],\n                   [3., 3.],\n                   [2., 3.]],\n                   dtype=np.float32)\nY_train = np.array([[0.],\n                   [0.],\n                   [0.],\n                   [1.],\n                   [1.],\n                   [1.],],\n                   dtype=np.float32)\n\n# 회귀선 작성 전 분포확인\ncolors=['red' if L&gt;0.5 else 'blue' for L in Y_train]\nplt.scatter(X_train[:,0], X_train[:, 1], label='Logistics regression', color=colors)\n\n\n\nimage.png\n\n\n# 모델 학습\ntf.random.set_seed(2020)\nW = tf.Variable(tf.random.normal([2,1], mean=0.0))\nb = tf.Variable(tf.random.normal([1], mean=0.0))\n\ndef hypothesis(X):\n    z = tf.matmul(X, W) + b\n    sigmoid = 1 / (1 + tf.exp(-z))\n    return sigmoid\n\ndef cost_fn(H, Y):\n    cost = -tf.reduce_mean(Y*tf.math.log(H) + (1-Y)*tf.math.log(1-H))\n    return cost\n\nlearning_rate = 0.01\noptimizer = tf.optimizers.SGD(learning_rate)\n\nfor step in range(5001):\n    with tf.GradientTape() as g:\n        pred = hypothesis(X_train)\n        cost = cost_fn(pred, Y_train)\n\n        gradients = g.gradient(cost, [W,b])\n    \n    optimizer.apply_gradients(zip(gradients, [W, b]))\n\n    if step % 1000 == 0:\n        print(f'Step={step+1}, Cost = {cost}, W={W.numpy()}, b = {b.numpy()}')\n\nw_hat = W.numpy()\nb_hat = b.numpy()\n\nStep=1, Cost = 0.7932398319244385, W=[[-0.10415223] [0.68125504]], b = [0.3810195]  Step=1001, Cost = 0.5122759938240051, W=[[0.1809378] [0.55177015]], b = [-0.97815347]  Step=2001, Cost = 0.39883172512054443, W=[[0.5135696] [0.6884617]], b = [-1.9777462]  Step=3001, Cost = 0.32507583498954773, W=[[0.7515713] [0.8368167]], b = [-2.7877953]  Step=4001, Cost = 0.27400580048561096, W=[[0.9350327] [0.97824335]], b = [-3.4628296]  Step=5001, Cost = 0.2367737740278244, W=[[1.0848083] [1.1075894]], b = [-4.039375]\n\n# Slope(Coefficient) 확인\nslope = w_hat[0]/w_hat[1]\nxx = np.linspace(np.min(X_train[:,0]),np.max(X_train[:,0])) # min과 max 사이 구간의 숫자를 생성. x값\nyy = -slope*xx - b_hat/w_hat[1]                             # xx(x값)입력하여 y값 생성\n\n# train data분포\nplt.scatter(X_train[:, 0], X_train[:, 1], label='Logistics regression', color=colors)\n\n# 분류선(Decision Boundary)확인\nplt.plot(xx, yy, label='Decision Boundary')\nplt.legend()\n\n\n\nimage-2.png\n\n\n# Confusion matrix\nfrom sklearn.metrics import confusion_matrix\n\nX_test = np.array([[1., 0.],\n                   [0., 2.],\n                   [1., 1.],\n                   [3., 2.],\n                   [3., 3.],\n                   [2., 3.]],\n                   dtype=np.float32)\nY_test = np.array([[0.],\n                   [0.],\n                   [1.],\n                   [0.],\n                   [1.],\n                   [0.],],\n                   dtype=np.float32)\n\nY_actual = Y_test\nY_predicted = hypothesis(X_test)\nY_predicted_binary = np.where(Y_predicted &gt;= 0.5, 1, 0)\n\nCM_array = confusion_matrix(Y_actual, Y_predicted_binary, labels=[0, 1]) \nCM_array\n\narray([[2, 2], [1, 1]], dtype=int64)\n\n# Confusion matrix 시각화(seaborn)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nclass_labels = ['Negative', 'Positive']\nplt.figure(figsize=(8, 6))\nsns.heatmap(CM_array, annot=True, cmap='Blues',\n            xticklabels=class_labels, yticklabels=class_labels)\n\nplt.title('Confusion Matrix')\nplt.xlabel('Predicted')\nplt.ylabel('True')\n\n\n\nimage-3.png\n\n\n# Confusion matrix 시각화(Scikit-learn)\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\ndisp = ConfusionMatrixDisplay(confusion_matrix=CM_array, display_labels=[0, 1])\ndisp.plot(cmap=plt.cm.Blues)\nplt.title('Confusion Matrix')\nplt.show()\n\n\n\nimage-4.png"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#multi-class-classfication-regression",
    "href": "posts/meta-dl-creditcard-20240609/index.html#multi-class-classfication-regression",
    "title": "[M_Study_3주차] Multi-class Classification / Artificial Neural Network",
    "section": "Multi-class Classfication regression",
    "text": "Multi-class Classfication regression\n\n2가지 분류가 아닌 3가지 이상의 분류(A,B,C로 나누는 신용등급 등)\nBinary classification과 달리 하나의 Decision boundary로는 해결 불가\nOne vs All(Rest)\n\n하나의 대상과, 아닌 것’들’로 Binary Classification을 여러번 수행\n예를 들어 a, b, c 3가지를 분류하는 경우\n\n아래와 같은 같은 3개의 식으로 표현할 수 있고, \n아래와 같이 하나의 행렬로 한번에 표현할 수 있다  \n\nSoftmax : 각 결과값(\\(H_a, H_b, H_c\\))의 비율(확률)이 나오게 됨(총합이 1)\n\nCross entropy cost function\n\n정보량은 확률에 반비례한다고 정의 (정보량= $ 1 p$)\n\n특정 성씨의 사람을 뽑는다고 할 때, 한국의 주요 성씨인 김씨\\(1 \\over 10\\) vs 소수 성씨인 남궁씨\\(1 \\over 100\\)\n\n로그를 취하여 전개하면 Cross entropy 식이 된다\nEntropy : Measure for uncertainty (불확실성의 측정)  \nCase별 Cross entropy(cost function)\n\n출력값(결과값 softmax)과 실제값이 비슷한 경우 : 특정 값 산출\n출력값(결과값 softmax)과 실제값이 완전히 다른 경우 : 무한대\n출력값(결과값 softmax)과 실제값이 완전히 동일한 경우 : 0\n\nCross entropy를 개인이 직접구현한다면 놓칠 수 있는 부분(cross entropy의 무한대)의 문제\n\n파이토치 등 많은 사람이 참여한 패키지를 사용하면 방지할 수 있음\n컴퓨터에서의 Zero division error 등의 경우, 텐서플로우 등 패키지에선 분모에 0.00001등을 더하여 실제값엔 영향이 작게하며 오류 제거"
  },
  {
    "objectID": "posts/prgms-sql-20240320/index.html",
    "href": "posts/prgms-sql-20240320/index.html",
    "title": "[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/prgms-sql-20240320/index.html#개요",
    "href": "posts/prgms-sql-20240320/index.html#개요",
    "title": "[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기",
    "section": "",
    "text": "프로그래머스 SQL 문제풀이 연습(Oracle기준, Mysql아님)입니다  (비상업적, 비영리적 용도)\n문제링크 게시가능여부"
  },
  {
    "objectID": "posts/prgms-sql-20240320/index.html#문제-조건에-부합하는-중고거래-댓글-조회하기",
    "href": "posts/prgms-sql-20240320/index.html#문제-조건에-부합하는-중고거래-댓글-조회하기",
    "title": "[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기",
    "section": "문제 : 조건에 부합하는 중고거래 댓글 조회하기",
    "text": "문제 : 조건에 부합하는 중고거래 댓글 조회하기\n\n    &lt;h6 class=\"guide-section-title\"&gt;문제 설명&lt;/h6&gt;\n    &lt;div class=\"markdown solarized-dark\"&gt;&lt;p&gt;다음은 중고거래 게시판 정보를 담은 &lt;code&gt;USED_GOODS_BOARD&lt;/code&gt; 테이블과 중고거래 게시판 첨부파일 정보를 담은 &lt;code&gt;USED_GOODS_REPLY&lt;/code&gt; 테이블입니다. &lt;code&gt;USED_GOODS_BOARD&lt;/code&gt; 테이블은 다음과 같으며 &lt;code&gt;BOARD_ID&lt;/code&gt;, &lt;code&gt;WRITER_ID&lt;/code&gt;, &lt;code&gt;TITLE&lt;/code&gt;, &lt;code&gt;CONTENTS&lt;/code&gt;, &lt;code&gt;PRICE&lt;/code&gt;, &lt;code&gt;CREATED_DATE&lt;/code&gt;, &lt;code&gt;STATUS&lt;/code&gt;, &lt;code&gt;VIEWS&lt;/code&gt;은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다.&lt;/p&gt;\n\n\n\n\nColumn name\n\n\nType\n\n\nNullable\n\n\n\n\n\n\nBOARD_ID\n\n\nVARCHAR(5)\n\n\nFALSE\n\n\n\n\nWRITER_ID\n\n\nVARCHAR(50)\n\n\nFALSE\n\n\n\n\nTITLE\n\n\nVARCHAR(100)\n\n\nFALSE\n\n\n\n\nCONTENTS\n\n\nVARCHAR(1000)\n\n\nFALSE\n\n\n\n\nPRICE\n\n\nNUMBER\n\n\nFALSE\n\n\n\n\nCREATED_DATE\n\n\nDATE\n\n\nFALSE\n\n\n\n\nSTATUS\n\n\nVARCHAR(10)\n\n\nFALSE\n\n\n\n\nVIEWS\n\n\nNUMBER\n\n\nFALSE\n\n\n\n\n\nUSED_GOODS_REPLY 테이블은 다음과 같으며 REPLY_ID, BOARD_ID, WRITER_ID, CONTENTS, CREATED_DATE는 각각 댓글 ID, 게시글 ID, 작성자 ID, 댓글 내용, 작성일을 의미합니다.\n\n\n\n\n\nColumn name\n\n\nType\n\n\nNullable\n\n\n\n\n\n\nREPLY_ID\n\n\nVARCHAR(10)\n\n\nFALSE\n\n\n\n\nBOARD_ID\n\n\nVARCHAR(5)\n\n\nFALSE\n\n\n\n\nWRITER_ID\n\n\nVARCHAR(50)\n\n\nFALSE\n\n\n\n\nCONTENTS\n\n\nVARCHAR(1000)\n\n\nTRUE\n\n\n\n\nCREATED_DATE\n\n\nDATE\n\n\nFALSE\n\n\n\n\n\n\n문제\n\n\nUSED_GOODS_BOARD와 USED_GOODS_REPLY 테이블에서 2022년 10월에 작성된 게시글 제목, 게시글 ID, 댓글 ID, 댓글 작성자 ID, 댓글 내용, 댓글 작성일을 조회하는 SQL문을 작성해주세요. 결과는 댓글 작성일을 기준으로 오름차순 정렬해주시고, 댓글 작성일이 같다면 게시글 제목을 기준으로 오름차순 정렬해주세요.\n\n\n\n예시\n\n\nUSED_GOODS_BOARD 테이블이 다음과 같고\n\n\n\n\n\nBOARD_ID\n\n\nWRITER_ID\n\n\nTITLE\n\n\nCONTENTS\n\n\nPRICE\n\n\nCREATED_DATE\n\n\nSTATUS\n\n\nVIEWS\n\n\n\n\n\n\nB0001\n\n\nkwag98\n\n\n반려견 배변패드 팝니다\n\n\n정말 저렴히 판매합니다. 전부 미개봉 새상품입니다.\n\n\n12000\n\n\n2022-10-01\n\n\nDONE\n\n\n250\n\n\n\n\nB0002\n\n\nlee871201\n\n\n국내산 볶음참깨\n\n\n직접 농사지은 참깨입니다.\n\n\n3000\n\n\n2022-10-02\n\n\nDONE\n\n\n121\n\n\n\n\nB0003\n\n\ngoung12\n\n\n배드민턴 라켓\n\n\n사놓고 방치만 해서 팝니다.\n\n\n9000\n\n\n2022-10-02\n\n\nSALE\n\n\n212\n\n\n\n\nB0004\n\n\nkeel1990\n\n\n디올 귀걸이\n\n\n신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불\n\n\n130000\n\n\n2022-10-02\n\n\nSALE\n\n\n199\n\n\n\n\nB0005\n\n\nhaphli01\n\n\n스팸클래식 팔아요\n\n\n유통기한 2025년까지에요\n\n\n10000\n\n\n2022-10-02\n\n\nSALE\n\n\n121\n\n\n\n\n\nUSED_GOODS_REPLY 테이블이 다음과 같을 때\n\n\n\n\n\nREPLY_ID\n\n\nBOARD_ID\n\n\nWRITER_ID\n\n\nCONTENTS\n\n\nCREATED_DATE\n\n\n\n\n\n\nR000000001\n\n\nB0001\n\n\ns2s2123\n\n\n구매하겠습니다. 쪽지 드립니다.\n\n\n2022-10-02\n\n\n\n\nR000000002\n\n\nB0002\n\n\nhoho1112\n\n\n쪽지 주세요.\n\n\n2022-10-03\n\n\n\n\nR000000003\n\n\nB0006\n\n\nhwahwa2\n\n\n삽니다. 연락주세요.\n\n\n2022-10-03\n\n\n\n\nR000000004\n\n\nB0007\n\n\nhong02\n\n\n예약중\n\n\n2022-10-06\n\n\n\n\nR000000005\n\n\nB0009\n\n\nhanju23\n\n\n구매완료\n\n\n2022-10-07\n\n\n\n\n\nSQL을 실행하면 다음과 같이 출력되어야 합니다.\n\n\n\n\n\nTITLE\n\n\nBOARD_ID\n\n\nREPLY_ID\n\n\nWRITER_ID\n\n\nCONTENTS\n\n\nCREATED_DATE\n\n\n\n\n\n\n반려견 배변패드 팝니다\n\n\nB0001\n\n\nR000000001\n\n\ns2s2123\n\n\n구매하겠습니다. 쪽지 드립니다.\n\n\n2022-10-02\n\n\n\n\n국내산 볶음참깨\n\n\nB0002\n\n\nR000000002\n\n\nhoho1112\n\n\n쪽지 주세요.\n\n\n2022-10-03\n\n\n\n\n\n\n주의사항\n\n\nCREATED_DATE의 포맷이 예시의 포맷과 일치해야 정답처리 됩니다.\n\n\n  &lt;/div&gt;"
  },
  {
    "objectID": "posts/prgms-sql-20240320/index.html#작성답안",
    "href": "posts/prgms-sql-20240320/index.html#작성답안",
    "title": "[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기",
    "section": "작성답안",
    "text": "작성답안\n\n\n\nSELECT board.TITLE, board.BOARD_ID,\n       reply.REPLY_ID, reply.WRITER_ID, reply.CONTENTS, TO_CHAR(reply.CREATED_DATE, 'YYYY-MM-DD')\nFROM USED_GOODS_BOARD board, USED_GOODS_REPLY reply\nWHERE TO_CHAR(board.CREATED_DATE, 'YYYYMM') = '202210'\n  AND board.BOARD_ID = reply.BOARD_ID\nORDER BY reply.CREATED_DATE ASC, board.TITLE ASC;\n\n\nFigure 1"
  },
  {
    "objectID": "posts/prgms-sql-20240320/index.html#정리",
    "href": "posts/prgms-sql-20240320/index.html#정리",
    "title": "[프로그래머스SQL] 조건에 부합하는 중고거래 댓글 조회하기",
    "section": "정리",
    "text": "정리\n\n각 테이블의 BOARD_ID 일치시키는 것을 실수하였음. 향후 동일케이스에 대해서는 고려하여 풀기\n다중정렬 &gt; ORDER BY reply.CREATED_DATE ASC, board.TITLE ASC; 앞의 컬럼일수록 정렬 우선순위를 가짐"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240609/index.html#개요",
    "title": "[M_Study_3주차] Multi-class Classification / Artificial Neural Network",
    "section": "",
    "text": "참여중인 딥러닝 스터디 3주차 기록입니다."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#개념",
    "href": "posts/meta-dl-creditcard-20240609/index.html#개념",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "개념",
    "text": "개념\nRMSE(Root Mean Squeare Error)\nRoot    (4)\nMean    (3)\nSquare  (2)\nError   (1)\n(1) 실제값에서 예측값을 뺀 '오차'를\n(2) 합했을 때 음수의 영향을 제거하기 위해 '제곱'하고\n(3) '평균'오차로 만든 후\n(4) '루트'를 씌워 값의 크기를 작게 한다 (값을 작게하여 연산속도에 이점이 있다)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#파일-다운로드-및-알아보기",
    "href": "posts/meta-dl-creditcard-20240609/index.html#파일-다운로드-및-알아보기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "파일 다운로드 및 알아보기",
    "text": "파일 다운로드 및 알아보기\nFile descriptions\ntrain.csv - 예측 모델을 만들기 위해 사용하는 학습 데이터입니다. \n    집의 정보와 예측할 변수인 가격(Price) 변수를 가지고 있습니다.\ntest.csv - 학습셋으로 만든 모델을 가지고 예측할 가격(Price) 변수를 제외한 집의 정보가\n    담긴 테스트 데이터 입니다.\nsample_submission.csv - 제출시 사용할 수 있는 예시 submission.csv 파일입니다.\nData fields\nID : 집을 구분하는 번호\ndate : 집을 구매한 날짜\nprice : 집의 가격(Target variable)\nbedrooms : 침실의 수\nbathrooms : 화장실의 수\nsqft_living : 주거 공간의 평방 피트(면적)\nsqft_lot : 부지의 평방 피트(면적)\nfloors : 집의 층 수\nwaterfront : 집의 전방에 강이 흐르는지 유무 (a.k.a. 리버뷰)\nview : 집이 얼마나 좋아 보이는지의 정도\ncondition : 집의 전반적인 상태\ngrade : King County grading 시스템 기준으로 매긴 집의 등급\nsqft_above : 지하실을 제외한 평방 피트(면적)\nsqft_basement : 지하실의 평방 피트(면적)\nyr_built : 지어진 년도\nyr_renovated : 집을 재건축한 년도\nzipcode : 우편번호\nlat : 위도\nlong : 경도\nsqft_living15 : 2015년 기준 주거 공간의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)\nsqft_lot15 : 2015년 기준 부지의 평방 피트(면적, 집을 재건축했다면, 변화가 있을 수 있음)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#패키지-및-데이터-불러오기",
    "href": "posts/meta-dl-creditcard-20240609/index.html#패키지-및-데이터-불러오기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "패키지 및 데이터 불러오기",
    "text": "패키지 및 데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ntrain_data_path = './data/train.csv'\ntest_data_path = './data/test.csv'\n\ndata = pd.read_csv(train_data_path)\ntest = pd.read_csv(test_data_path)\nprint('train data : {}'.format(data.shape))\nprint('test data : {}'.format(test.shape))\n\ntrain data : (15035, 21)\ntest data : (6555, 20)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#데이터-전처리",
    "href": "posts/meta-dl-creditcard-20240609/index.html#데이터-전처리",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "데이터 전처리",
    "text": "데이터 전처리\n\n정답컬럼 분리\n\ntest데이터와 달리 train data에는 컬럼이 1개 더 있음 (정답컬럼인 price)\n별도의 정답 데이터(y)로 분리\n\n\nprint('컬럼 분리 전')\nprint(data.columns)\nprint(test.columns)\n\n컬럼 분리 전\nIndex(['id', 'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living',\n       'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',\n       'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',\n       'lat', 'long', 'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\n\n\n\n# y라는 변수에 price(정답)을 옮기고, 전체데이터를 백업(data_backup에 할당)하고 price컬럼 삭제\ny = data['price'] \ndata_backup = data.copy()\ndata.drop('price',axis=1, inplace=True)\n\n\nprint('컬럼 분리 후')\nprint(data.columns)\nprint(test.columns)\nprint(y.name)\n\n컬럼 분리 후\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nIndex(['id', 'date', 'bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot',\n       'floors', 'waterfront', 'view', 'condition', 'grade', 'sqft_above',\n       'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long',\n       'sqft_living15', 'sqft_lot15'],\n      dtype='object')\nprice\n\n\n\n\n결측치 확인 및 제거\n\ntrain, test 데이터를 합쳐서 한번에 확인\n\n\n# 합치기\ndf_chk_missing = pd.concat((data, test), axis=0)\n\n# 향후 분할을 대비한 행 수 저장\ntrain_length = len(data)\ntest_length = len(test)\n\nprint(train_length, test_length)\n\n15035 6555\n\n\n\n결측치 확인방법1(pandas)\n\nisna()로 결측치를 확인\n\n\nprint(df_chk_missing.isna().sum())\n\nid               0\ndate             0\nbedrooms         0\nbathrooms        0\nsqft_living      0\nsqft_lot         0\nfloors           0\nwaterfront       0\nview             0\ncondition        0\ngrade            0\nsqft_above       0\nsqft_basement    0\nyr_built         0\nyr_renovated     0\nzipcode          0\nlat              0\nlong             0\nsqft_living15    0\nsqft_lot15       0\ndtype: int64\n\n\n\n\n결측치 확인방법2(missingno)\n\nmissingno 패키지로 컬럼별 결측치 시각화\n\n\nimport missingno\n\nmissingno.matrix(df_chk_missing)\n\n\n\n\n\n\n\n\n\n\n결측치 확인방법3(ydata_profiling)\n\nydata_profiling 패키지로 결측치 및 다양한 값 확인 가능\n렌더링 용량 문제로 실행결과는 이미지로 대체(RangeError: Maximum call stack size exceeded)\n\n\nfrom ydata_profiling import ProfileReport\n\nprofile = ProfileReport(df_chk_missing, title=\"Profiling Report\")\nprofile\n\n\n\n\n실행결과 샘플\n\n\n\n결측치가 없으므로 다음 과정을 진행\n\n\n\n\n불필요한 변수 제거, 데이터 변환 등\n\n단순식별용 데이터 삭제\n\n가격과 관계없는 단순식별용 데이터인 id 삭제\n\n\nmain_id = df_chk_missing['id'][:train_length]\ntest_id = df_chk_missing['id'][train_length:]\ndel df_chk_missing['id']\n\n\n\n불필요한 데이터 삭제\n\n날짜 뒤에 T00000과 같이 시간데이터(로 추정됨)가 있는데, 모두 T00000으로만 되어있으므로 삭제\n\n\n# T000000으로 되어있는 값 세기\ndf_chk_missing['date'].str.contains('T000000').value_counts()\n\ndate\nTrue    21590\nName: count, dtype: int64\n\n\n\n# apply로 lambda함수를 사용하여, date컬럼의 앞자리만 저장\ndf_chk_missing['date'] = df_chk_missing['date'].apply(lambda x : str(x[:6]))\ndf_chk_missing.head()\n\n\n\n\n\n\n\n\n\ndate\nbedrooms\nbathrooms\nsqft_living\nsqft_lot\nfloors\nwaterfront\nview\ncondition\ngrade\nsqft_above\nsqft_basement\nyr_built\nyr_renovated\nzipcode\nlat\nlong\nsqft_living15\nsqft_lot15\n\n\n\n\n0\n201410\n3\n1.00\n1180\n5650\n1.0\n0\n0\n3\n7\n1180\n0\n1955\n0\n98178\n47.5112\n-122.257\n1340\n5650\n\n\n1\n201502\n2\n1.00\n770\n10000\n1.0\n0\n0\n3\n6\n770\n0\n1933\n0\n98028\n47.7379\n-122.233\n2720\n8062\n\n\n2\n201502\n3\n2.00\n1680\n8080\n1.0\n0\n0\n3\n8\n1680\n0\n1987\n0\n98074\n47.6168\n-122.045\n1800\n7503\n\n\n3\n201406\n3\n2.25\n1715\n6819\n2.0\n0\n0\n3\n7\n1715\n0\n1995\n0\n98003\n47.3097\n-122.327\n2238\n6819\n\n\n4\n201501\n3\n1.50\n1060\n9711\n1.0\n0\n0\n3\n7\n1060\n0\n1963\n0\n98198\n47.4095\n-122.315\n1650\n9711\n\n\n\n\n\n\n\n\n\n\n로그변환\n\n치우친 분포를 정규분포에 가깝게 만들기\n\n\n분포가 치우쳐져 있는 항목 찾기(시각화)\n\nrow_plot = 5\ncol_plot = 4\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(24, 35)) \n\ncolumns = df_chk_missing.columns\ncolumns_idx = 1 # 첫 컬럼인 date(날짜)는 제외하기 위해 0이 아닌 1부터 시작\nfor row in range(row_plot):\n    for col in range(col_plot):\n        sns.kdeplot(data=df_chk_missing[columns[columns_idx]], ax=ax[row][col])\n        ax[row][col].set_title(columns[columns_idx])\n        columns_idx += 1\n        if columns_idx == len(columns) :\n            break\n\n\n\n\n\n\n\n\n\n아래의 항목들이 치우쳐져 있음\n\nsqft_living\nsqft_lot\nwaterfront (→유/무 지표로 0,1만 있는게 정상이므로 제외)\nsqft_above\nsqft_basement\nsqft_living15\nsqft_lot15\n\n\n\n# 변환대상 리스트에 저장\nskewed_columns = ['sqft_living', 'sqft_lot', 'sqft_above', 'sqft_basement', 'sqft_living15', 'sqft_lot15']\n\n# 그래프로 그리기 (변환 전/후 그래프를 함께 그릴 예정이므로 plot의 수는 두배)\nrow_plot = 6\ncol_plot = 2\nfig, ax = plt.subplots(row_plot, col_plot, figsize=(15, 35)) \n\ncolumns = skewed_columns\ncolumns_idx = 0\n\n\nfor row in range(row_plot):\n    # 로그변환 대상만 식별 후 진행\n    if columns[row] in skewed_columns:\n        # 기존 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][0])\n        ax[row][0].set_title(columns[row])\n\n        # 로그변환\n        df_chk_missing[columns[row]] = np.log1p(df_chk_missing[columns[row]])\n\n        # 변환된 그래프 그리기\n        sns.kdeplot(data=df_chk_missing[columns[row]], ax=ax[row][1])\n        ax[row][1].set_title(columns[row]+'_log')\n\n\n\n\n\n\n\n\n\n\n\ntrain, test 데이터로 정리\n\npreprocessed_train = df_chk_missing[:train_length].copy()\npreprocessed_test = df_chk_missing[train_length:].copy()\nprice_train = y.copy()\n\n# date(날짜)의 타입을 int로 변경 (변경하지 않는 경우 object타입으로 인한 오류 발생)\npreprocessed_train['date'] = preprocessed_train['date'].astype(int)\npreprocessed_test['date'] = preprocessed_test['date'].astype(int)\n\nprint(preprocessed_train.shape)\nprint(preprocessed_test.shape)\n\n(15035, 19)\n(6555, 19)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#scikit-learn-등-관련-패키지-불러오기",
    "href": "posts/meta-dl-creditcard-20240609/index.html#scikit-learn-등-관련-패키지-불러오기",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "Scikit-learn 등 관련 패키지 불러오기",
    "text": "Scikit-learn 등 관련 패키지 불러오기\n\n본래 사용하는 패키지는 모두 최상단에서 불러오는게 맞음!\n\n\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.model_selection import KFold, cross_val_score\nimport xgboost as xgb\nimport lightgbm as lgb\n\n\n모델 불러오고 Cross Validation으로 모델성능 측청\n\ngboost = GradientBoostingRegressor(random_state=1210)\nxgboost = xgb.XGBRegressor(random_state=1210)\nlightgbm = lgb.LGBMRegressor(random_state=1210)\n\nmodel_dict = {'GradientBoosting':gboost,\n              'XGBoost':xgboost,\n              'LigntGBM':lightgbm}\n\n# LightGBM의 메시지가 나오지 않도록 별도로 저장 후 출력\nmodel_cv_score = dict()\nfor model in model_dict.keys():\n    model_cv_score[model] = np.mean(cross_val_score(model_dict[model], X=preprocessed_train, y=price_train))\n\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.001070 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2296\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 540497.991270\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000462 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2327\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 542956.681826\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000355 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2331\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 543149.529265\n[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.000627 seconds.\nYou can set `force_row_wise=true` to remove the overhead.\nAnd if memory is not enough, you can set `force_col_wise=true`.\n[LightGBM] [Info] Total Bins 2332\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 542032.619305\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000316 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2298\n[LightGBM] [Info] Number of data points in the train set: 12028, number of used features: 19\n[LightGBM] [Info] Start training from score 534776.444047\n\n\n\nfor model in model_dict.keys():\n    print(f'{model} : {model_cv_score[model]}')\n\nGradientBoosting : 0.8613647608814923\nXGBoost : 0.8762617283884332\nLigntGBM : 0.8818569800403846\n\n\n\n\n모델학습 및 예측\n\nScore가 가장 높았던 lightGBM으로 진행해보기\n\n\nmodel_dict['LigntGBM'].fit(preprocessed_train.values, y)\nprediction = model_dict['LigntGBM'].predict(preprocessed_test.values)\nprediction\n\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000727 seconds.\nYou can set `force_col_wise=true` to remove the overhead.\n[LightGBM] [Info] Total Bins 2338\n[LightGBM] [Info] Number of data points in the train set: 15035, number of used features: 19\n[LightGBM] [Info] Start training from score 540682.653143\n\n\narray([1296687.09405506,  311847.90404507,  806735.28228208, ...,\n       1726006.82963994,  395020.94053356,  333594.29000994])\n\n\n\n\n제출용 DataFrame 및 csv파일 생성\n\ndf_submission = pd.DataFrame({'id' : test_id, \n                              'price' : prediction})\ndf_submission\n\n\n\n\n\n\n\n\n\nid\nprice\n\n\n\n\n0\n15208\n1.296687e+06\n\n\n1\n15209\n3.118479e+05\n\n\n2\n15210\n8.067353e+05\n\n\n3\n15211\n2.098083e+05\n\n\n4\n15212\n4.343237e+05\n\n\n...\n...\n...\n\n\n6550\n21758\n4.230647e+05\n\n\n6551\n21759\n5.111171e+05\n\n\n6552\n21760\n1.726007e+06\n\n\n6553\n21761\n3.950209e+05\n\n\n6554\n21762\n3.335943e+05\n\n\n\n\n6555 rows × 2 columns\n\n\n\n\n\ndf_submission.to_csv('submission.csv', index=False)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#gridsearch",
    "href": "posts/meta-dl-creditcard-20240609/index.html#gridsearch",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "GridSearch",
    "text": "GridSearch\n\nLightGBM에 Grid Search 적용해보기\n\nfit 후 결과값 부연설명\n\n5 folds : cv = 5\n4 candidates : 2(max_depth) X 2(n_estimators)\n20 fits : 5 folds X 4 candidates\n\n\n\nfrom sklearn.model_selection import GridSearchCV\n\ngrid_param = {\n    'n_estimators': [50, 100], #트리수\n    'max_depth': [1, 10], #트리깊이\n}\n\ngrid_model = GridSearchCV(lgb.LGBMRegressor(random_state=1210), \n                          param_grid=grid_param, \n                          scoring='neg_mean_squared_error',\n                           cv=5, verbose=1, n_jobs=5)\n\n\ngrid_model.fit(preprocessed_train.values, y)\n\n\ngrid_model.cv_results_\nparams = grid_model.cv_results_['params']\n\ndf_grid_result = pd.DataFrame(params)\ndf_grid_result['score'] = grid_model.cv_results_['mean_test_score']\n\n\ndf_grid_result\n\n\n\n\n\n\n\n\n\nmax_depth\nn_estimators\nscore\n\n\n\n\n0\n1\n50\n-4.787553e+10\n\n\n1\n1\n100\n-3.851269e+10\n\n\n2\n10\n50\n-1.723322e+10\n\n\n3\n10\n100\n-1.636420e+10\n\n\n\n\n\n\n\n\n\nGridSearch 기준 Score가 가장 좋은 파라메터로 진행해보기\n\n\nmodel = lgb.LGBMRegressor(max_depth=10, n_estimators=100, random_state=1210)\nmodel.fit(preprocessed_train.values, y)\nprediction = model.predict(preprocessed_test.values)\nprediction\n\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.000693 seconds.\nYou can set `force_row_wise=true` to remove the overhead.\nAnd if memory is not enough, you can set `force_col_wise=true`.\n[LightGBM] [Info] Total Bins 2338\n[LightGBM] [Info] Number of data points in the train set: 15035, number of used features: 19\n[LightGBM] [Info] Start training from score 540682.653143\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n\n\narray([1291842.41370212,  314132.92290945,  817260.44452776, ...,\n       1713971.79620206,  389405.58625426,  332109.32763046])"
  },
  {
    "objectID": "posts/coach-ml-kaggle-20230506/index.html#gridsearch",
    "href": "posts/coach-ml-kaggle-20230506/index.html#gridsearch",
    "title": "[Scikit-learn] Kaggle 집값예측 실습",
    "section": "GridSearch",
    "text": "GridSearch\n\nLightGBM에 Grid Search 적용해보기\n\nfit 후 결과값 부연설명\n\n5 folds : cv = 5\n4 candidates : 2(max_depth) X 2(n_estimators)\n20 fits : 5 folds X 4 candidates\n\n\n\nfrom sklearn.model_selection import GridSearchCV\n\ngrid_param = {\n    'n_estimators': [50, 100], #트리수\n    'max_depth': [1, 10], #트리깊이\n}\n\ngrid_model = GridSearchCV(lgb.LGBMRegressor(random_state=1210), \n                          param_grid=grid_param, \n                          scoring='neg_mean_squared_error',\n                           cv=5, verbose=1, n_jobs=5)\n\n\ngrid_model.fit(preprocessed_train.values, y)\n\n\ngrid_model.cv_results_\nparams = grid_model.cv_results_['params']\n\ndf_grid_result = pd.DataFrame(params)\ndf_grid_result['score'] = grid_model.cv_results_['mean_test_score']\n\n\ndf_grid_result\n\n\n\n\n\n\n\n\n\nmax_depth\nn_estimators\nscore\n\n\n\n\n0\n1\n50\n-4.787553e+10\n\n\n1\n1\n100\n-3.851269e+10\n\n\n2\n10\n50\n-1.723322e+10\n\n\n3\n10\n100\n-1.636420e+10\n\n\n\n\n\n\n\n\n\nGridSearch 기준 Score가 가장 좋은 파라메터로 진행해보기\n\n\nmodel = lgb.LGBMRegressor(max_depth=10, n_estimators=100, random_state=1210)\nmodel.fit(preprocessed_train.values, y)\nprediction = model.predict(preprocessed_test.values)\nprediction\n\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.000693 seconds.\nYou can set `force_row_wise=true` to remove the overhead.\nAnd if memory is not enough, you can set `force_col_wise=true`.\n[LightGBM] [Info] Total Bins 2338\n[LightGBM] [Info] Number of data points in the train set: 15035, number of used features: 19\n[LightGBM] [Info] Start training from score 540682.653143\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] Accuracy may be bad since you didn't explicitly set num_leaves OR 2^max_depth &gt; num_leaves. (num_leaves=31).\n\n\narray([1291842.41370212,  314132.92290945,  817260.44452776, ...,\n       1713971.79620206,  389405.58625426,  332109.32763046])"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240609/index.html#주차-과제-설명",
    "href": "posts/meta-dl-creditcard-20240609/index.html#주차-과제-설명",
    "title": "[M_Study_3주차] Multi-class Classification / Artificial Neural Network",
    "section": "2주차 과제 설명",
    "text": "2주차 과제 설명\n\ntf.random.set_seed(2024)\n\n서로 다른 모델을 비교하는 경우, 시작점이 다른 것 때문에 성능우위가 다르게 측정되는 경우 발생 (같은 성능임에도 다르게 나오거나, 좋은 모델이 더 나쁜 모델로 오인되는 경우)\n이러한 경우를 방지하고자, set_seed로 같은 지점에서 시작하게 할 수 있음\n딥러닝은 복잡한 다차원의 함수이므로, 좋은 시작점에 따라 달라질 수 있음 (좋은 Optimizer를 사용하고 좋은 데이터를 쓴다면 차이는 줄어들 수 있음)\n\nMatrix Multiplication\n\nA(1,2), B(2,1)와 같은 Matrix에서, A의 열(,2)과 B의 행(2,)의 숫자가 같아야 가능\n\nCost function에서 마이너스(-)를 붙이는 경우\n\n높을수록 안좋은 척도여야 할 때, 계산식이 높을수록 좋은 값인 경우 붙여서 변환\n\nLearning rate\n\nGD에서 안정적으로 최적점에 가게하기 위해 학습률을 조정\n사람이 지정하는 hyper parameter, 경험에 의해 넣는 경우가 많다(정답은 없음)\n\nConfusion Matrix\n\nRecall, Precision 으로 표현하는 것은 경영진 등에는 와닿지 않을 수 있으므로 시각화하여 보여주면 좋음"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html",
    "href": "posts/meta-dl-creditcard-20240602/index.html",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "",
    "text": "참여중인 딥러닝 스터디 2주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240602/index.html#개요",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "",
    "text": "참여중인 딥러닝 스터디 2주차 기록입니다."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#주차-과제-설명",
    "href": "posts/meta-dl-creditcard-20240602/index.html#주차-과제-설명",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "1주차 과제 설명",
    "text": "1주차 과제 설명\n\n큰 틀에서는 보통 아래의 순서로 진행\n\n데이터생성\nhypothesis\ncost function\noptimizer\ntrain\nPrediction (=Inference)\n\ntf.reduce_mean() : 열(row)끼리의 평균\nNon-Linear Modeling  &gt;\\(y = ax^2 + bx + c\\)\n\n구하고자 하는 값은 \\(a, b, c\\)\n모델 학습 전 임의의 값(\\(a,b,c\\))으로 추세선 긋기  \n내가 가정하는 식을 hypothesis에 넣고 학습\ndef hypothesis(x):\n  return a*(x)**2 + b*x + c\n\ndef cost_fn(pred_y, true_y):\n  return tf.reduce_mean(tf.square(pred_y - true_y))\n\noptimizer = tf.optimizers.Adam(learning_rate = 0.01)\n\ndef train():\n  with tf.GradientTape() as g:\n    pred = hypothesis(X)\n    cost = cost_fn(pred, Y)\n\n  gradients = g.gradient(cost, [a,b,c])                    # 기울기를 계산하는 부분\n  optimizer.apply_gradients(zip(gradients, [a,b,c]))       # 계산된 기울기를 업데이트 해주는 부분\n\nfor step in range(1,1001):\n  train()\n\n  if step % 100 == 0:\n    pred = hypothesis(X)\n    cost = cost_fn(pred, Y)\n    print(f\" step:{step} cost:{cost:.4f} a:{a.numpy()} b:{b.numpy()} c:{c.numpy()} \")\n    line_x = np.arange(min(X), max(X), 0.001)\n    line_y = a*(line_x)**2 + b*(line_x) + c\n모델 학습 후 변경된 추세선 확인하기"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#linear-regression",
    "href": "posts/meta-dl-creditcard-20240602/index.html#linear-regression",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "Linear Regression",
    "text": "Linear Regression\n\nLinear Regression의 Motivation\n\n수 많은 데이터를 묘사하는 하나의 선을 긋고, 그 선으로 향후 추이(예를 들어 광고비와 매출의 관계 등)를 판단\n랜덤하게 하나의 선을 긋고(임의의 W, b설정), 실제 데이터(점)과 선(예측값)의 거리[오차]를 줄인다\n\n선형성이 있다는 가정 하에 모델링 수행 &gt; \\(Y = B_0 + B_1X + \\epsilon\\)\n\n기존 수업의 \\(Y = WX+b\\) 식에서 \\(B_0\\)이 \\(b\\), \\(B_1X\\)이 \\(W\\)\n\n\\(B_0\\) : intercept (첫번째 기울기는 \\(B_1X\\)으로 표현)\n\\(B_1X\\) : slope, coefficients\n\\(B_0\\), \\(B_1X\\) 등을 합쳐서 parameter라고 부름 (가장 적절한 parameter를 찾는 것이 AI의 목적)\n\n\nhat (\\(\\hat{B}\\))은 최적화가 되었을 때 씌운다\n\n처음에 임의값을 두었다가 학습을 하며 최적화가 되면 씌움\n\nresidual(잔차)\n\n예측값 \\(\\hat{y}\\)(\\(\\hat{B}_0+\\hat{B}_1x_i\\))에 대해 정의된 오차 \\(e_i\\) (\\(y_i-\\hat{y_i}\\))\n\ni번째 잔차(\\(i\\)th residual)\n\n\nRSS(Residual Sum of Squares) : 잔차를 제곱해서 더한 것 &gt; \\(e_1^2 + e_2^2+...+e_n^2\\)\n\n제곱이 아닌 절대값으로 해도 개념적으로는 오차를 계산 가능\n최소자승법(least square)으로 최적의 \\(B\\)를 구하며 RSS가 줄어듦\n\n최소자승법 : 그래프에서 오차가 가장 낮은, 미분값이 0인 지점 찾기(오차가 0이 되는 지점을 미분으로 찾는 것이며, 이때의 오차는 Train set의 오차임)\n절대값으로 오차를 찾는 경우 미분을 활용할 수 없어, RSS를 사용\n현대에는 최소자승법을 잘 안쓰고 GD를 사용 (GD : 하나의 랜덤한 점을 찍고, 최소점을 향해 근사를 반복해나감[epoch반복])\n\n\n\\(B_0\\), \\(B_1X\\) 등 parameter를 구했을 때, 얼마나 신뢰할 수 있는 숫자인가\n\nStandard error(Variance에 루트를 씌우면 Standard error로, 본질적으로 같음)\n\nVariance는 모델의 안정성\nStandard error, \\(SE(\\hat{B}_1)^2\\) 계산을 통해 얼마나 안정적인지 판단\nSE의 계산식은 데이터(샘플)가 많아질수록 분모(Sum)가 커지므로, 모델의 Variance가 낮아짐\n\n→ 데이터가 많아지면 모델이 좋아진다 (최적의 \\(B\\)를 최소자승법으로 구해 모델을 만들고, 데이터 샘플의 수가 커지면 계산된 최적의 \\(B\\)가 가지는 SE가 줄어들음)\n\n\nConfidence intervals(신뢰구간)\n\n대학원 면접에서 많이 나오는 주제\nVariance(또는 SE)를 기반으로 신뢰구간을 구함 &gt; \\(\\hat{B}_1 +- 2*SE(\\hat{B}_1)\\)\n신뢰구간 95% / 평균 100 / 신뢰구간 80~120의 해석\n\n모집단에서 샘플링을 했을 때 평균이 100\n모집단 평균이 105, 110일수도 있지만 추정한 신뢰구간안에 실제 평균이 존재할 확률이 95%라는 뜻\n\nVariance가 낮아지면 신뢰구간이 좁아지며 좋아짐\n\n\nt-statistic\n\n$ t = _1-0 SE(_1) $\nSE가 낮을수록 좋은 값이라는 점에서, 위 수식(t값)이 클수록 좋다는 직관적 이해 가능\np-value : t값보다 클 확률 (즉 낮을수록 좋다)\n\n결과 표 보며 이해하기  \n\ncoefficient : 구한 parameter값\nStandard error, t-statistic은 단위에 따라 달라질 수 있는 값\np-value는 통일된 값으로, 0.0001보다 작으므로 Variance가 낮고 모델이 안정적이다 (p-value가 낮을수록 결과가 유의하다 라고 표현)\n\n\\(R^2\\)\n\n$ R^2$ = $ TSS - RSS TSS $ = $1 - RSS TSS $\nRSS(오차의 제곱을 모두 더한 잔차)가 클수록 작아지므로, 클수록 좋은 지표임을 이해\nTSS는 RSS보다 무조건 크므로, \\(R^2\\)는 0~1의 값을 갖는다\n\\(R^2\\)가 0.7이면 70%의 설명력을 가진다\n\n주의할 점\n\n상관관계에 대해 분석한 것으로, 인과관계가 아니다 (인과관계라면 상관관계는 있을 수 있다)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#multiple-regression",
    "href": "posts/meta-dl-creditcard-20240602/index.html#multiple-regression",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "Multiple Regression",
    "text": "Multiple Regression\n\n변수와 계수를 추가하면 Multiple Regression이 됨\n\n수식이 길어지고, * 편미분이 여러개가 나오게 되는 차이\n변수가 2개가 되어 기존의 2차원평면/regression line이 아닌 3차원평면/regression plain이 나옴\nmultiple matrix를 활용해 표현 (row, column)\nRSS도 행렬식으로 표현\n\n역행렬은 엄청난 연산이 필요한데, 이는 least square를 사용하지 않게된 이유임 (정형데이터 위주였던 과거와 달리 이미지 등 데이터와 이에 대한 행렬이 매우 커져, computing성능발전에도 역행렬 계산 어려워짐)\nleast square는 Bias를 최소화하는 방법인데, trade-off로 Variance커질 위험이 커서 사용하지 않게 됨\n\n현대는 모델의 Variance가 중요해짐. Overfitting과 관계된 Variance를 줄이기 위해 약간의 Bias상승은 감내\nLeast square(최소자승법)는 오차가 0이되는 지점을 미분으로 찾는 방법이며, 이때의 오차는 Train Dataset으로 오차가 너무 작아지면 Overfitting\n\n\n\nCorrelation 상관관계\n\nVariable간의 상관관계를 보는 이유 : 중복되는 변수의 과대평가, 타 변수의 과소평가를 방지 (예를 들어 연봉과 자산의 경우 상관관계가 있음)\n\nGD(Gradient Descent, 경사하강법)\n\n역행렬의 계산량문제로 최소자승법(least square)가 아닌 GD방식을 사용\n\\(a\\) (learning rate)로 적절히 작은 숫자를 곱해, 한번에 너무 많이 이동(하강)하지 않게 함\n\n보통 0.01사용\n\n$W = W - a * $ $ c W$\n코드로 이해하기 \n\nCost를 가중치W로 미분 (gradient 함수로 $ c W$구하기)\n\n  # gradient 계산\n  gradients = g.gradient(cost, [W,b])     \n\n가중치W 업데이트 (apply_gradients 함수로 \\(W\\) 업데이트)\n\n  # gradients에 따라 W와 b 업데이트\n  optimizer.apply_gradients(zip(gradients, [W,b])) \n\nSingle Regression에서는 없던 Multiple Regression의 고민\n\n변수의 갯수 (많이 쓴다고 좋은게 아니며, 최적의 갯수 찾기)\n\nforward(↔︎backward) selection\n\n변수의 갯수를 늘려가다가(↔︎줄여가다가), 성능이 낮아질때 직전 갯수로 사용\n\n변수의 갯수가 달라졌을 때 성능의 지표\n\nAIC(Akaike Information Criterion)\nBIC(Bayesian Information Criterion)\nAdjusted \\(R^2\\)\nCV(Cross-validation)\n\n\n요즘은 Linear Regression에서 발전된 알고리즘이 많이 나와서, 위의 것보다 먼저 알아야 하는게 많음\n\nQualitative Predictor(Categorical, 범주형 변수)\n\n숫자가 아닌 상태로 쓰이는 경우 (0남자 1여자 등, 여러개도 Okay) 활용하여 Regression에 반영할 수 있게 됨\n\n예를 들어, 구하고자하는 y가 키(신장)이라면, 성별변수 남자가 0이면 가중치는 음수, 반대면 양수가 될 수 있음\n\n\nInteraction impact(Synergy impact)\n\n변수가 구하고자하는 y가 아니라 다른 변수에도 영향을 미치는 경우\n\n서로 관계있는 두 변수를 곱하여 추가해줌(\\(X^1, X^2\\)가 관계있는 경우 \\(X^1*X^2\\)라는 변수로)\n결과 표로 이해하기  \n\nradio의 p-value가 유의하지 않아 변수제거를 했을 때, 파생변수인 radio*TV는 어떻게 할까?\n\n제거한다 (오리지널 변수를 제거한다면 파생변수도 제거, 오리지널이 있을때만 사용가능)\nHierarchy principle : 파생변수가 존재하려면 오리지널 변수도 있어야 함\n\nCoefficient 값 기준으로 radio가 TV보다 더 중요한 변수인가?\n\nCoefficient는 단위(unit)를 간과하므로, 높다고 해서 반드시 중요한 것은 아니다\n\n\n\n변수(feature)의 관계는 독립적인게 좋음\n\nNon-linearity의 Multiple regrssion 활용한 표현\n\n예를 들어 전반부는 정비례 / 후반부는 반비례 한다면\n\n\\(B_1 *나이 + B_2 * 나이^2\\) 와 같이 표현 가능\n위의 표현식은 변수의 독립성을 저해하는가?(사용해도 되나?)\n\n서로 다른관계를 묘사하는 것이라면 사용 가능\n\n연봉, 자산 모두 대출점수의 양의 상관관계라면 사용 불가\n\\(B_1 *나이\\)는 양의 상관관계, \\(B_2 * 나이^2\\)는 음의 상관관계라면 사용 가능\n\n\n\n다만 변수가 많아지면 한계가 있으므로, 비선형에 적합한 타 모델이 더 좋음\n\n상관관계를 빠르게 파악하는 법 : 모든 산점도(Scatter plot)를 그려보기\n\n미리 파악하여 상관관계가 있는 것을 빼고 모델링하면 더 좋은 결과가 나타남\n중복변수가 들어가거나 하더라도, Robust한 모델을 사용하는 것도 좋은 방법"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#logistic-regression",
    "href": "posts/meta-dl-creditcard-20240602/index.html#logistic-regression",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "Logistic regression",
    "text": "Logistic regression\n\nLinear regression으로 현재까지 예측문제를 풀었다면, Logistic regression으로는 분류문제를 풀 수 있다\n머신러닝으로 푸는 큰 3가지 문제 : 예측 vs 분류 vs 클러스터링\n\n분류 : 메일이 왔을 때 스팸인가 아닌가, 신용카드승인내역이 이상거래인가 정상거래인가\n\nHyphothesis의 반영\n\n기존의 Linear regression(\\(y=Wx+b\\))의 식으로는 놓치는 case가 많이 생김\nLogistic(Sigmoid) function을 활용하여 해결 가능  \n\nz가 아무리 커지거나 작아져도 0~1사이에서 벗어나지 않음\n0.5를 기준으로 판단가능 (Pass/Fail, 스팸/정상 등)\nz부분에 기존에 데이터를 학습했던 Linear regression식(\\(y=Wx+b\\))을 넣으면(plug-in), 분류문제를 푸는 함수로 바꿈\n값이 0.7이 나온다면, Pass확률이 70%인 것으로 해석가능\n\n\nDescision boundary 경계영역\n\n예를 들어 2가지 Case를 분류하는 Linear Line이 있다면, 그것이 Descision boundary (Non Linear한 경우라도 분류문제를 풀 수 있고, 그 Line은 Descision boundary)\n\nCost function에서는 문제가 생김\n\nSigmoid function으로 간편하게 분류문제를 푸는 함수로 바꿨지만, 기존처럼 미분을 하면 문제 발생\n\n값이 조금만 크거나 작아져도 기울기가 0이 됨 → 기존의 Mean Square방식 적용 불가  \nGD 사용시 최적 지점까지 가지 못하는 경우 발생\n\nCross entropy를 사용하게 됨\n  [Cost function으로 사용되기 위한 2가지 조건]\n  1. 클수록 나쁘고 작을수록 좋아야 함\n  2. 미분이 가능해야 함\n    (미분이 안되는 경우 : 평평한 부분이 있거나, 위아래로 변동이 큰 구간이 많은 경우)\n\n  * 두 조건을 충족하는 것은 쉽지 않으며, Accuracy는 1번만 충족\n  * Cross entropy는 위의 2개 조건을 모두 충족\n\n2가지 상황(y=0[pass], y=1[fail])에 대한 상황에 대해 다른 식 사용\n\n필요시 하나의 식으로도 나타낼 수 있음 (y값에 따라 한쪽 식이 0이 되는 형태)\n\n현대에서도 많이 쓰이는 함수인 Cross entropy (gpt4 등)\nGD경사하강법으로도 사용 가능"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240602/index.html#모형예측classification의-성과평가confusion-matrix",
    "href": "posts/meta-dl-creditcard-20240602/index.html#모형예측classification의-성과평가confusion-matrix",
    "title": "[M_Study_2주차] Multiple Regression / Logistic Regression",
    "section": "모형예측(Classification)의 성과평가(Confusion matrix)",
    "text": "모형예측(Classification)의 성과평가(Confusion matrix)\n\nAccuracy(정답률) : 실제값 중 맞춘 비율\n\n분류가 Imbalance한 경우 한계가 있음(신용카드 경우도 대다수가 정상거래) (예를 들어 암환자 비율이 90%이상일 때, 로직없이 그냥 암환자로만 판정해도 정답률 높음)\n\nPrecision(암으로 판정한 사람 중, 실제로 암) vs Recall(실제 암인 사람 중, 암으로 판정된 사람)\n\n암환자를 정상환자로 판단하는 것은 치명적\n암과 같은 케이스는 기본적으로 암으로 ’판단’하는 것이 많아져야하므로 Recall을 사용 (분자가 ’암 판정’인, 분자가 커질수록 점수가 높은 recall을 사용하는게 적절)\n프로젝트 특성에 따라 적합한 모델 뿐 아니라 적합한 지표를 사용하는 것이 중요\n\nPrecision이 더 중요한 케이스\n\n불량제품 하나를 검수하기 위해 1만개의 정상제품을 검사하면 비효율적\n1개의 불량제품을 감수하고 1만개를 살리는게 효율적\n\n분류가 balance한지 imbalance한지를 체크\nF1 score : Precision과 Recall의 조화평균\nConfusion matrix를 그래프로 visualize 해서 보여주면 더 설득에 용이"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html",
    "href": "posts/meta-dl-creditcard-20240526/index.html",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "",
    "text": "참여중인 딥러닝 스터디 1주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240526/index.html#개요",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "",
    "text": "참여중인 딥러닝 스터디 1주차 기록입니다."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#tensorflow-pytorch",
    "href": "posts/meta-dl-creditcard-20240526/index.html#tensorflow-pytorch",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "Tensorflow, Pytorch",
    "text": "Tensorflow, Pytorch\n\n프레임워크 2가지 존재 : Tensorflow(텐서플로우, 구글), Pytorch(파이토치, 페이스북)\n\n알파고(딥마인드)시점까지는 ai의 90퍼센트 이상은 텐서플로우로 구현되었으나, 후발주자로 페이스북이 파이토치를 만들고 경쟁구도가 되었음\n\n파이토치 vs 텐서플로우\n\n파이토치 : high레벨에 가까운 pythonic함 (사람의 직관에 가까운, 추상화된) 대학원 등 교육 쪽에서 많이 사용(구현해보는 것에 중점) 사용자 증가로 긍정적 생태계 조성(텐서플로우에는 없는 함수가 개발될 수 있고, 디버깅 쉬워짐[참고Case많음], 참고강의 많음)\n텐서플로우 : low레벨에 가까운 효율성 (기계가 이해하기 쉬운 C언어와 같은) 산업 등 비즈니스 영역에서 많이 사용(효율성 중시)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#tensor",
    "href": "posts/meta-dl-creditcard-20240526/index.html#tensor",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "Tensor",
    "text": "Tensor\n\nTensor : ai에서 사용하는 배열 (차원=rank), 고차원의 데이터 저장(숫자뿐 아니라 문자도 가능)\n\n0차원 scalar / 1차원 vector / 2차원 matric (2d tensor) /3차원 3 tensor (3d tendor) / N차원 N tensor\n참고영상 : https://youtu.be/m0qwxNA7IzI?si=FeyWcPYuun7T_QON\n\n\n\n\n\nimage.png\n\n\n\n고차원/비정형 데이터 필요성 예시\n\n이미지 데이터(흑백)는 3d tensor 필요\n이미지 데이터(컬러)는 4d tensor 필요\n영상 데이터는 5d tensor 필요\n(결론→) 비정형데이터의 처리에 있어 tensor가 필요\n\n기존에는 매출, 성장률 등 숫자(정형 데이터)만 썼다면, 이제는 이미지(비정형 데이터) 등도 데이터 분석에 사용하기 시작함"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#tensorflow-실습-constant-rank",
    "href": "posts/meta-dl-creditcard-20240526/index.html#tensorflow-실습-constant-rank",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "Tensorflow 실습 (constant, rank)",
    "text": "Tensorflow 실습 (constant, rank)\n\n텐서플로우 2.0의 차이 &gt; 즉시 실행모드(Eager Mode)지원 (1.x버전에서는 그래프를 생성하고 초기화하는 등 별도 작업이 필요했었음) \nRank(축) : 차원의 수\nShape(형상) : 0, 1, 2차원 등 데이터의 차원\ndtype : string, float32, float16, int32, int8 등 데이터 타입\n\n\nimport numpy as np\nimport tensorflow as tf\n\nprint(tf.__version__)\n\n2.16.1\n\n\n\na = tf.constant(2)\nb  = tf.constant([2,3])\nc = tf.constant([[2,3],[6,7]])\nd = tf.constant(['hello'])\n\nprint('[tf.rank 차원의 수 출력]')\nprint(tf.rank(a))\nprint(tf.rank(b))\nprint(tf.rank(c))\nprint(tf.rank(d))\nprint()\n\nprint('[변수 자체 출력]')\nprint(a)\nprint(b)\nprint(c)\nprint(d)\n\n[tf.rank 차원의 수 출력]\ntf.Tensor(0, shape=(), dtype=int32)\ntf.Tensor(1, shape=(), dtype=int32)\ntf.Tensor(2, shape=(), dtype=int32)\ntf.Tensor(1, shape=(), dtype=int32)\n\n[변수 자체 출력]\ntf.Tensor(2, shape=(), dtype=int32)\ntf.Tensor([2 3], shape=(2,), dtype=int32)\ntf.Tensor(\n[[2 3]\n [6 7]], shape=(2, 2), dtype=int32)\ntf.Tensor([b'hello'], shape=(1,), dtype=string)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#계산-add-subtract-multiply",
    "href": "posts/meta-dl-creditcard-20240526/index.html#계산-add-subtract-multiply",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "계산 (add, subtract, multiply)",
    "text": "계산 (add, subtract, multiply)\n\nadd, subtract, multiply (+, -, * 기호로도 가능)\n\n\na = tf.constant(3)\nb = tf.constant(2)\n\n\nprint(tf.add(a,b))\nprint(a+b)\n\ntf.Tensor(5, shape=(), dtype=int32)\ntf.Tensor(5, shape=(), dtype=int32)\n\n\n\nprint(tf.subtract(a,b))\nprint(a-b)\n\ntf.Tensor(1, shape=(), dtype=int32)\ntf.Tensor(1, shape=(), dtype=int32)\n\n\n\nprint(tf.multiply(a,b))\nprint(a*b)\n\ntf.Tensor(6, shape=(), dtype=int32)\ntf.Tensor(6, shape=(), dtype=int32)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#numpy와-tensor의-변환",
    "href": "posts/meta-dl-creditcard-20240526/index.html#numpy와-tensor의-변환",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "numpy와 tensor의 변환",
    "text": "numpy와 tensor의 변환\n\n둘 다 데이터를 담는 container\n학습이 잘되고 있는지, 중간결과 등을 확인할때 numpy형태로 cpu로 확인\n실제 계산은 tensor 형태로 gpu에서 수행\n\n\n# numpy()\nc = (a+b)\n\nprint(c)\nprint(type(c))\n\nprint()\nprint(c.numpy())\nprint(type(c.numpy()))\n\ntf.Tensor(5, shape=(), dtype=int32)\n&lt;class 'tensorflow.python.framework.ops.EagerTensor'&gt;\n\n5\n&lt;class 'numpy.int32'&gt;\n\n\n\n# tf.convet_to_tensor()\nc_sqrt = np.sqrt(c,dtype=np.float32)\nc_tensor = tf.convert_to_tensor(c_sqrt)\n\nprint(c_sqrt)\nprint(type(c_sqrt))\n\nprint()\nprint(tf.convert_to_tensor(c_sqrt))\nprint(type(tf.convert_to_tensor(c_sqrt)))\n\n2.236068\n&lt;class 'numpy.float32'&gt;\n\ntf.Tensor(2.236068, shape=(), dtype=float32)\n&lt;class 'tensorflow.python.framework.ops.EagerTensor'&gt;"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#linear-regression",
    "href": "posts/meta-dl-creditcard-20240526/index.html#linear-regression",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "Linear regression",
    "text": "Linear regression\n\n추세선 등을 그어서 쉽게 판단 가능 + X(투입)에 대한 Y(산출)을 판단해 데이터에 기반한 정량적 판단(객관적 증거)\n선형적관계 &gt; \\(Y = f(X) + \\epsilon\\) 을 기본적인 ML/DL의 식이라고 할 때,  \\(f\\)의 관계가 선형적 관계가 있다고 가정할 때 Linear regression  \\(income = f(education, seniority) + \\epsilon\\) 와 같은 예시를 들 수 있음\nSingle/Multi regression이 있다\n\n\n[용어정리]\nresponse, target : Y값 feature, input, predictor : X값 \\(\\epsilon\\)(엡실론) : 오차 \\(\\hat{x}\\) : 예측값 \\(x\\) (위의 기호는 hat)\n\n\n비선형적 관계를 다루는 모델을 사용하여 오차를 줄일 수 있음 단 오차를 0으로 만드는게 무조건 좋은 것은 아님 → 다뤄보지 못한 데이터가 나오면 성능이 떨어짐(과적합 overfitting)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#interpretability-vs-flexibility",
    "href": "posts/meta-dl-creditcard-20240526/index.html#interpretability-vs-flexibility",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "interpretability vs flexibility",
    "text": "interpretability vs flexibility\n &gt;[용어정리]\nflexibility : 성능, performance (100문제중 80문제를 찾추는가) interpretability : 해석 Least Squares : Linear regression\n\nDeep learning : 높은 성능 / 낮은 해석능력  효과적이고 빠름, 비선형적이면 좋은 모델을 뽑을 수 없음(선형이라는 가정 자체가 틀린 시작)\nLeast Squares : 성능은 DL보다 낮지만 높은 해석능력 (전통적 통계학의 기반을 둔 머신러닝, Statistical ML) 많은 시간과 데이터 필요, 비선형적 관계를 잘 모델링\n성능이 좋으니 DL만 사용? &gt; 관련 사례 DL로 판단하여 대출거절한 것은 차별에 해당한다는 판례 대출거절에 대해 근거를 제시해야하지만(자산부족 등), DL은 해석능력(interpretability)이 낮아 설명할 근거가 부족함 Least Squares(ㅣinear regression)로 근거를 제시했다면 차별이 되지 않았을 것"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#assessing-model-accuracy",
    "href": "posts/meta-dl-creditcard-20240526/index.html#assessing-model-accuracy",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "assessing model accuracy",
    "text": "assessing model accuracy\n\nerror의 정의 : 예측값과 실제값의 차이\n\n평균에 제곱한 에러 총합 MSE(Mean Squared Error), 줄일수록 좋음\n\n제곱을 활용하는 이유 : 나중에 미분(에러가 최소화되는 지점찾기)를 하는데, 이를 위해서 함 (다음 강의에서 설명예정)\n\\(MSE_{TR}\\)(Training set), \\(MSE_{TE}\\)(Test set)\n\n데이터 특성(복잡/단순)과 모델 적용(복잡/단순)에 따른 Training, Test MSE추이 \n\n검정(정답), 노랑(Linear), 초록(Smoothing splines)/ 빨강(\\(MSE_{TR}\\)), 회색(\\(MSE_{TE}\\))\n단순한 데이터에 복잡한 모델(초록)을 사용하니 과적합 발생 \n데이터가 복잡하지 않아 Linear를 사용하니 Error추이(우측그래프)도 좋음"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240526/index.html#bias-vs-variance-의-trade-off",
    "href": "posts/meta-dl-creditcard-20240526/index.html#bias-vs-variance-의-trade-off",
    "title": "[M_Study_1주차] Tensorflow / Linear Regression",
    "section": "Bias vs Variance 의 Trade off",
    "text": "Bias vs Variance 의 Trade off\n\nerror는 Variance와 Bias로 이루어져 있다 &gt; Variance(V), Bias(B) 예시 (과녁) V 낮음 B 낮음 : 정중앙에 잘 모여있음 V 낮음 B 높음 : 잘 모여있지만 위치가 잘못됨 V 높음 B 낮음 : 정답 근처이지만 불안정하게 퍼져있음 V 높음 V 높음 : 정답 근처도 아니고, 불안정하게 퍼져있음\nBias낮음 : Training에서 적중률이 높다, Overfitting 정답 자체를 틀리는 것과 관계\nVariance높음 : 모델이 불안정하다 변동에 과민하게 반응하는 것과 관계 (결과의 극단적 변화, 무의미한 결과는 무의미한 것으로 간주해야 안정적인 모델)\n둘 다 낮추기는 힘듦 (B낮추려면 V높아짐, B낮추려면 V 높아짐)\n둘 다 낮추기 위한 단 하나의 방법 : 데이터를 추가한다\nBias와 Variance를 고려한 가장 error가 적은 부분 Sweet spot"
  },
  {
    "objectID": "posts/coach-ds-20230506/index.html",
    "href": "posts/coach-ds-20230506/index.html",
    "title": "[간단분석] 공공데이터포털 건강검진정보 활용",
    "section": "",
    "text": "국민건강보험공단 건강검진정보를 활용한 간단한 분석 공공데이터포털 국민건강보험공단_건강검진정보\n실습 기록용으로 남깁니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/coach-ds-20230506/index.html#개요",
    "href": "posts/coach-ds-20230506/index.html#개요",
    "title": "[간단분석] 공공데이터포털 건강검진정보 활용",
    "section": "",
    "text": "국민건강보험공단 건강검진정보를 활용한 간단한 분석 공공데이터포털 국민건강보험공단_건강검진정보\n실습 기록용으로 남깁니다."
  },
  {
    "objectID": "posts/coach-ds-20230506/index.html#데이터-불러오기",
    "href": "posts/coach-ds-20230506/index.html#데이터-불러오기",
    "title": "[간단분석] 공공데이터포털 건강검진정보 활용",
    "section": "데이터 불러오기",
    "text": "데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport koreanize_matplotlib\nimport matplotlib.pyplot as plt\n\n\ndf = pd.read_csv('국민건강보험공단_건강검진정보_20221231.CSV', encoding=\"cp949\")\n\n\ndf.columns\n\nIndex(['기준년도', '가입자일련번호', '시도코드', '성별', '연령대코드(5세단위)', '신장(5cm단위)',\n       '체중(5kg단위)', '허리둘레', '시력(좌)', '시력(우)', '청력(좌)', '청력(우)', '수축기혈압',\n       '이완기혈압', '식전혈당(공복혈당)', '총콜레스테롤', '트리글리세라이드', 'HDL콜레스테롤', 'LDL콜레스테롤',\n       '혈색소', '요단백', '혈청크레아티닌', '혈청지오티(AST)', '혈청지피티(ALT)', '감마지티피', '흡연상태',\n       '음주여부', '구강검진수검여부', '치아우식증유무', '치석'],\n      dtype='object')\n\n\n\n음주여부, 흡연상태, 연령대코드, 성별코드간의 상관관계\n\n상관계수 구하기\n\n\nfiltered = df[['음주여부','흡연상태','연령대코드(5세단위)','성별']].copy()\nfiltered.corr()\n\n\n\n\n\n\n\n\n\n음주여부\n흡연상태\n연령대코드(5세단위)\n성별\n\n\n\n\n음주여부\n1.000000\n0.252058\n-0.357367\n-0.254963\n\n\n흡연상태\n0.252058\n1.000000\n-0.073601\n-0.536833\n\n\n연령대코드(5세단위)\n-0.357367\n-0.073601\n1.000000\n0.042162\n\n\n성별\n-0.254963\n-0.536833\n0.042162\n1.000000\n\n\n\n\n\n\n\n\n\n상관계수 시각화 (Seaborn heatmap)\n\n\n#mask옵션 사용하고, annot옵션으로 수치표기, fmt옵션으로 소수자리 지정하여 heatmap으로 표현\nmask = np.triu(np.ones_like(filtered.corr(), dtype=bool))\nsns.heatmap(filtered.corr(), annot=True, fmt='.2f', mask=mask)\n\n\n\n\n\n\n\n\n\n상관관계가 강한 순으로 나열\n\n성별과 흡연, 음주와 연령의 뚜렷한 상관관계\n흡연과 음주의 약한 상관관계 &gt; [참고] -1.0과 -0.7 사이이면, 강한 음적 선형관계 -0.7과 -0.3 사이이면, 뚜렷한 음적 선형관계 -0.3과 -0.1 사이이면, 약한 음적 선형관계 -0.1과 +0.1 사이이면, 거의 무시될 수 있는 선형관계 +0.1과 +0.3 사이이면, 약한 양적 선형관계 +0.3과 +0.7 사이이면, 뚜렷한 양적 선형관계 +0.7과 +1.0 사이이면, 강한 양적 선형관계\n\n\n\n#상관계수로 표를 만들어, 강한 상관관계가 있는 순으로 조사해보았습니다 (절대값으로 내림차순)\ncon_index = []\ncon_value = []\ncon_value_abs= []\nfor i in filtered.corr().columns:\n    for j in filtered.corr().index:\n        con_index.append(i +\"/\" + j)\n        con_value.append(filtered.corr()[i][j])\n        con_value_abs.append(abs(filtered.corr()[i][j]))\npd.DataFrame({'상관계수':con_value,\n             '절대값':con_value_abs,\n             '항목':con_index}).sort_values(by=['절대값'],ascending=False)\n\n\n\n\n\n\n\n\n\n상관계수\n절대값\n항목\n\n\n\n\n0\n1.000000\n1.000000\n음주여부/음주여부\n\n\n5\n1.000000\n1.000000\n흡연상태/흡연상태\n\n\n10\n1.000000\n1.000000\n연령대코드(5세단위)/연령대코드(5세단위)\n\n\n15\n1.000000\n1.000000\n성별/성별\n\n\n7\n-0.536833\n0.536833\n흡연상태/성별\n\n\n13\n-0.536833\n0.536833\n성별/흡연상태\n\n\n2\n-0.357367\n0.357367\n음주여부/연령대코드(5세단위)\n\n\n8\n-0.357367\n0.357367\n연령대코드(5세단위)/음주여부\n\n\n3\n-0.254963\n0.254963\n음주여부/성별\n\n\n12\n-0.254963\n0.254963\n성별/음주여부\n\n\n1\n0.252058\n0.252058\n음주여부/흡연상태\n\n\n4\n0.252058\n0.252058\n흡연상태/음주여부\n\n\n6\n-0.073601\n0.073601\n흡연상태/연령대코드(5세단위)\n\n\n9\n-0.073601\n0.073601\n연령대코드(5세단위)/흡연상태\n\n\n11\n0.042162\n0.042162\n연령대코드(5세단위)/성별\n\n\n14\n0.042162\n0.042162\n성별/연령대코드(5세단위)\n\n\n\n\n\n\n\n\n\n\n흡연과 음주에 대한 추이\n\n앞서 약한 상관관계였던 흡연과 음주에 대한 인원추이\n\n\n# 코드를 실제값으로 변환\nsmoke = {1 : \"흡연안함\", 2: \"끊음\", 3: \"흡연중\"}\ndrink = {0: \"안마심\", 1: \"마심\"}\n\ndf['흡연상태'] = df['흡연상태'].replace(smoke)\ndf['음주여부'] = df['음주여부'].replace(drink)\n\n\n# '흡연상태','음주여부'만 가져와 crosstab\nfiltered_drink_smoke = df[['흡연상태','음주여부']]\ndf_crosstab = pd.crosstab(index=filtered_drink_smoke['음주여부'],columns=filtered_drink_smoke['흡연상태'])\ndf_crosstab\n\n\n\n\n\n\n\n\n흡연상태\n끊음\n흡연안함\n흡연중\n\n\n음주여부\n\n\n\n\n\n\n\n마심\n132750\n360530\n161804\n\n\n안마심\n33815\n280441\n30504\n\n\n\n\n\n\n\n\n\n# countplot 시각화\nsns.set_style('whitegrid')\nplt.rc('font',family=\"Malgun Gothic\")\nsns.countplot(data=filtered_drink_smoke, x='흡연상태', hue='음주여부', palette='Set1').set_title('흡연상태별 음주여부') # palette = 그래프테마\n\nText(0.5, 1.0, '흡연상태별 음주여부')\n\n\n\n\n\n\n\n\n\n\n흡연중이거나 했다가 끊은 경우에는 음주하는 사람의 비중이 높음\n흡연을 안하는 경우는 음주여부의 비중 차이가 크지 않음\n\n\n\n음주여부에 따른 콜레스테롤과 감마지티피의 관계\n\n감마지티피 : 알콜에 의한 간장애의 지표를 나타내는 검사항목\n각 항목을 산점도로 시각화하여 파악\n\n\ndf_temp = df[['총콜레스테롤','감마지티피','음주여부','흡연상태']]\n\n\n# lmplot 산점도\nplt.figure(figsize=(14,14))\nsns.lmplot(data=df_temp, x='총콜레스테롤', y='감마지티피', hue='음주여부', col='흡연상태',markers=['x','o'] # markers로 음주여부에 따라 o,x로\n           ,scatter_kws={'s':20}) # 뭉쳐진부분이 잘보이도록 scatter_kws로 점크기조정\n\n&lt;Figure size 1400x1400 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n\n대체로 특정 구역에 몰려있음, 체중 120kg 이상에 대해서 추가분석\n\n\nweight_over120 = df.loc[(df['체중(5kg단위)'] &gt;= 120), ['총콜레스테롤','감마지티피','음주여부','흡연상태']]\nplt.figure(figsize=(14,14))\nsns.lmplot(data=weight_over120, x='총콜레스테롤', y='감마지티피', hue='음주여부', col='흡연상태',markers=['x','o']\n           ,scatter_kws={'s':20})\n\n&lt;Figure size 1400x1400 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n\n흡연중인 경우, 흡연을 안하거나 끊은 경우보다 감마지피티의 값이 높게 분포\n음주여부에 따라 콜레스테롤의 차이는 크게 보이지 않으나, 감마지티피의 경우 모두 상승하는 경향\n\n\n\n연령대별 시력 확인\n\n# 별도로 정의해둔 연령코드 딕셔너리\nage_code = {1: '0~4세',\n 2: '5~9세',\n 3: '10~14세',\n 4: '15~19세',\n 5: '20~24세',\n 6: '25~29세',\n 7: '30~34세',\n 8: '35~39세',\n 9: '40~44세',\n 10: '45~49세',\n 11: '50~54세',\n 12: '55~59세',\n 13: '60~64세',\n 14: '65~69세',\n 15: '70~74세',\n 16: '75~79세',\n 17: '80~84세',\n 18: '85세+'}\n\n# 실명(시력 9.9) 제거\nsight_right = df.drop(df.loc[df['시력(우)']==9.9,].index)\nsight_left = df.drop(df.loc[df['시력(좌)']==9.9,].index)\n\n#숫자료 표기되는 연령대코드를 연령구간으로 표기할 index 생성 후 replace로 변경 (barplot의 index로 사용)\nage_code_right = []\nfor i in np.sort(sight_right['연령대코드(5세단위)'].unique()).tolist():\n    age_code_right.append(age_code[i])\nage_code_left = []\nfor i in np.sort(sight_left['연령대코드(5세단위)'].unique()).tolist():\n    age_code_left.append(age_code[i])\n\nsight_right['연령대코드(5세단위)'] = sight_right['연령대코드(5세단위)'].replace(age_code)\nsight_left['연령대코드(5세단위)'] = sight_left['연령대코드(5세단위)'].replace(age_code)\n\n\n#시력(좌), (우) 그래프를 식별하기 용이하도록 (좌)그래프를 회전\nfig, axs = plt.subplots(ncols=2, figsize=(12,5),\n                       gridspec_kw={'wspace':0.5},)\nfig.suptitle('연령별 시력 평균(좌, 우)').set_size(20) #제목\n\nsns.set_context('talk')\n\nsns.barplot(data = sight_left, x='시력(좌)', y='연령대코드(5세단위)', hue='성별', orient='h', errorbar=None, ax=axs[0],\n            order=age_code_left).invert_xaxis()\nsns.barplot(data = sight_right, x='시력(우)', y='연령대코드(5세단위)', hue='성별', orient='h', errorbar=None, ax=axs[1],\n            order=age_code_right)\n\nfor ax in axs:\n    ax.set_ylabel('연령대') # 코드가 아니므로 y축 이름을 연령대로 변경\n\n\n\n\n\n\n\n\n\n모든 연령대에서 특정 성별의 시력이 높음\n연령이 높아질수록 시력도 낮아지며, 좌우시력의 큰 차이는 보이지 않음"
  },
  {
    "objectID": "posts/coach-ds-20221113/index.html",
    "href": "posts/coach-ds-20221113/index.html",
    "title": "[간단분석] KOSIS 온라인쇼핑 해외직접판매액 간단분석 (타 주제 Choropleth시각화)",
    "section": "",
    "text": "KOSIS 지역별 / 상품군별 온라인쇼핑 해외직접판매액 데이터를 활용한 간단한 분석 KOSIS 상품군별 온라인쇼핑 해외직접판매액\n실습 기록용으로 남깁니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/coach-ds-20221113/index.html#개요",
    "href": "posts/coach-ds-20221113/index.html#개요",
    "title": "[간단분석] KOSIS 온라인쇼핑 해외직접판매액 간단분석 (타 주제 Choropleth시각화)",
    "section": "",
    "text": "KOSIS 지역별 / 상품군별 온라인쇼핑 해외직접판매액 데이터를 활용한 간단한 분석 KOSIS 상품군별 온라인쇼핑 해외직접판매액\n실습 기록용으로 남깁니다."
  },
  {
    "objectID": "posts/coach-ds-20221113/index.html#분석",
    "href": "posts/coach-ds-20221113/index.html#분석",
    "title": "[간단분석] KOSIS 온라인쇼핑 해외직접판매액 간단분석 (타 주제 Choropleth시각화)",
    "section": "분석",
    "text": "분석\n\n데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport koreanize_matplotlib\nimport matplotlib.pyplot as plt\n\n\ndf = pd.read_csv('online_export.csv')#, encoding=\"cp949\")\n\n\ndf.head()\n\n\n\n\n\n\n\n\n\nUnnamed: 0\n국가(대륙)별\n상품군별\n판매유형별\n시점\n데이터\n\n\n\n\n0\n0\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.1/4\n1054\n\n\n1\n1\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.2/4\n946\n\n\n2\n2\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.3/4\n791\n\n\n3\n3\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.4/4\n854\n\n\n4\n4\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2018.1/4\n2033\n\n\n\n\n\n\n\n\n\n데이터 확인 중 시점 컬럼에 p가 붙어있어서 의미를 확인해봄\n\nKOSIS주석 : e: 추정치, p: 잠정치, -: 자료없음, …: 미상자료, x: 비밀보호, ▽: 시계열 불연속\n\n\n\ndf['시점'].unique()\n\narray(['2017.1/4', '2017.2/4', '2017.3/4', '2017.4/4', '2018.1/4',\n       '2018.2/4', '2018.3/4', '2018.4/4', '2019.1/4', '2019.2/4',\n       '2019.3/4', '2019.4/4', '2020.1/4', '2020.2/4', '2020.3/4',\n       '2020.4/4', '2021.1/4', '2021.2/4', '2021.3/4', '2021.4/4',\n       '2022.1/4', '2022.2/4 p)'], dtype=object)\n\n\n\n\n시점 데이터의 분류 (연도, 분기의 구분), 단위표기\n\ndf['연도'] = df['시점'].map(lambda x : x.split('.')[0])\ndf['분기'] = df['시점'].map(lambda x : x.split('.')[1].split('/')[0])\ndf[['연도','분기']] = df[['연도','분기']].astype(int)\n\ndf = df.rename(columns={'데이터':'백만'})\ndf\n\n\n\n\n\n\n\n\n\nUnnamed: 0\n국가(대륙)별\n상품군별\n판매유형별\n시점\n백만\n연도\n분기\n\n\n\n\n0\n0\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.1/4\n1054\n2017\n1\n\n\n1\n1\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.2/4\n946\n2017\n2\n\n\n2\n2\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.3/4\n791\n2017\n3\n\n\n3\n3\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2017.4/4\n854\n2017\n4\n\n\n4\n4\n미국\n컴퓨터 및 주변기기\n면세점 이외\n2018.1/4\n2033\n2018\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2767\n2767\n기타\n기 타\n면세점 이외\n2021.2/4\n1278\n2021\n2\n\n\n2768\n2768\n기타\n기 타\n면세점 이외\n2021.3/4\n1154\n2021\n3\n\n\n2769\n2769\n기타\n기 타\n면세점 이외\n2021.4/4\n1076\n2021\n4\n\n\n2770\n2770\n기타\n기 타\n면세점 이외\n2022.1/4\n2325\n2022\n1\n\n\n2771\n2771\n기타\n기 타\n면세점 이외\n2022.2/4 p)\n725\n2022\n2\n\n\n\n\n2772 rows × 8 columns\n\n\n\n\n\n\n데이터 자체에 대한 분석 (describe)\n\ndf.describe()\n\n\n\n\n\n\n\n\n\nUnnamed: 0\n백만\n연도\n분기\n\n\n\n\ncount\n2772.000000\n2772.000000\n2772.000000\n2772.000000\n\n\nmean\n1385.500000\n1613.116522\n2019.272727\n2.409091\n\n\nstd\n800.351798\n4273.426107\n1.600909\n1.114533\n\n\nmin\n0.000000\n-10003.000000\n2017.000000\n1.000000\n\n\n25%\n692.750000\n41.750000\n2018.000000\n1.000000\n\n\n50%\n1385.500000\n291.500000\n2019.000000\n2.000000\n\n\n75%\n2078.250000\n1181.000000\n2021.000000\n3.000000\n\n\nmax\n2771.000000\n47689.000000\n2022.000000\n4.000000\n\n\n\n\n\n\n\n\n\n특이하게도 최소값에 음수(-10003)이 있음\n\n해외역직구와 같은 경향인가 추측해보았지만, 전체 국가/연도에서 단 1개값만 그렇다고 보기는 어려움\n이상치로 보여 제거하고 분석을 진행하면 어떨까 싶음\n\n\n\n\n국가별 판매액에 대한 heatmap을 통한 파악\n\nsales_country = df.pivot_table(values='백만', index='국가(대륙)별', columns='연도', aggfunc='sum')\nsns.heatmap(data=sales_country, annot=True, fmt='.0f', cmap='Blues')\n\n\n\n\n\n\n\n\n\n미국, 일본, 중국의 판매액이 두드러짐\n\n\n\n판매액 상위 3개국에 대한 판매액 추세 시각화\n\nsns.lineplot(data=df[df['국가(대륙)별'].isin(['미국','중국','일본'])], \n             x='연도',y='백만',hue='국가(대륙)별', errorbar=None, estimator='sum'\n            )\nplt.legend(bbox_to_anchor=(1.05,1), loc=2, borderaxespad=0) #bbox_to_anchor(그래프와의 관격, 위/아래 위치)\n\n\n\n\n\n\n\n\n\n2020, 2021년도 급격한 하락이 보임\n\n당시의 큰 이벤트로는 코로나가 있으며, 해당 시기의 국가봉쇄/여객기 항편취소/화물기 감편 등이 원인일 것으로 보임\n\n\n\n\n2020년 국가별 주요 상품군 분석\n\n판매액 비중이 높은 주요 국가에 대해 분석 진행\n\n\ndf_2020 = df[df['연도']==2020].groupby(['국가(대륙)별','분기'])['백만'].sum().unstack().copy()\nsns.heatmap(data=df_2020, annot=True, fmt='.0f', cmap='Blues')\n\n\n\n\n\n\n\n\n\n주요 3개국(미국, 일본, 중국)에 대한 제품군별 판매액 분석\n\n\nfilter_rule = (df['연도']==2020) & (df['국가(대륙)별'].isin(['미국','중국','일본']))\ndf_2020_top3 = df[filter_rule][['국가(대륙)별','상품군별','백만']]\n\n# 잘 팔리는 상품군을 딕셔너리에 저장\nbest_category = {}\nbest2_category = {}\nfor i, country in enumerate(df_2020_top3['국가(대륙)별'].unique()):\n    filter_country = df_2020_top3['국가(대륙)별'] == country\n    globals()[country] = df_2020_top3[filter_country].groupby(['상품군별'])['백만'].sum().copy()\n    best_category[i] = globals()[country].sort_values(ascending=False).index[0]\n    best2_category[i]= globals()[country].sort_values(ascending=False).index[1]\n\n#그래프 기본 틀\nfig, axs = plt.subplots(ncols=3, figsize=(15,8), # ncols(그래프 수), figsize(공간크기)\n                       gridspec_kw={'wspace':0.7},) #gridspec으로 그래프 사이 여백 설정\n\n#그래프 그리기 (반복문으로 그래프를 그리고, 범례설정과 국가/1위카테고리를 입력한 제목 생성)\nsub_title=[]\nfor i, country  in enumerate(df_2020_top3['국가(대륙)별'].unique()):\n    globals()[country].plot(kind='pie',startangle=145, autopct='%.1f%%', ax=axs[i], pctdistance=0.8, #rotatelabels=True,\n                           )\n    sub_title.append(\"[\"+country+\"]\")  \n    axs[i].set_title(sub_title[i]+ chr(10) +best_category[i])\n    axs[i].set_ylabel('')\n    axs[i].labels=None\n\n\n\n\n\n\n\n\n\n국가별 판매액 상위\n\n미국 : 의류 및 패션관련상품\n중국 : 음반 비디오 악기\n일본 : 의류 및 패션관련 상품\n\n4분기 판매가 두드러지는데, 특별히 비중이 많은 상품이 있는지 확인\n\n\nfilter_rule = (df['연도']==2020) & (df['국가(대륙)별'].isin(['미국','중국','일본'])) & (df['분기']==4)\ndf_2020_top3_quarter4 = df[filter_rule][['국가(대륙)별','상품군별','백만']]\n\n# 잘 팔리는 상품군을 딕셔너리에 저장\nbest_category = {}\nbest2_category = {}\nfor i, country in enumerate(df_2020_top3_quarter4['국가(대륙)별'].unique()):\n    filter_country = df_2020_top3_quarter4['국가(대륙)별'] == country\n    globals()[country] = df_2020_top3_quarter4[filter_country].groupby(['상품군별'])['백만'].sum().copy()\n    best_category[i] = globals()[country].sort_values(ascending=False).index[0]\n    best2_category[i]= globals()[country].sort_values(ascending=False).index[1]\n\n#그래프 기본 틀\nfig, axs = plt.subplots(ncols=3, figsize=(15,8), # ncols(그래프 수), figsize(공간크기)\n                       gridspec_kw={'wspace':0.7},) #gridspec으로 그래프 사이 여백 설정\n\n#그래프 그리기 (반복문으로 그래프를 그리고, 범례설정과 국가/1위카테고리를 입력한 제목 생성)\nsub_title=[]\nfor i, country  in enumerate(df_2020_top3_quarter4['국가(대륙)별'].unique()):\n    globals()[country].plot(kind='pie',startangle=145, autopct='%.1f%%', ax=axs[i], pctdistance=0.8, #rotatelabels=True,\n                           )\n    sub_title.append(\"[\"+country+\"]\")  \n    axs[i].set_title(sub_title[i]+ chr(10) +best_category[i])\n    axs[i].set_ylabel('')\n    axs[i].labels=None\n\n\n\n\n\n\n\n\n\n4분기 국가별 판매액 상위 (변동없음)\n\n미국 : 의류 및 패션관련상품\n중국 : 음반 비디오 악기\n일본 : 의류 및 패션관련 상품\n\n비중이 아닌 상품군별 규모를 확인해봄\n\n음반 비디오 악기가 가장 규모가 컸고, 다음으로 의류 및 패션관련 상품의 규모가 컸음\n\n\n\n# 상위 3개국가에 대해 상품군별 시각화해서 분석함\nplt.figure(figsize=(20,5))\nsns.barplot(data=df_2020_top3, x='상품군별', y='백만', hue='국가(대륙)별', errorbar=None, dodge=False)\nplt.legend(bbox_to_anchor=(1.1,0.5), loc=6, borderaxespad=0)\nplt.show()\n\n\n\n\n\n\n\n\n\n미국, 일본은 ‘의류 및 패션상품’ 판매가 두드러지므로 해외직구활성화 방안 등을 강구한다면 해당 업종을 눈여겨 봐야할 듯 함\n두번째로는 ‘화장품’ 판매실적이 좋은데, 분류가 되어있지 않으니 기초/색조 여부 등을 보긴 해야겠지만\n\n기초화장품 쪽 주력인 업체가 있다면 진출을 고민하는 등의 방향을 고민해보면 좋을 듯 하고\n색조화장품 쪽 주력인 업체라면 해당 국가들의 미의 기준(선호색 등)을 파악하며 시작하면 좋을 듯 함\n\n중국은 ‘음반 비디오 악기’ 판매 실적이 좋은데, 2020년이라면 한류가 원인 중 하나가 아닐까 싶음\n\n간단히 구글링을 했을 때 ’한국구제문화교류진흥원’이란 곳의 보고서에 따르면 아래와 같은 상태 부분이 있음\n\n20년 1월~7월의 한국 3대 엔터테인먼트들의 주가는 상승했고, 원인 중 하나가 글로벌 팬덤의 확대와 빌보드 차트 진입과 중국 현지화 전략의 순항이라 함 (물론 위에서 말한 원인은 구체적 자료를 제시한 내용은 아님)\n중국판 미생의 방영 등 한류 자체는 긍정적인 상황으로 보임(물론 중국판 미생이 `18년 제작을 마쳤으니 위의 수치엔 영향 없을듯 함)\n\n\n중국의 한류에 대한 내용검색을 위한 보고서였지만, 제조업(화장품)관련 보고서 내용도 있었는데,\n\n화장품수출 강세는 색조화장품 뿐 아니라 기초화장품도 늘었다는 내용으로 보아 두 품목 모두 상승을 견인한 것으로 보임\n의류 강세관련하여, ’팬데믹으로 의류산업은 고전’중이지만 ’마스크, 방호복 등 관련 수요 증가’라는 내용이 있어 의류품목 관련 판단은 좀 더 해보아야겠음\n\n참고한 자료 : https://kofice.or.kr/b20industry/b20_industry_00_view.asp?seq=1134&tblID=gongji&clsID=0\n\n\n\n판매액 상위국가에 대한 주요 상품 시각화\n\nfilter_rule2 = (df['국가(대륙)별'].isin(['미국','일본','중국']))&(df['상품군별'].isin([\"의류 및 패션 관련상품\", \"화장품\", \"음반·비디오·악기\"]))\ndf_top3_categorical = df[filter_rule2].copy()\n\nfig, axs = plt.subplots(ncols=3, figsize=(15,4), # ncols(그래프 수), figsize(공간크기)\n                       gridspec_kw={'wspace':0.3},) #gridspec으로 그래프 사이 여백 설정\n\nylabel_text = {0:'백만',1:'',2:''}\nfor i, country  in enumerate(df_top3_categorical['국가(대륙)별'].unique()):\n    sns.lineplot(data=df_top3_categorical[df_top3_categorical['국가(대륙)별'] == country], \n                 x='연도', y='백만', hue='상품군별', errorbar=None, marker='o', palette=[\"b\", \"r\", 'g'],  style='상품군별',\n                 ax = axs[i])\n    axs[i].set_title('국가(대륙별) - ' + country)\n    axs[i].spines[['top','right']].set_visible(False) # 그래프 테두리 왼쪽,위,오른쪽 안보이게(false)\n    axs[i].legend().set_visible(False)\n    axs[i].set_ylabel(ylabel_text[i])\naxs[2].legend(bbox_to_anchor=(2,1), loc=0, borderaxespad=4)\n\n\n\n\n\n\n\n\n\n의류 분야는 세 국가 모두 `21년을 기점으로 하락세\n화장품은 미국/중국 하락세이나 일본이 크게 성장하여, `22년의 화장품 판매액은 일본의 영향이 크지 않을까 추측\n음반은 `21~22년도에 중국에서 판매액 증가가 뚜렷\n실제로도 확인해보니, `22년도 판매액은 일본의 비중이 컸음(하단 그래프)\n\n\nplt.figure(figsize=(10,4))\nsns.barplot(data=df[(df['연도'] == 2022) & (df['상품군별'] == '화장품')],\n             x='국가(대륙)별', y='백만', hue='상품군별', dodge=False)\nplt.legend(bbox_to_anchor=(1.1,0.5), loc=6, borderaxespad=0) #bbox_to_anchor(그래프와의 관격, 위/아래 위치)\n             #loc(좌우), borderaxespad(클수록 아래로)"
  },
  {
    "objectID": "posts/coach-ds-20221113/index.html#추가과제",
    "href": "posts/coach-ds-20221113/index.html#추가과제",
    "title": "[간단분석] KOSIS 온라인쇼핑 해외직접판매액 간단분석 (타 주제 Choropleth시각화)",
    "section": "추가과제",
    "text": "추가과제\n\n현재 분석과는 관계없지만, 함께 진행한 과제가 있어 기록만 해둠\n\n\n# Choropleth 시각화\n\n# 데이터 불러오기 & 가공(월 합계 등)\nraw_data = pd.read_csv(\n    '국가별_수출입현황_20221119232639.csv', \n    encoding=\"cp949\")\n\niso_table = pd.read_excel('iso_alpha.xlsx', engine='openpyxl')\niso_table = iso_table[['나라 이름','alpha-3']]\n\nraw_data_saved = raw_data.copy()\nraw_data_saved['2022년합계'] = raw_data_saved[raw_data_saved.columns[2:]].sum(axis=1)\n\n# Pivot table(국가별 합계) - 합계 0은 제외 (시각화되어있지않으면 0으로 간주, 메모리도 더 절약될 것이라 생각)\npivoted = raw_data_saved.groupby(['국가별(1)'])[['2022년합계']].sum()\npivoted = pivoted[pivoted['2022년합계']!=0]\n\n# replace로 국가명↔코드로 변환 (영문으로 변환되지 않은 국가['키리바티', '타지크' 등 생소한 국가]는 제외했습니다)\npivoted['iso_table']=pivoted.index\npivoted['국가명']=pivoted.index\npivoted['iso_table'] = pivoted['iso_table'].replace(iso_table['나라 이름'].tolist(),iso_table['alpha-3'].tolist())\n\npivoted['iso_table'] = pivoted['iso_table'][((pivoted['iso_table'].str.upper()) != (pivoted['iso_table'].str.lower()))]\npivoted\n\n\n\n\n\n\n\n\n\n2022년합계\niso_table\n국가명\n\n\n국가별(1)\n\n\n\n\n\n\n\n가나\n146268\nGHA\n가나\n\n\n가봉\n-709661\nGAB\n가봉\n\n\n가이아나\n20358\nGUY\n가이아나\n\n\n감비아\n-1354\nGMB\n감비아\n\n\n건지\n7\nNaN\n건지\n\n\n...\n...\n...\n...\n\n\n필리핀\n6247769\nPHL\n필리핀\n\n\n허드 앤 맥도날드 군도\n-27\nNaN\n허드 앤 맥도날드 군도\n\n\n헝가리\n3696148\nHUN\n헝가리\n\n\n호주\n-19871753\nAUS\n호주\n\n\n홍콩\n20619857\nHKG\n홍콩\n\n\n\n\n244 rows × 3 columns\n\n\n\n\n\n# plotly의 choropleth를 활용\n# 지도위에 마우스를 올리면 국가명/iso code / 무역수지(백만단위)를 표현\nimport plotly.express as px\n\nfig = px.choropleth(pivoted, locations=\"iso_table\",\n                    color=\"2022년합계\",\n                    hover_name=\"국가명\",\n                    color_continuous_scale=px.colors.sequential.Plasma,\n                   title='2022년 국가별 무역수지 현황')\n\nfig.show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nQuarto rendring 문제로 출력 예시 이미지 첨부"
  },
  {
    "objectID": "posts/coach-ds-20231107/index.html",
    "href": "posts/coach-ds-20231107/index.html",
    "title": "[간단분석] 공공데이터 상권정보로 인터랙티브 맵 시각화(folium)",
    "section": "",
    "text": "공공데이터포털 자료로 인터렉티브맵(folium) 시각화 연습\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/coach-ds-20231107/index.html#데이터-불러오기",
    "href": "posts/coach-ds-20231107/index.html#데이터-불러오기",
    "title": "[간단분석] 공공데이터 상권정보로 인터랙티브 맵 시각화(folium)",
    "section": "데이터 불러오기",
    "text": "데이터 불러오기\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport koreanize_matplotlib\nimport matplotlib.pyplot as plt\n\n\ndf = pd.read_csv('medical_201909.csv', encoding=\"cp949\", low_memory=False)\n\n\nfolium 시각화 연습\n\nimport folium\nfrom folium.plugins import MarkerCluster\n\n# 데이터 추출\ndf_elder = df[df['상권업종소분류명'] == '노인/치매병원'].copy()\n\n# folium 지도 생성 (fit_bounds에 위도/경도를 넣어 적정 zoom 상태로 시작)\nlatitude = df_elder['위도']\nlongitude = df_elder['경도']\nmain_folium_map = folium.Map(location=[latitude.mean(),longitude.mean()])\nmain_folium_map.fit_bounds([[latitude.min(), longitude.min()],[latitude.max(),longitude.max()]])\n\n# 시/도별 색상을 다르게 하기위해 색상표 추가 (별도 확인한 folium색상리스트와 데이터의 시도명 활용)\nindex_color= ['red', 'blue', 'green', 'purple', 'orange', 'darkred',\n         'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue',\n         'darkpurple', 'white', 'pink', 'lightblue', 'lightgreen',\n         'gray', 'lightgray']\nindex_address = df_elder['시도명'].value_counts().index.tolist()\ncolor_table = {}\n\nfor i, area in enumerate(index_address):\n  color_table[area] = index_color[i]\n\n# 위도/경도 기준으로 지도에 마커 추가\n\n# 상호명은 아이콘 위에 마우스 올리면 보이게 함 (tooltip)\n# 주소는 클릭하면 조이게 하고, 세로로 뜨지않게 Popup(address, max_width=200) 을 활용\n# 시도별 색상부여를 위해 위에서 만든 색상표 사용, 시도명 null값은 딕셔터리.get(,'black)으로 처리\n# 요양병원에 맞는 아이콘 부여 (prefix='fa', icon='blind') prefix fa에 참고한 사이트 : https://glyphsearch.com/\n# MarkerCluster를 활용해 클러스터화(묶음) 수행\ncluster = MarkerCluster()\nfor idx in df_elder.index:\n  location = [df_elder.loc[idx, '위도'], df_elder.loc[idx, '경도']]\n  name = df_elder.loc[idx, '상호명']\n  address = df_elder.loc[idx, '도로명주소']\n  icon_color = color_table.get(df_elder.loc[idx, '시도명'],'black')\n\n  cluster.add_child(\n      folium.Marker(location,\n                    popup=folium.Popup(address, max_width=200),\n                    tooltip=name,\n                    icon=folium.Icon(color=icon_color, prefix='fa', icon='blind')\n                    )\n  ).add_to(main_folium_map)\n\nmain_folium_map\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n썸네일용 이미지 업로드"
  },
  {
    "objectID": "posts/pycon-20230813/index.html",
    "href": "posts/pycon-20230813/index.html",
    "title": "[Pycon2023] 짠내나는 데이터 다루기 세션 정리",
    "section": "",
    "text": "파이콘에서 들었던 ’짠내나는 데이터 다루기’세션 내용정리입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/pycon-20230813/index.html#개요",
    "href": "posts/pycon-20230813/index.html#개요",
    "title": "[Pycon2023] 짠내나는 데이터 다루기(박조은님 세션) 정리",
    "section": "",
    "text": "파이콘 세션 듣고 간단히 정리  \n파이콘 사이트 : https://2023.pycon.kr/"
  },
  {
    "objectID": "posts/pycon-20230813/index.html#세션내용-정리",
    "href": "posts/pycon-20230813/index.html#세션내용-정리",
    "title": "[Pycon2023] 짠내나는 데이터 다루기(박조은님 세션) 정리",
    "section": "세션내용 정리",
    "text": "세션내용 정리\n\n메모리 확보하기\n\n가상메모리 설정, 그래픽 설정 낮추기, 백그라운드 비활성화, 캐시 제거, 재부팅\n\n\n\n메모리 사용량 줄이기\n\n데이터 샘플링 (행/열 줄이기)\n\ndf.sample(n), df.sample(frac=0.1) * frac:비율\n도메인에 따라 샘플링 기준 달라짐(특정 상품군/기간/고객군 등)\n필요없는 컬럼 제거 #### 청크(Chunked Processing)\n메모리를 작은 청크로 나누어 처리(메모리에 청크 단위로 로드)\npd.read_csv(chunksize=100) * chunksize만큼의 row를 가져옴\n아래와 같은 형식으로 사용\n# Chunksize만큼 나누어서 리스트에 저장\nchunk_list = []\nfor chunk in pd.read_scv('sample.csv', chunksize=100):\n  # pd.to_numeric(, downcast='float)와 같은 옵션을 같이 사용하면 좋음\n  chunk_list.apppend(chunk)\n\n# 리스트를 concat을 활용하여 하나로 결합\npd.concat(chunk_list)\n추가검색해보니 Chunk size지정에 대한 용량별 가이드가 있어 참고해봄 (공식문서아님, 블로그글 참고함) 출처 : https://acepor.github.io/2017/08/03/using-chunksize/  #### Parquet형식 사용(데이터 압축)\n\nParquet : 효율적 데이터 저장/검색을 위한 오픈소스, 열 지향 형식, Java/Python/C++ 등 지원\n샘플코드(Codestral에게 유사하게 만들어달라고 함)\n\nimport pyarrow.parquet as pq\nimport glob\n\nparquet_files = glob.glob('yourdirectory/*.parquet')\n\nfor file in parquet_files:\n    metadata = pq.read_metadata(file)\n    print('Schema:', metadata.schema)\n    print('Other Metadata:', metadata.metadata)\n\nKaggle의 Hotel booking demand로 실험한 것 보여주셨는데, 31.37GB → 4.95GB로 감소 #### 데이터 타입을 지정해서 불러오기\n\n아래와 같이 dtype을 지정해서 불러오는 경우 메모리 사용량이 절약될 수 있다\n\n  dtype_dict = {'기준년도':'uint16', '가입자일련번호':'uint32'}\n  pd.read_csv('sample.csv', dtype=dtype_dict)\n\nKaggle의 Hotel booking demand로 실험한 것 보여주셨는데, 29MB → 5.6MB로 감소 #### 분산처리 프레임워크(Dask, Vaex, PySpark 등 사용)\nDask : 병렬처리를 위한 분산 컴퓨팅 프레임워크, 큰 데이터를 처리할 수 있음, pandas와 유사한 API\nVaex : 디스크 기반의 컬럼 지향방식을 활용하여 대용량 데이터 처리 \nPySpark : Apache spark의 Python API (대규모 데이터 처리를 위한 분산컴퓨팅프레임워크 Spark를 파이썬에서 사용)"
  },
  {
    "objectID": "posts/pycon-20230813/index.html#메모리-확보하기",
    "href": "posts/pycon-20230813/index.html#메모리-확보하기",
    "title": "[Pycon2023] 짠내나는 데이터 다루기 세션 정리",
    "section": "메모리 확보하기",
    "text": "메모리 확보하기\n\n가상메모리 설정, 그래픽 설정 낮추기, 백그라운드 비활성화, 캐시 제거, 재부팅"
  },
  {
    "objectID": "posts/pycon-20230813/index.html#메모리-사용량-줄이기",
    "href": "posts/pycon-20230813/index.html#메모리-사용량-줄이기",
    "title": "[Pycon2023] 짠내나는 데이터 다루기 세션 정리",
    "section": "메모리 사용량 줄이기",
    "text": "메모리 사용량 줄이기\n\n데이터 샘플링 (행/열 줄이기)\n\ndf.sample(n), df.sample(frac=0.1) * frac:비율\n도메인에 따라 샘플링 기준 달라짐(특정 상품군/기간/고객군 등)\n필요없는 컬럼 제거\n\n\n\n청크(Chunked Processing)\n\n메모리를 작은 청크로 나누어 처리(메모리에 청크 단위로 로드)\npd.read_csv(chunksize=100) * chunksize만큼의 row를 가져옴\n아래와 같은 형식으로 사용\n# Chunksize만큼 나누어서 리스트에 저장\nchunk_list = []\nfor chunk in pd.read_scv('sample.csv', chunksize=100):\n  # pd.to_numeric(, downcast='float)와 같은 옵션을 같이 사용하면 좋음\n  chunk_list.apppend(chunk)\n\n# 리스트를 concat을 활용하여 하나로 결합\npd.concat(chunk_list)\n추가검색해보니 Chunk size지정에 대한 용량별 가이드가 있어 참고해봄 (공식문서아님, 블로그글 참고함) 출처 : https://acepor.github.io/2017/08/03/using-chunksize/ \n\n\n\nParquet형식 사용(데이터 압축)\n\nParquet : 효율적 데이터 저장/검색을 위한 오픈소스, 열 지향 형식, Java/Python/C++ 등 지원\n샘플코드(Codestral에게 유사하게 만들어달라고 함)\n\nimport pyarrow.parquet as pq\nimport glob\n\nparquet_files = glob.glob('yourdirectory/*.parquet')\n\nfor file in parquet_files:\n    metadata = pq.read_metadata(file)\n    print('Schema:', metadata.schema)\n    print('Other Metadata:', metadata.metadata)\n\nKaggle의 Hotel booking demand로 실험한 것 보여주셨는데, 31.37GB → 4.95GB로 감소\n\n\n\n데이터 타입을 지정해서 불러오기\n\n아래와 같이 dtype을 지정해서 불러오는 경우 메모리 사용량이 절약될 수 있다\n\n  dtype_dict = {'기준년도':'uint16', '가입자일련번호':'uint32'}\n  pd.read_csv('sample.csv', dtype=dtype_dict)\n\nKaggle의 Hotel booking demand로 실험한 것 보여주셨는데, 29MB → 5.6MB로 감소\n\n\n\n분산처리 프레임워크(Dask, Vaex, PySpark 등 사용)\n\nDask : 병렬처리를 위한 분산 컴퓨팅 프레임워크, 큰 데이터를 처리할 수 있음, pandas와 유사한 API\nVaex : 디스크 기반의 컬럼 지향방식을 활용하여 대용량 데이터 처리 \nPySpark : Apache spark의 Python API (대규모 데이터 처리를 위한 분산컴퓨팅프레임워크 Spark를 파이썬에서 사용)"
  },
  {
    "objectID": "posts/hanbitn-copilot-20230914/index.html",
    "href": "posts/hanbitn-copilot-20230914/index.html",
    "title": "[한빛앤] GitHub Copilot 세미나 정리",
    "section": "",
    "text": "한빛앤 Copilot세미나 내용 정리(+Codeium, Codestral’)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/hanbitn-copilot-20230914/index.html#개요",
    "href": "posts/hanbitn-copilot-20230914/index.html#개요",
    "title": "[한빛앤] GitHub Copilot 세미나 정리",
    "section": "개요",
    "text": "개요\n\n한빛앤 코파일럿 세미나 다녀와서 정리"
  },
  {
    "objectID": "posts/hanbitn-copilot-20230914/index.html#내용-정리",
    "href": "posts/hanbitn-copilot-20230914/index.html#내용-정리",
    "title": "[한빛앤] GitHub Copilot 세미나 정리",
    "section": "내용 정리",
    "text": "내용 정리\n\nAuto complete : 코드를 먼저 쓰면 해주는 제안을 활용가능\n비사용자 대비 코딩시간 최대 55% 단축\n\n두 그룹에 자바스크립트 작성을 시킨 후 비교  https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/\n\n시간을 단축하고 개발자의 정신적에너지를 절약하여 고부가가치에 집중하게 하기\n보안이슈\n\n코파일럿은 제품 개선을 위해 데이터를 수집함(암호화 및 일부만 열람하게 한다고는 함)\n내 코드가 학습에 사용되는게 싫으면 세팅에서 수집하지 않도록 할 수 있음\n\n코파일럿 X\n\nChatGPT처럼 질문할 수 있고 답변받을 수 있음\n대화한 내용에 대해 물어볼만한 질문도 선택지로 제시\n각 프로젝트의 언어(Python 등)에 맞춰 답변\n\n대체제\n\nCodeium : 개인사용 무료, Autocomplete 가능, Chat 가능\nTabnine : 무료버전 있음, Local Machine mode(보안에 좋을 듯)\n\n사용 후기\n\nCopilot : 한달 무료 사용. Autocomplete기능 자체를 처음 써봐서 좋긴 했음 xml과 beautifulsoup관련 어려움이 있었는데 도움이 꽤 되었음\nCodeium : 개인플랜 무료 사용. Chat기능을 별도로 쓸 일이 없었음 설치형이라 회사에 도입은 어려울 것 같았음(설치는 늘 승인받으라해서)\n직업 개발자가 아니어서인지 고급기능을 쓸 일이 없어서, 내 경우는 Autocomplete정도로 충족이 되어 Codeium을 사용하기로 함\n(2024.06추가) 요즘은 코드특화된 모델이 많이 나와서 채팅 쪽은 오히려 코드스트랄 등이 체감상 더 나은 것 같음\n\nCodestral(Mistral Codemodel) : Mistral Lechat 접속 후 아래와 같이 모델을 변경하여 사용 가능"
  },
  {
    "objectID": "posts/dtcontest-ore-20240608/index.html",
    "href": "posts/dtcontest-ore-20240608/index.html",
    "title": "[공모전] 공공데이터 공모전-1(대상광물 분석, 공공데이터API)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(+공공데이터 API활용샘플)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240608/index.html#개요",
    "href": "posts/dtcontest-ore-20240608/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-1(대상광물 분석, 공공데이터API)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\n공공데이터를 csv로 저장하지 않고 API로 활용해보기로 함"
  },
  {
    "objectID": "posts/dtcontest-ore-20240608/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240608/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-1(대상광물 분석, 공공데이터API)",
    "section": "내용정리",
    "text": "내용정리\n\n과제 요약\n\n과제명 : 핵심 광물별 공급위기 요소 탐지 모델 개발\n과제 개요 : 핵심광물별 가격 변동성, 시세, 생산·수입국 현황 등으로 핵심 광물별로 공급 리스크를 줄일 수 있는 위기 요소 탐지 분석 모델 개발\n제출 서류 : 분석 결과보고서(양식활용), 분석 코드, 근거데이터 파일\n활용 계획 : 전기차 배터리, 반도체 등 첨단산업 민간기업에 다양한 핵심광물 수급현황 위기 요소 탐지에 대한 분석 방법, 결과 등을 제공하여 안정적인 수급리스크 정보지원 강화\n유의사항\n\n핵심광물의 수급현황 등을 기반으로 위기요소 탐지 분석\n\n광물가격 급등 등 변동성, 국제시세, 주요 생산·수입국 현황, 수입량·수입금액·수입의존도, 국내 비축확보율, 재자원화율 및 국내 주요 수요기업 정보 등\n\n인터넷에 공개되어 있는 모든 가용 데이터를 사용하여 자유롭게 작성\n\n단, 사용한 데이터는 출처를 표기하여 근거데이터로 제출(참고 사이트 : 관세청, 외교부, 기재부, 산업부, 무역협회, 수출입은행 등)\n\n\n\n\n\n분석대상 광물선정\n\n공모전 인지 및 시작이 늦어서, 최대한 효율적으로 진행하고자 함(1달이내 남음)\n분석대상 광물을 공모전에 언급된 모든 광물보다는, 중요한 광물 위주로 진행해보고자 함\n\n공모전에 언급된 광물 : 텅스텐, 코발트, 리튬, 망간, 니켈\n\n고려 요소\n\n업종별 소요량 등을 기준으로 가장 공통적인/주요한 광물을 찾아보고자 함\n상기 자료는 찾기가 어려워, 생산량, 소비량, 수출입물량을 기준으로 상대적 비교를 해보고자 함\n\n\n\n\n공공데이터포털 API사용을 위한 파이썬 함수 작성\n\nAPI로 데이터 호출해보니 아래의 내용을 확인할 수 있었음\n\n호출 url의 ’perPage’를 활용해 한번에 가져올 데이터 수(행)을 정할 수 있음\n호출된 json에서 currentCount와 totalCount로 가져온 데이터와 전체 데이터를 확인할 수 있음\n\n확인한 내용을 기반으로, 공공데이터포털에서 json을 지원하는 데이터는 별도 조작없이 가능하게 하자는 목적으로 함수작성함\n\n일단 1개만 호출하여 전체 데이터 수량을 확인하고, perPage값을 바꿔 전체 데이터를 불러옴\n\n\n\nimport requests\nimport json\nimport pandas as pd\n\ndef request_and_to_json(url):\n    response = requests.get(url)\n    json_ob = json.loads(response.text)\n    return json_ob\n\ndef chk_json_status_of_data_go_kr(json_obj):\n    other_data = ['currentCount', 'matchCount', 'page', 'perPage', 'totalCount']\n    result_dict = dict()\n    \n    for each_column in other_data:\n        result_dict[each_column] = json_obj[each_column]  \n    return result_dict \n\ndef download_from_data_go_kr_with_json(url):\n    json_ob = request_and_to_json(url)\n\n    json_status = chk_json_status_of_data_go_kr(json_ob)\n    if json_status['currentCount'] &lt; json_status['totalCount']:\n        url = url.replace('perPage=1',f'perPage={json_status[\"totalCount\"]}')\n        json_ob = request_and_to_json(url)\n\n    return json_ob\n\n\n# API사용을 위한 개인키 입력\nserviceKey = '(개인키)'\n\n\n\n개별분석\n\n광종별 소요량\n\n공공데이터포털 - 한국광해광업공단_광종별 소비현황  https://www.data.go.kr/data/3070245/fileData.do#tab-layer-file\n\n\nbase_url = 'https://api.odcloud.kr/api'\naddress_get = '/3070245/v1/uddi:d950e6bc-e6a0-407c-baad-dfa87d739ff1_202004091120'\nurl = f'{base_url}{address_get}?page=1&perPage=1&serviceKey={serviceKey}'\njson_1 = download_from_data_go_kr_with_json(url)\nchk_json_status_of_data_go_kr(json_1)\n\n{'currentCount': 410,\n 'matchCount': 410,\n 'page': 1,\n 'perPage': 410,\n 'totalCount': 410}\n\n\n\ndf_1 = pd.json_normalize(json_1['data'])\ndf_1\n\n\n\n\n\n\n\n\n\n2011 소비량\n2012 소비량\n2013 소비량\n2014 소비량\n2015 소비량\n2016 소비량\n2017 소비량\n2018 소비량\n2019 소비량\n2020 소비량\n2021 소비량\n2022 소비량\n2023 소비량\n광종\n국가\n단위\n대륙\n품목\n\n\n\n\n0\n293.867\n253.700\n201.000\n225.800\n220.751\n226.106\n247.578\n260.381\n246.674\n190.106\n198.989\n337.973\n272.189\n알루미늄\nAustria\n천톤\nEUROPE\nrefined\n\n\n1\n10.200\n10.200\n10.200\n29.598\n21.898\n30.197\n27.001\n27.052\n31.673\n29.178\n39.481\n3.276\n2.400\n알루미늄\nBelarus\n천톤\nEUROPE\nrefined\n\n\n2\n382.312\n344.280\n236.780\n202.967\n231.648\n184.982\n212.039\n233.065\n181.368\n138.809\n204.808\n257.193\n160.985\n알루미늄\nBelgium\n천톤\nEUROPE\nrefined\n\n\n3\n52.188\n53.527\n60.645\n87.027\n109.824\n110.526\n109.522\n111.927\n119.211\n95.958\n128.057\n121.134\n97.254\n알루미늄\nBulgaria\n천톤\nEUROPE\nrefined\n\n\n4\n77.771\n83.684\n76.755\n66.065\n24.672\n52.033\n96.463\n112.930\n136.757\n143.869\n159.163\n135.867\n129.308\n알루미늄\nCroatia\n천톤\nEUROPE\nrefined\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n405\n939.000\n892.000\n935.000\n962.000\n931.000\n788.980\n829.000\n1800.000\n1800.000\n950.000\n878.000\n973.000\n911.000\n아연\nU.S.A.\n천톤\nAMERICA\nslab\n\n\n406\n0.000\n0.520\n0.514\n0.304\n0.449\n0.316\n0.312\n0.235\n0.235\n0.299\n0.350\n0.360\n0.371\n아연\nUruguay\n천톤\nAMERICA\nslab\n\n\n407\n10.430\n6.656\n9.014\n4.872\n2.246\n1.994\n0.685\n0.596\n0.596\n0.442\n0.360\n0.300\n0.370\n아연\nVenezuela\n천톤\nAMERICA\nslab\n\n\n408\n207.319\n116.293\n180.000\n174.400\n176.000\n178.000\n145.000\n146.700\n146.700\n135.000\n122.000\n125.000\n96.000\n아연\nAustralia\n천톤\nOCEANIA\nslab\n\n\n409\n11.023\n9.275\n8.844\n7.238\n6.876\n8.684\n10.631\n11.550\n11.550\n10.653\n10.332\n9.407\n6.405\n아연\nNew Zealand\n천톤\nOCEANIA\nslab\n\n\n\n\n410 rows × 18 columns\n\n\n\n\n\n# 광종 및 소비량 확인\nprint(df_1['광종'].unique())\nprint(df_1.columns)\n\n['알루미늄' '카드뮴' '동' '연' '니켈' '주석' '아연']\nIndex(['2011 소비량', '2012 소비량', '2013 소비량', '2014 소비량', '2015 소비량', '2016 소비량',\n       '2017 소비량', '2018 소비량', '2019 소비량', '2020 소비량', '2021 소비량', '2022 소비량',\n       '2023 소비량', '광종', '국가', '단위', '대륙', '품목'],\n      dtype='object')\n\n\n\n# str처리된 float값 변환\ndf_1[['2011 소비량', '2012 소비량', '2013 소비량', '2014 소비량', '2015 소비량', '2016 소비량',\n       '2017 소비량', '2018 소비량', '2019 소비량', '2020 소비량', '2021 소비량', '2022 소비량',\n       '2023 소비량']] = df_1[['2011 소비량', '2012 소비량', '2013 소비량', '2014 소비량', '2015 소비량', '2016 소비량',\n       '2017 소비량', '2018 소비량', '2019 소비량', '2020 소비량', '2021 소비량', '2022 소비량',\n       '2023 소비량']].astype(float)\ndf_1.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 410 entries, 0 to 409\nData columns (total 18 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   2011 소비량  409 non-null    float64\n 1   2012 소비량  410 non-null    float64\n 2   2013 소비량  410 non-null    float64\n 3   2014 소비량  410 non-null    float64\n 4   2015 소비량  410 non-null    float64\n 5   2016 소비량  410 non-null    float64\n 6   2017 소비량  410 non-null    float64\n 7   2018 소비량  410 non-null    float64\n 8   2019 소비량  410 non-null    float64\n 9   2020 소비량  410 non-null    float64\n 10  2021 소비량  410 non-null    float64\n 11  2022 소비량  410 non-null    float64\n 12  2023 소비량  410 non-null    float64\n 13  광종        410 non-null    object \n 14  국가        410 non-null    object \n 15  단위        410 non-null    object \n 16  대륙        410 non-null    object \n 17  품목        410 non-null    object \ndtypes: float64(13), object(5)\nmemory usage: 57.8+ KB\n\n\n\n# 광종별 소비량\ndf1_consume = df_1.groupby(by=['광종'])[['2011 소비량', '2012 소비량', '2013 소비량', '2014 소비량', '2015 소비량', '2016 소비량',\n       '2017 소비량', '2018 소비량', '2019 소비량', '2020 소비량', '2021 소비량', '2022 소비량',\n       '2023 소비량']].sum()\ndf1_consume\n\n\n\n\n\n\n\n\n\n2011 소비량\n2012 소비량\n2013 소비량\n2014 소비량\n2015 소비량\n2016 소비량\n2017 소비량\n2018 소비량\n2019 소비량\n2020 소비량\n2021 소비량\n2022 소비량\n2023 소비량\n\n\n광종\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n니켈\n1651.690\n1729.344\n1794.140\n1579.073\n1730.944\n1855.296\n2090.518\n2339.103\n2430.139\n2442.837\n2962.181\n3003.505\n3171.547\n\n\n동\n19488.142\n20281.667\n21085.937\n22704.666\n22716.929\n23112.305\n23236.699\n23825.029\n23937.201\n24764.119\n24777.553\n25897.648\n27632.445\n\n\n아연\n12510.399\n12055.051\n12885.691\n13796.903\n13784.174\n13863.425\n14058.430\n14021.779\n14021.779\n13603.269\n13257.980\n13839.233\n14185.938\n\n\n알루미늄\n44428.294\n47851.313\n50670.176\n54045.963\n56775.631\n59293.053\n59905.431\n62043.652\n62608.661\n63407.663\n68102.645\n67853.241\n68826.117\n\n\n연\n10459.383\n10506.481\n11288.386\n10863.942\n11293.988\n11533.887\n12240.931\n12354.902\n12686.026\n11897.099\n14463.857\n14831.478\n14532.497\n\n\n주석\n372.530\n353.471\n355.130\n389.926\n363.759\n380.857\n375.021\n373.503\n362.765\n380.887\n374.583\n359.100\n344.361\n\n\n카드뮴\n23933.352\n23396.250\n27150.332\n28807.514\n27119.446\n27233.503\n26733.110\n24011.194\n20911.834\n19882.427\n19813.410\n19521.471\n19994.543\n\n\n\n\n\n\n\n\n\nimport seaborn as sns\nimport koreanize_matplotlib\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(15,4))\nsns.heatmap(df1_consume, annot=True, fmt=\".0f\")\n\n\n\n\n\n\n\n\n\n상대적으로 알루미늄의 소비량이 가장 많음\n\n공모전 조원에게 받은 한국지질자원연구서의 보고서에 따르면, 지각 내에 3번째로 많이 들어있음 (2022.02 비철금속 비축 효과성/타당성 평가분석 및 중장기 정부비축방향)\n항공, 건축, 전기, 내화 등 다양한 용도로 사용되고 있으며, 4차 핵심사업의 용도로는 부합하지 않는 것으로 판단됨\n\n\n\nfor ore in df_1['광종'].unique():\n    if ore == '알루미늄' or ore == '카드뮴':\n        continue\n    df1_consume.loc[ore].plot()\nplt.legend()\n\n\n\n\n\n\n\n\n\n알루미늄을 제외하고 소비량이 상승하고 있는 광물 위주로 추림\n\n앞서 알루미늄에 대한 시각과 같이 4차 핵심사업의 용도로는 니켈만이 유력\n\n\n\ndf1_consume.loc['니켈'].plot()\n\n\n\n\n\n\n\n\n\n\n광종별 생산량\n\n공공데이터포털 - 한국광해광업공단_광종별 국가별 생산량  https://www.data.go.kr/data/3070256/fileData.do#/API%20%EB%AA%A9%EB%A1%9D/getuddi%3A6d31d5bc-5487-4fa1-a335-90f9d9623cc8_202004080953\n\n\nbase_url = 'https://api.odcloud.kr/api'\naddress_get = '/3070256/v1/uddi:6d31d5bc-5487-4fa1-a335-90f9d9623cc8_202004080953'\nurl = f'{base_url}{address_get}?page=1&perPage=1&serviceKey={serviceKey}'\n\njson_2 = download_from_data_go_kr_with_json(url)\nchk_json_status_of_data_go_kr(json_2)\n\n{'currentCount': 695,\n 'matchCount': 695,\n 'page': 1,\n 'perPage': 695,\n 'totalCount': 695}\n\n\n\ndf_2 = pd.json_normalize(json_2['data'])\ndf_2\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n광종\n국가\n단위\n대륙\n품목\n\n\n\n\n0\n561.354\n800.316\n657.100\n605.215\n787.404\n738.612\n740.380\n760.244\n1043.343\n619.748\n675.269\n669.926\n542.114\n알루미늄\nBosnia\n천톤\nEUROPE\nbauxite\n\n\n1\n0.000\n0.000\n0.000\n0.000\n11.900\n9.800\n12.200\n11.800\n14.300\n14.100\n14.500\n13.800\n13.800\n알루미늄\nCroatia\n천톤\nEUROPE\nbauxite\n\n\n2\n80.800\n90.129\n100.000\n71.100\n70.000\n110.000\n110.000\n110.000\n120.760\n123.496\n142.764\n120.000\n120.000\n알루미늄\nFrance\n천톤\nEUROPE\nbauxite\n\n\n3\n2324.000\n1815.328\n1844.000\n1876.000\n1831.270\n1880.000\n1927.145\n1559.360\n1379.123\n1428.639\n1227.000\n1173.000\n869.100\n알루미늄\nGreece\n천톤\nEUROPE\nbauxite\n\n\n4\n277.800\n255.100\n93.700\n14.400\n8.300\n16.700\n4.000\n5.000\n0.000\n0.000\n0.000\n0.000\n0.000\n알루미늄\nHungary\n천톤\nEUROPE\nbauxite\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n690\n662.151\n648.619\n651.637\n649.218\n683.118\n691.400\n598.438\n620.202\n654.971\n685.400\n639.843\n569.613\n502.000\n아연\nCanada\n천톤\nAMERICA\nslab\n\n\n691\n322.116\n323.569\n322.781\n320.924\n326.834\n321.166\n327.000\n335.942\n393.418\n368.200\n357.000\n328.727\n344.151\n아연\nMexico\n천톤\nAMERICA\nslab\n\n\n692\n313.714\n319.280\n346.361\n336.454\n335.422\n341.518\n312.339\n333.677\n356.925\n318.619\n320.000\n349.500\n346.072\n아연\nPeru\n천톤\nAMERICA\nslab\n\n\n693\n248.000\n261.000\n233.000\n180.000\n172.000\n126.000\n132.000\n116.000\n115.000\n180.000\n216.000\n216.000\n220.000\n아연\nU.S.A.\n천톤\nAMERICA\nslab\n\n\n694\n517.000\n508.000\n504.000\n488.000\n489.000\n470.000\n471.000\n491.000\n436.000\n447.300\n432.512\n385.032\n467.044\n아연\nAustralia\n천톤\nOCEANIA\nslab\n\n\n\n\n695 rows × 18 columns\n\n\n\n\n\n# 광종 및 생산량 확인\nprint(df_2['광종'].unique())\nprint(df_2.columns)\n\n['알루미늄' '안티모니' '카드뮴' '동' '금' '연' '몰리브덴' '니켈' '은' '주석' '아연']\nIndex(['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량', '광종', '국가', '단위', '대륙', '품목'],\n      dtype='object')\n\n\n\n# str처리된 float값 변환\ndf_2[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량']] = df_2[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량']].astype(float)\ndf_2.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 695 entries, 0 to 694\nData columns (total 18 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   2011 생산량  691 non-null    float64\n 1   2012 생산량  695 non-null    float64\n 2   2013 생산량  695 non-null    float64\n 3   2014 생산량  695 non-null    float64\n 4   2015 생산량  695 non-null    float64\n 5   2016 생산량  695 non-null    float64\n 6   2017 생산량  695 non-null    float64\n 7   2018 생산량  695 non-null    float64\n 8   2019 생산량  695 non-null    float64\n 9   2020 생산량  695 non-null    float64\n 10  2021 생산량  695 non-null    float64\n 11  2022 생산량  694 non-null    float64\n 12  2023 생산량  694 non-null    float64\n 13  광종        695 non-null    object \n 14  국가        695 non-null    object \n 15  단위        695 non-null    object \n 16  대륙        695 non-null    object \n 17  품목        695 non-null    object \ndtypes: float64(13), object(5)\nmemory usage: 97.9+ KB\n\n\n\n# 광종별 생산량\ndf2_produce = df_2.groupby(by=['광종'])[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량']].sum()\ndf2_produce\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n\n\n광종\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n금\n2570.328\n2644.576\n2886.315\n3017.911\n3083.170\n3180.769\n3.238410e+03\n3.263709e+03\n3.211746e+03\n3.066197e+03\n3.041123e+03\n3.147309e+03\n3.138277e+03\n\n\n니켈\n3467.292\n4140.150\n4538.125\n3925.512\n3970.324\n3839.161\n4.229470e+03\n4.623132e+03\n4.964282e+03\n4.972969e+03\n5.467607e+03\n6.303324e+03\n7.216948e+03\n\n\n동\n35816.170\n37138.574\n39170.057\n41019.128\n42338.447\n43631.801\n4.364408e+04\n4.403226e+04\n4.399504e+04\n4.471063e+04\n4.588754e+04\n4.758409e+04\n5.004668e+04\n\n\n몰리브덴\n268.602\n266.883\n278.853\n303.501\n296.261\n283.849\n2.915410e+02\n2.731790e+02\n2.764260e+02\n2.893510e+02\n2.688010e+02\n2.858460e+02\n2.804480e+02\n\n\n아연\n25676.388\n25887.690\n26613.454\n27099.928\n27286.373\n26155.233\n2.563553e+04\n2.541092e+04\n2.568426e+04\n2.614851e+04\n2.747017e+04\n2.712567e+04\n2.750890e+04\n\n\n안티모니\n156163.000\n174973.000\n192551.000\n158041.000\n155999.000\n165096.000\n1.590890e+05\n1.601380e+05\n1.227800e+05\n1.142970e+05\n8.946900e+04\n8.533900e+04\n8.443900e+04\n\n\n알루미늄\n295511.409\n308026.690\n351054.187\n311065.456\n328534.809\n341423.066\n3.746015e+05\n4.011228e+05\n4.261662e+05\n4.469730e+05\n4.548925e+05\n4.549827e+05\n4.715010e+05\n\n\n연\n15435.226\n15814.869\n16593.862\n16246.173\n15871.816\n16294.015\n1.629023e+04\n1.651490e+04\n1.688362e+04\n1.626823e+04\n1.897150e+04\n2.043378e+04\n1.952917e+04\n\n\n은\n23282.594\n24903.406\n26174.528\n27279.117\n27848.245\n28038.988\n2.643421e+04\n2.651451e+04\n2.625192e+04\n2.425894e+04\n2.563196e+04\n2.477051e+04\n2.527272e+04\n\n\n주석\n670.472\n662.043\n648.298\n694.752\n669.020\n639.671\n7.081480e+02\n7.180450e+02\n7.278870e+02\n7.277420e+02\n7.273120e+02\n6.603090e+02\n6.635190e+02\n\n\n카드뮴\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n2.532580e+07\n2.817260e+07\n2.505329e+07\n2.473016e+07\n2.486415e+07\n2.447090e+07\n2.477489e+07\n\n\n\n\n\n\n\n\n\n앞서 소비량 분석에서 4차 핵심산업에 부합하지 않을 것으로 배제했던 광물을 제외하고 확인\n\n\nfor ore in df_2['광종'].unique():\n    if ore not in ['동', '연', '주석', '아연', '알루미늄', '카드뮴']:\n        df2_produce.loc[ore].plot()\nplt.legend()\n\n\n\n\n\n\n\n\n\n생산량이 감소하고 있는 안티모니는 어떤 금속인지에 대해 조사\n\n방염, 페인트 합금, 고무 등에 사용되는 것으로, 안티모니도 대상에서 배제\n\n\n\nfor ore in df_2['광종'].unique():\n    if ore not in ['동', '연', '주석', '아연', '알루미늄', '카드뮴','안티모니']:\n        df2_produce.loc[ore].plot()\nplt.legend()\n\n\n\n\n\n\n\n\n\n# 니켈에 대한 국가별 생산량\ndf2_produce_country = df_2[df_2['광종']=='니켈'].groupby(by=['국가'])[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량']].sum()\ndf2_produce_country\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n\n\n국가\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlbania\n3.528\n0.728\n2.086\n4.889\n6.309\n3.952\n5.301\n4.204\n2.830\n3.764\n3.615\n1.423\n0.548\n\n\nAustralia\n325.227\n407.700\n433.872\n403.943\n378.205\n323.656\n293.966\n274.539\n265.220\n285.144\n249.845\n251.507\n241.140\n\n\nAustria\n0.500\n0.500\n0.500\n0.600\n0.700\n0.700\n0.700\n0.700\n0.700\n0.700\n0.700\n1.000\n1.000\n\n\nBotswana\n15.675\n17.948\n22.848\n14.952\n16.788\n16.878\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n\n\nBrazil\n117.801\n148.344\n130.611\n160.924\n159.906\n155.788\n137.303\n130.454\n109.944\n136.633\n136.788\n142.700\n131.400\n\n\nCanada\n361.470\n358.551\n380.471\n378.353\n384.236\n393.333\n369.061\n323.373\n317.894\n282.033\n235.219\n191.807\n214.341\n\n\nChina\n559.536\n684.172\n803.857\n638.237\n554.597\n537.173\n723.282\n841.119\n957.049\n857.237\n912.392\n974.155\n1044.821\n\n\nColombia\n75.636\n103.188\n98.772\n82.400\n73.400\n74.170\n81.200\n86.200\n81.200\n72.200\n76.600\n83.600\n77.400\n\n\nCuba\n102.532\n94.926\n72.236\n64.839\n64.731\n62.759\n65.041\n63.620\n58.430\n63.144\n64.929\n66.101\n62.213\n\n\nDominican Republic\n26.996\n30.372\n18.800\n0.000\n0.000\n19.826\n31.264\n38.428\n56.900\n42.632\n54.640\n56.800\n38.848\n\n\nFinland\n67.605\n65.473\n63.831\n62.433\n54.122\n75.687\n95.917\n104.337\n100.952\n104.781\n90.887\n129.668\n139.599\n\n\nFrance\n13.916\n13.546\n12.916\n8.812\n6.761\n4.287\n2.417\n3.700\n6.900\n7.300\n8.900\n6.842\n7.125\n\n\nGreece\n39.630\n40.150\n36.177\n39.891\n36.863\n36.463\n35.861\n33.609\n25.689\n13.071\n8.834\n3.124\n0.000\n\n\nGuatemala\n0.000\n2.422\n10.184\n49.899\n67.324\n53.434\n68.147\n53.708\n52.456\n72.537\n84.864\n69.181\n20.177\n\n\nIndia\n0.000\n0.000\n1.010\n2.028\n1.861\n0.329\n0.092\n0.077\n0.055\n0.000\n0.000\n0.000\n0.000\n\n\nIndonesia\n246.597\n640.591\n834.330\n167.151\n176.035\n308.017\n555.580\n907.673\n1250.383\n1411.019\n1915.958\n2745.018\n3589.948\n\n\nIvory Coast\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.576\n6.852\n16.421\n18.988\n27.849\n33.534\n36.279\n\n\nJapan\n156.883\n169.556\n177.810\n177.782\n192.789\n195.565\n187.046\n186.736\n182.652\n171.044\n180.721\n163.401\n153.248\n\n\nKazakhstan\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n\n\nKosovo\n15.132\n8.872\n15.214\n13.448\n13.300\n6.825\n15.621\n9.179\n8.548\n11.769\n10.646\n0.339\n0.360\n\n\nMacedonia\n20.892\n20.951\n20.001\n18.054\n17.699\n10.607\n7.175\n10.100\n15.202\n17.747\n17.714\n8.349\n3.812\n\n\nMadagascar\n0.000\n11.390\n50.298\n74.108\n94.542\n84.210\n70.948\n66.366\n67.466\n19.800\n58.704\n71.258\n75.828\n\n\nMorocco\n0.217\n0.288\n0.160\n0.000\n0.203\n0.188\n0.196\n0.126\n0.131\n0.142\n0.144\n0.144\n0.144\n\n\nMyanmar\n0.800\n9.800\n3.340\n39.428\n45.804\n45.200\n43.570\n35.604\n28.890\n49.078\n42.254\n16.868\n11.802\n\n\nNew Caledonia\n168.626\n177.076\n212.777\n237.223\n270.729\n300.193\n319.476\n324.139\n296.106\n272.152\n242.887\n266.171\n302.940\n\n\nNorway\n92.753\n91.940\n91.380\n90.846\n91.465\n92.914\n86.672\n91.054\n92.290\n91.374\n91.485\n82.163\n95.253\n\n\nPapua New Guinea\n0.000\n5.283\n11.370\n20.987\n25.581\n22.269\n34.666\n35.355\n32.722\n33.659\n31.594\n34.304\n33.604\n\n\nPhilippines\n319.353\n317.621\n313.050\n443.909\n466.754\n345.506\n379.377\n389.966\n341.325\n328.911\n393.687\n340.127\n382.568\n\n\nPoland\n1.700\n1.600\n1.200\n1.560\n1.680\n1.540\n1.440\n1.400\n1.440\n1.420\n1.440\n1.600\n1.680\n\n\nRussia\n536.000\n522.700\n506.000\n503.436\n492.916\n413.482\n372.562\n368.667\n379.762\n386.934\n311.033\n367.972\n354.259\n\n\nSouth Africa\n79.320\n78.446\n83.508\n89.656\n98.646\n91.104\n91.451\n82.730\n82.603\n64.030\n69.804\n66.623\n65.699\n\n\nSouth Korea\n16.863\n23.673\n28.130\n24.964\n39.007\n45.616\n47.402\n45.593\n46.269\n45.604\n47.270\n31.959\n40.022\n\n\nSpain\n0.000\n2.398\n7.574\n8.631\n7.213\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n\n\nTurkey\n0.848\n3.814\n1.178\n3.035\n8.637\n9.337\n14.767\n13.559\n4.742\n20.201\n11.647\n14.479\n14.400\n\n\nU.S.A.\n0.000\n0.000\n0.000\n4.300\n27.167\n24.114\n22.081\n17.573\n13.494\n16.718\n18.353\n17.475\n16.429\n\n\nUkraine\n22.475\n20.833\n26.751\n25.129\n20.842\n18.920\n15.605\n16.331\n15.133\n15.910\n15.657\n10.093\n0.733\n\n\nUnited Kingdom\n37.400\n39.400\n42.400\n39.100\n39.094\n43.104\n37.090\n38.211\n34.976\n35.177\n30.654\n33.384\n35.851\n\n\nVenezuela\n26.800\n16.200\n6.522\n5.000\n9.702\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n\n\nVietnam\n0.000\n0.000\n1.200\n6.932\n8.607\n4.272\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n\n\nZambia\n2.888\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n1.230\n3.780\n3.680\n3.942\n6.550\n\n\nZimbabwe\n11.693\n9.698\n15.761\n18.633\n16.109\n17.743\n16.617\n17.850\n16.278\n16.336\n16.213\n16.213\n16.927\n\n\n\n\n\n\n\n\n\n# 니켈에 대한 국가별 생산량의 총 합계\ndf2_produce_country_total = df2_produce_country[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량',\n       '2023 생산량']].sum(axis=1)\ndf2_produce_country_total.sort_values(ascending=False)\n\n국가\nIndonesia             14748.300\nChina                 10087.627\nRussia                 5515.723\nPhilippines            4762.154\nCanada                 4190.142\nAustralia              4133.964\nNew Caledonia          3390.495\nJapan                  2295.233\nBrazil                 1798.596\nNorway                 1181.589\nFinland                1155.292\nColombia               1065.966\nSouth Africa           1043.620\nCuba                    905.501\nMadagascar              744.918\nGuatemala               604.333\nUnited Kingdom          485.841\nSouth Korea             482.372\nDominican Republic      415.506\nMyanmar                 372.438\nGreece                  349.362\nPapua New Guinea        321.394\nUkraine                 224.412\nZimbabwe                206.071\nMacedonia               188.303\nU.S.A.                  177.704\nIvory Coast             140.499\nKosovo                  129.253\nTurkey                  120.644\nBotswana                105.089\nFrance                  103.422\nVenezuela                64.224\nAlbania                  43.177\nSpain                    25.816\nZambia                   22.070\nVietnam                  21.011\nPoland                   19.700\nAustria                   9.000\nIndia                     5.452\nMorocco                   2.083\nKazakhstan                0.000\ndtype: float64\n\n\n\n니켈 총생산량 기준 상위 10개국에 대한 시각화진행\n\n인도네시아, 중국, 러시아, 필리핀 순으로 상위 생산국\n\n\n\n# 니켈 총생산량 내림차순 기준 상위 10개국 Pie chart\ntarget_country = df2_produce_country_total.sort_values(ascending=False)[0:10].index.tolist()\ndf2_produce_country_total.loc[target_country].plot(kind='pie',startangle=145, autopct='%.1f%%', pctdistance=0.8)\n\n\n\n\n\n\n\n\n\n니켈에 대한 모델링 등을 할때, 주요 생산국의 관련 지표를 넣으면 좋을 듯 함\n\n\n\n광종별 수출입 현황\n\n공공데이터포털 - 한국광해광업공단_광종별 국내 수출입 현황  https://www.data.go.kr/data/3070177/fileData.do\n\n\nbase_url = 'https://api.odcloud.kr/api'\naddress_get = '/3070177/v1/uddi:09b79733-b804-4ec6-9968-dd0f58638b55_202004090938'\nurl = f'{base_url}{address_get}?page=1&perPage=1&serviceKey={serviceKey}'\n\njson_3 = download_from_data_go_kr_with_json(url)\nchk_json_status_of_data_go_kr(json_3)\n\n{'currentCount': 116,\n 'matchCount': 116,\n 'page': 1,\n 'perPage': 116,\n 'totalCount': 116}\n\n\n\ndf_3 = pd.json_normalize(json_3['data'])\ndf_3\n\n\n\n\n\n\n\n\n\n광종\n분류\n수입금액(천불)\n수입중량(톤)\n수출금액(천불)\n수출중량(톤)\n연도\n\n\n\n\n0\n금광\n금속광\n67000\n5705.000\n116\n1005.000\n2021\n\n\n1\n은광\n금속광\n302335\n37635.000\n79\n63.000\n2021\n\n\n2\n동광\n금속광\n6017233\n2097948.000\n1185720\n560664.000\n2021\n\n\n3\n연광\n금속광\n2366631\n642414.000\n670\n1102.000\n2021\n\n\n4\n아연광\n금속광\n2044885\n1819759.000\n34679\n23804.000\n2021\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n하석\n비금속광\n144\n321.000\n1\n0.000\n2022\n\n\n112\n무연탄\n석탄광\n1661049\n5384000.000\n251\n375.000\n2022\n\n\n113\n유연탄\n석탄광\n26230599\n117752000.000\n0\n0.000\n2022\n\n\n114\n갈탄\n석탄광\n65\n107.000\n0\n0.000\n2022\n\n\n115\n토탄\n석탄광\n25324\n110185.000\n41\n21.000\n2022\n\n\n\n\n116 rows × 7 columns\n\n\n\n\n\n# 광종 및 소비량 확인\nprint(df_3['광종'].unique())\nprint(df_3.columns)\n\n['금광' '은광' '동광' '연광' '아연광' '철광' '텅스텐광' '몰리브덴광' '망간광' '주석광' '창연' '안티모니광'\n '비소광' '황철석' '니켈' '코발트' '크롬광' '리튬광' '티타늄광' '질코늄광' '알루미늄광' '백금광' '탄탈륨광'\n '바나듐광' '니오븀광' '게르마늄광' '기타 금속' '인상흑연' '토상흑연' '활석' '납석' '장석' '고령토류' '석회석류'\n '규석' '규사' '황' '규조토' '형석' '인광석' '규회석' '운모' '주사' '홍주석' '규선석' '남정석' '중정석'\n '마그네사이트' '석고' '불석' '수정' '붕소광' '금강석' '하석' '기타 비금속' '무연탄' '유연탄' '갈탄' '토탄'\n '기타 석탄']\nIndex(['광종', '분류', '수입금액(천불)', '수입중량(톤)', '수출금액(천불)', '수출중량(톤)', '연도'], dtype='object')\n\n\n\n# str처리된 float값 변환\ndf_3[['수입중량(톤)', '수출중량(톤)',]] = df_3[['수입중량(톤)', '수출중량(톤)']].astype(float)\ndf_3.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 116 entries, 0 to 115\nData columns (total 7 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   광종        116 non-null    object \n 1   분류        116 non-null    object \n 2   수입금액(천불)  116 non-null    int64  \n 3   수입중량(톤)   116 non-null    float64\n 4   수출금액(천불)  116 non-null    int64  \n 5   수출중량(톤)   116 non-null    float64\n 6   연도        116 non-null    int64  \ndtypes: float64(2), int64(3), object(2)\nmemory usage: 6.5+ KB\n\n\n\n공모전에 언급된 주요광물에 대해서 추림\n\n\ndf3_sorted = df_3[df_3['광종'].isin(['텅스텐광','망간광','니켈','코발트','리튬광','알루미늄광'])]\ndf3_sorted\n\n\n\n\n\n\n\n\n\n광종\n분류\n수입금액(천불)\n수입중량(톤)\n수출금액(천불)\n수출중량(톤)\n연도\n\n\n\n\n6\n텅스텐광\n금속광\n60\n1.0\n84\n8.0\n2021\n\n\n8\n망간광\n금속광\n290356\n1325095.0\n0\n0.0\n2021\n\n\n14\n니켈\n금속광\n340685\n3181534.0\n42\n86.0\n2021\n\n\n15\n코발트\n금속광\n1\n0.0\n0\n0.0\n2021\n\n\n17\n리튬광\n금속광\n1047778\n94839.0\n53933\n4980.0\n2021\n\n\n20\n알루미늄광\n금속광\n33126\n424540.0\n45\n156.0\n2021\n\n\n66\n텅스텐광\n금속광\n607\n40.0\n3559\n1241.0\n2022\n\n\n68\n망간광\n금속광\n283632\n1085930.0\n5\n113.0\n2022\n\n\n74\n니켈\n금속광\n382427\n2653287.0\n206\n108.0\n2022\n\n\n75\n코발트\n금속광\n95\n12.0\n0\n0.0\n2022\n\n\n79\n알루미늄광\n금속광\n33150\n417762.0\n46\n478.0\n2022\n\n\n\n\n\n\n\n\n\nfor ore in ['텅스텐광','망간광','니켈','코발트','리튬광','알루미늄광']:\n    print(df3_sorted[df3_sorted['광종']==ore])\n    print()\n\n      광종   분류  수입금액(천불)  수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n6   텅스텐광  금속광        60      1.0        84      8.0  2021\n66  텅스텐광  금속광       607     40.0      3559   1241.0  2022\n\n     광종   분류  수입금액(천불)    수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n8   망간광  금속광    290356  1325095.0         0      0.0  2021\n68  망간광  금속광    283632  1085930.0         5    113.0  2022\n\n    광종   분류  수입금액(천불)    수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n14  니켈  금속광    340685  3181534.0        42     86.0  2021\n74  니켈  금속광    382427  2653287.0       206    108.0  2022\n\n     광종   분류  수입금액(천불)  수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n15  코발트  금속광         1      0.0         0      0.0  2021\n75  코발트  금속광        95     12.0         0      0.0  2022\n\n     광종   분류  수입금액(천불)  수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n17  리튬광  금속광   1047778  94839.0     53933   4980.0  2021\n\n       광종   분류  수입금액(천불)   수입중량(톤)  수출금액(천불)  수출중량(톤)    연도\n20  알루미늄광  금속광     33126  424540.0        45    156.0  2021\n79  알루미늄광  금속광     33150  417762.0        46    478.0  2022\n\n\n\n[광종별 간단 요약]\n\n텅스텐 : 수입 금액/중량 증가(가격비 비슷), 수출 금액/중량 증가\n망간 : 수입 금액/중량 감소\n니켈 : 수입 금액 증가, 수입 중량 감소 (가격 증가)\n코발트 : 수입 급격한 증가, 수출은 없음\n리튬 : 비교가능 데이터 없음\n\n[수출입 데이터 기준 고려사항]\n\n니켈 : 수입량과 가격 모두 증가\n니켈(수입량 증가와 가격 증가 추세로, 추가분석 필요하여 하단에서 계속 진행)\n코발트(수입 급격히 증가했으나 수출실적은 전혀없는 상황으로 국내 매장량 등 분석하고자 함)\n\n시간 상 관련 수치자료를 찾지 못하여 간단히 몇가지 검색해보니, 소요량에 대한 기사 발견 \n\n[기사]한국기업의 귀속생산량이 전세계 총합 대비 1% 이하 수준 https://www.businesspost.co.kr/BP?command=article_view&num=353613\n[한국경제인협회] 니켈, 리튬, 코발트에 대한 주요 생산국 및 수입량 추이 https://www.fki.or.kr/main/news/statement_detail.do?bbs_id=00035573&category=ST\n\n\n\n\n\n\n결론\n\n추가적인 분석에 따라 달라지겠지만 현재로서는 아래와 같음\n니켈\n\n4차 핵심사업에 소요되는 광물로 2011년 대비 2배이상 소요량 증가\n생산량이 증가하고 있으나 주요 3개국 생산량이 58.3%로 편중으로 인한 리스크 큼(생산국:인도네시아, 중국, 러시아)\n자료 시기가 2021, 2022년으로 많지는 않지만, 수입량의 감소에도 수입금액이 늘었다는 것은 가격 상승이 예상되는 상황\n소요량, 생산량, 수입데이터 기준 가격상승 예상 등 리스크가 있어보여 위험요소 탐지가 필요한 광물로 보임\n\n코발트\n\n수입량은 급격히 증가했으나, 수출량은 전무한 상황으로 생산자체가 불가하거나 국내 사용만으로도 부족한 상황이 아닐지 추측\n간단히 구글링하였을 때, 기사에 따르면 코발트 생산은 콩고 생산량이 68.8%일 정도로 편중이 심함\n코발트 또한 이차 전지에 활용되는 핵심광물로 위험 요소 탐지가 필요해보임\n\n니켈에 대해 분석한 내용을 모델링할 때 감안하거나, 최종보고서의 핵심광물 위험요소에 대한 당위성 부여 등에 활용하고자 함"
  },
  {
    "objectID": "posts/coach-ds-20231107/index.html#개요",
    "href": "posts/coach-ds-20231107/index.html#개요",
    "title": "[간단분석] 공공데이터 상권정보로 인터랙티브 맵 시각화(folium)",
    "section": "개요",
    "text": "개요"
  },
  {
    "objectID": "posts/dtcontest-ore-20240610/index.html",
    "href": "posts/dtcontest-ore-20240610/index.html",
    "title": "[공모전] 공공데이터 공모전-2(github온라인db)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(+github활용한 온라인db구축)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240610/index.html#개요",
    "href": "posts/dtcontest-ore-20240610/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-2(github온라인db)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\n단순 API로딩이 아니라, 각자 바로 데이터를 로딩할 수 있는 매체에 대한 고민 후 구현\n\n코딩이 익숙하지 않은 팀원이 쉽게 이용할 수 있도록하고, readme에 바로 사용할 수 있게 샘플코드 제공\ngithub를 활용해 pandas에서 바로 로딩할 수 있도록 구현"
  },
  {
    "objectID": "posts/dtcontest-ore-20240610/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240610/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-2(github온라인db)",
    "section": "내용정리",
    "text": "내용정리\n\n도입목적\n\n본격적으로 모델 학습을 하기 전, 데이터 이용 편의를 증진하고자 함\n팀원들이 R이나 통계분석에는 익숙하나 파이썬 코딩에는 익숙하지않아, 최대한 모델링에 집중하도록 지원\n\n하나의 repository에서 원하는 데이터를 한번에 확인 가능\n업데이트 일자를 표기하여 얼마나 최신 데이터인지 확인 가능\n\n데이터를 하나의 페이지에서 통합관리(공공데이터 홈페이지 접속 등 불필요)\n개인서버(NAS)에서 매일 특정시간 구동하여 별도의 수작업없이 자동으로 최신화\n\n\n\n구동방식\n\n공공데이터 리스트와 API키가 저장된 json파일 로딩\n지정된 공공데이터를 다운로드하고 csv파일로 저장\n바로 로딩하기위한 파일 주소생성, 업데이트 날짜 저장\nREADME 파일에 파일주소와 업데이트 날짜 등 업데이트\ngit_push함수로 github repository에 자동업로드\n\n\n\ngithub reposiroty주소\nhttps://github.com/KR9268/db_datagokr\n\n\n샘플코드(패키지 및 함수)\n\nimport requests\nimport json\nimport pandas as pd\nfrom datetime import datetime\nimport subprocess\nimport os\nimport time\n\ndef json_load(json_path, encoding='utf-8'):\n    with open(json_path, 'r', encoding=encoding) as file:\n        json_data = json.load(file)\n    return json_data\n\ndef request_and_to_json(url):\n    response = requests.get(url)\n    json_ob = json.loads(response.text)\n    return json_ob\n\ndef chk_json_status_of_data_go_kr(json_obj):\n    other_data = ['currentCount', 'matchCount', 'page', 'perPage', 'totalCount']\n    result_dict = dict()\n    \n    for each_column in other_data:\n        result_dict[each_column] = json_obj[each_column]  \n    return result_dict \n\ndef download_from_data_go_kr_with_json(url):\n    json_ob = request_and_to_json(url)\n\n    json_status = chk_json_status_of_data_go_kr(json_ob)\n    if json_status['currentCount'] &lt; json_status['totalCount']:\n        url = url.replace('perPage=1',f'perPage={json_status[\"totalCount\"]}')\n        json_ob = request_and_to_json(url)\n\n    return json_ob\n\ndef update_readme(new_content_list):\n    # Open the README.md file in read mode\n    with open('README.md', 'r', encoding='utf-8') as file:\n        lines = file.readlines()\n\n    # Find the index of the line that starts with '* 데이터 현황'\n    index = next((i for i, line in enumerate(lines) if line.startswith('* 데이터 현황')), None)\n\n    # If the line is found, remove the following lines and insert new content\n    if index is not None:\n        lines = lines[:index+1] # Remove the following lines\n        #lines.extend(new_content) # Insert new content\n        lines.extend(new_content_list) # Insert new content\n\n    # Open the README.md file in write mode and write the updated content\n    with open('README.md', 'w', encoding='utf-8') as file:\n        file.writelines(lines)\n\ndef git_push():\n    # Get a list of all .csv files in the current directory\n    csv_files = [f for f in os.listdir('.') if f.endswith('.csv')]\n\n    # Stage all .csv files\n    for file in csv_files:\n        subprocess.call(['git', 'add', file])\n\n    subprocess.call(['git', 'add', 'README.md'])\n    # Commit the changes with a message\n    subprocess.call(['git', 'commit', '-m', 'Automatic commit'])\n\n    # Push the changes to the remote repository\n    subprocess.call(['git', 'push'])\n\n\n\n샘플코드(메인코드)\n\n# json load\nserviceKey = json_load('option.json')['serviceKey']\ndb_list = json_load('db_list.json', 'cp949')\n\n\n# main\n\n# 작업하기\ntxt_for_readme = ['\\n']\nfor each in db_list:\n    # 다운로드\n    url = f\"{each['base_url']}{each['address_get']}?page=1&perPage=1&serviceKey={serviceKey}\"\n    json_data = download_from_data_go_kr_with_json(url)\n    result_data = chk_json_status_of_data_go_kr(json_data)\n    \n    # 저장\n    if result_data['currentCount'] == result_data['totalCount']:\n        pd.json_normalize(json_data['data']).to_csv(f\"{each['file_name_to']}.csv\",encoding='cp949', index=False)\n\n    # 파일주소 및 이름, 업데이트시간 저장\n    owner = 'KR9268'\n    repo = 'db_datagokr'\n    branch = 'main'\n    file_path = f\"{each['file_name_to']}.csv\"\n\n    url = f\"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{file_path}\"\n\n    txt_for_readme.append(f\"  *  {datetime.strftime(datetime.now(),'%Y-%m-%d')}업데이트 : {each['name']}\\n{url}\\n\")\n    time.sleep(1)\n\n# 업데이트 내역과 파일 git push\nupdate_readme(txt_for_readme)\ngit_push()"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "",
    "text": "본격적으로 모델 학습을 하기 전, 데이터 이용 편의를 증진하고자 함\n팀원들이 R이나 통계분석에는 익숙하나 파이썬 코딩에는 익숙하지않아, 최대한 모델링에 집중하도록 지원\n\n하나의 repository에서 원하는 데이터를 한번에 확인 가능\nrepository에서 바로 복사해서 사용가능한 샘플을 제공하여 쉽게 데이터로딩 가능\n\n데이터를 하나의 페이지에서 통합관리(공공데이터 홈페이지 접속 등 불필요)\n\n업데이트 일자를 표기하여 얼마나 최신 데이터인지 확인 가능\n추가하고자 하는 데이터가 공공데이터포털의 데이터라면 쉽게 작업내역에 추가가능 (리스트 추가권한을 주거나, discord봇 접수 등 생각해보았으나 구현시간대비 효용이 작아 직접 추가진행)\n\n개인서버(NAS)에서 매일 특정시간 구동하여, github서버로 자동 push(업로드)하여 별도의 수작업없이 db 최신화\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#추진배경",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#추진배경",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "",
    "text": "본격적으로 모델 학습을 하기 전, 데이터 이용 편의를 증진하고자 함\n팀원들이 R이나 통계분석에는 익숙하나 파이썬 코딩에는 익숙하지않아, 최대한 모델링에 집중하도록 지원\n\n하나의 repository에서 원하는 데이터를 한번에 확인 가능\nrepository에서 바로 복사해서 사용가능한 샘플을 제공하여 쉽게 데이터로딩 가능\n\n데이터를 하나의 페이지에서 통합관리(공공데이터 홈페이지 접속 등 불필요)\n\n업데이트 일자를 표기하여 얼마나 최신 데이터인지 확인 가능\n추가하고자 하는 데이터가 공공데이터포털의 데이터라면 쉽게 작업내역에 추가가능 (리스트 추가권한을 주거나, discord봇 접수 등 생각해보았으나 구현시간대비 효용이 작아 직접 추가진행)\n\n개인서버(NAS)에서 매일 특정시간 구동하여, github서버로 자동 push(업로드)하여 별도의 수작업없이 db 최신화"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#효과",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#효과",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "효과",
    "text": "효과\n\n특정 공공데이터 포털의 데이터를 사용하기 위해 했던 아래의 작업이 제거됨\n\n공공데이터포털에 접속하여 csv파일 저장\n저장해둔 csv파일 찾기\n해당 파일을 분석했던 jupyter파일로 찾아가 API호출주소나 키를 찾기\ncsv파일을 저장한 뒤 추가 업데이트가 되었는지 확인하고 재다운로드\n한국어 데이터 로딩을 위한 encoding규격 등의 숙지가 필요없음 (저장시 규격을 지정하고, 로딩을 위한 샘플코드에 규격을 지정해둠)\n\n위의 사항을 달성하기 위한 부가작업이 제거됨\n\ncsv파일 저장 및 업데이트 시기 기록, 서버에 업로드 및 파일주소 저장"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#github-repository",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#github-repository",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "github repository",
    "text": "github repository\n관련 github레포\n\nAPI개인키 등 정보가 있어 레포에는 csv파일과 현황만 저장함 (구현을 위해 필요한 db_list나 개인키 등의 json파일은 모두 ignore리스트로 관리)\ngit clone해둔 개인서버 디렉토리에서 자동 실행"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#세부내용-구현내용-사용한-언어패키지-등",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "[세부내용] 구현내용 & 사용한 언어/패키지 등",
    "text": "[세부내용] 구현내용 & 사용한 언어/패키지 등\n\njson_load(json) : 개인키와 db_list 로딩을 위한 함수. 어려운 기능은 아니지만 여러번 쓰여 함수화 \ndownload_from_data_go_kr_with_json(requests, json) : 공공데이터포털 API호출용 (실제 자료 + 전체/다운 현황 등 수신)\nchk_json_status_of_data_go_kr : 전체/실제 건수 등 별도 처리용(대조하여 누락없이 전체자료 저장하기 위함)\nupdate_readme : README파일에 파일 현황(데이터명/주소/링크 등) 업데이트용\ngit_push(subprocess) : 새롭게 추가된 모든사항(ignore대상 제외)을 자동으로 업로드(auto commit)하기 위한 용도\n위의 함수들을 기반으로 아래의 내용을 구현\n\n\njson으로 민감정보 등을 코드에 표기하지 않고 별도관리 (+ gitignore로 이중보안)\n1건만 먼저 호출하여 전체건수를 확인 후, 한번에 전체 건을 호출 (10000건 지정 등 과도한 세팅값의 하드코딩 지양)\npandas로 encoding cp949 지정하여 csv로 저장\ngithub raw링크형식을 활용하여 바로 파일로딩할 수 있도록 주소 생성(db에서 아래 형식으로 지정해둔 파일명 사용)\n\n[\n  {\n  \"name\": \"공공데이터포털의 데이터명\",\n  \"base_url\": \"API Base Url\",\n  \"address_get\": \"해당 데이터의 API주소(API목록 란에서 확인)\",\n  \"file_name_to\": \"CSV로 저장할 파일명(.csv제외)\"\n  },\n  {\n  \"name\": \"공공데이터포털의 데이터명2\",\n  \"base_url\": \"API Base Url\",\n  \"address_get\": \"해당 데이터의 API주소(API목록 란에서 확인)\",\n  \"file_name_to\": \"CSV로 저장할 파일명(.csv제외)\"\n  }\n]\n\ntime.sleep()으로 너무 자주 호출하여 서버에 무리가지 않도록 세팅"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#샘플코드패키지-및-함수",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#샘플코드패키지-및-함수",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "샘플코드(패키지 및 함수)",
    "text": "샘플코드(패키지 및 함수)\n\nimport requests\nimport json\nimport pandas as pd\nfrom datetime import datetime\nimport subprocess\nimport os\nimport time\n\ndef json_load(json_path, encoding='utf-8'):\n    with open(json_path, 'r', encoding=encoding) as file:\n        json_data = json.load(file)\n    return json_data\n\ndef request_and_to_json(url):\n    response = requests.get(url)\n    json_ob = json.loads(response.text)\n    return json_ob\n\ndef chk_json_status_of_data_go_kr(json_obj):\n    other_data = ['currentCount', 'matchCount', 'page', 'perPage', 'totalCount']\n    result_dict = dict()\n    \n    for each_column in other_data:\n        result_dict[each_column] = json_obj[each_column]  \n    return result_dict \n\ndef download_from_data_go_kr_with_json(url):\n    json_ob = request_and_to_json(url)\n\n    json_status = chk_json_status_of_data_go_kr(json_ob)\n    if json_status['currentCount'] &lt; json_status['totalCount']:\n        url = url.replace('perPage=1',f'perPage={json_status[\"totalCount\"]}')\n        json_ob = request_and_to_json(url)\n\n    return json_ob\n\ndef update_readme(new_content_list):\n    # Open the README.md file in read mode\n    with open('README.md', 'r', encoding='utf-8') as file:\n        lines = file.readlines()\n\n    # Find the index of the line that starts with '* 데이터 현황'\n    index = next((i for i, line in enumerate(lines) if line.startswith('* 데이터 현황')), None)\n\n    # If the line is found, remove the following lines and insert new content\n    if index is not None:\n        lines = lines[:index+1] # Remove the following lines\n        #lines.extend(new_content) # Insert new content\n        lines.extend(new_content_list) # Insert new content\n\n    # Open the README.md file in write mode and write the updated content\n    with open('README.md', 'w', encoding='utf-8') as file:\n        file.writelines(lines)\n\ndef git_push():\n    # Get a list of all .csv files in the current directory\n    csv_files = [f for f in os.listdir('.') if f.endswith('.csv')]\n\n    # Stage all .csv files\n    for file in csv_files:\n        subprocess.call(['git', 'add', file])\n\n    subprocess.call(['git', 'add', 'README.md'])\n    # Commit the changes with a message\n    subprocess.call(['git', 'commit', '-m', 'Automatic commit'])\n\n    # Push the changes to the remote repository\n    subprocess.call(['git', 'push'])"
  },
  {
    "objectID": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#샘플코드패키지-및-함수-1",
    "href": "posts_miniprojects/dtcontest-ore-py-datagokr/index.html#샘플코드패키지-및-함수-1",
    "title": "[Python] Github, API활용한 공공데이터 저장소 만들기",
    "section": "샘플코드(패키지 및 함수)",
    "text": "샘플코드(패키지 및 함수)\n\n# json load\nserviceKey = json_load('option.json')['serviceKey']\ndb_list = json_load('db_list.json', 'cp949')\n\n\n# main\n\n# 작업하기\ntxt_for_readme = ['\\n']\nfor each in db_list:\n    # 다운로드\n    url = f\"{each['base_url']}{each['address_get']}?page=1&perPage=1&serviceKey={serviceKey}\"\n    json_data = download_from_data_go_kr_with_json(url)\n    result_data = chk_json_status_of_data_go_kr(json_data)\n    \n    # 저장\n    if result_data['currentCount'] == result_data['totalCount']:\n        pd.json_normalize(json_data['data']).to_csv(f\"{each['file_name_to']}.csv\",encoding='cp949', index=False)\n\n    # 파일주소 및 이름, 업데이트시간 저장\n    owner = 'KR9268'\n    repo = 'db_datagokr'\n    branch = 'main'\n    file_path = f\"{each['file_name_to']}.csv\"\n\n    url = f\"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{file_path}\"\n\n    txt_for_readme.append(f\"  *  {datetime.strftime(datetime.now(),'%Y-%m-%d')}업데이트 : {each['name']}\\n{url}\\n\")\n    time.sleep(1)\n\n# 업데이트 내역과 파일 git push\nupdate_readme(txt_for_readme)\ngit_push()"
  },
  {
    "objectID": "posts/dtcontest-ore-20240612/index.html",
    "href": "posts/dtcontest-ore-20240612/index.html",
    "title": "[공모전] 공공데이터 공모전-3(사용할 피쳐 재분석)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(지표 및 사용할 데이터에 대한 고민)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240612/index.html#개요",
    "href": "posts/dtcontest-ore-20240612/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-3(사용할 피쳐 재분석)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\n사용하기로 한 지표에 대한 재조사 및 통합사용하기로 의견제안 예정\n모델의 Feature로 원자재의 벌크운송에 대한 운임지수(BDI)사용 의견제안 예정"
  },
  {
    "objectID": "posts/dtcontest-ore-20240612/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240612/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-3(사용할 피쳐 재분석)",
    "section": "내용정리",
    "text": "내용정리\n\n지난 회의정리\n\n모델링에 사용할 지표 2가지 선정\n\n수급안정화지수\n시장위험지수\n\n광물별 가격 영향 미치는 요소 생각해보기\n모델링 관련 아이디어\n\n\n\n회의내용에 대한 Self고찰 및 아이디어 Develope\n\n모델링에 사용할 지표에 대한 분석\n\n데이터를 살펴보다보니 둘의 움직임이 거의 같게 나타남\n가격리스크, 중장기적 시계 등 공통적인 요소가 서로 많은 지표임을 발견\n포함항목을 좀 더 구체적으로 명시한 수급안정화지수로 통합사용 하는 것으로 의견 제안 예정\n\n광종별 중장기 가격리스크, 세계 수급비율(공급/소비), 세계 공급(매장)편중도, 국내 수입증가율, 국내 수입국 편중도 등\n\n\n\n\nimport pandas as pd\nimport seaborn as sns\nimport koreanize_matplotlib\nimport matplotlib.pyplot as plt\n\ndf_source = pd.read_csv('비교_한국광해광업공단_수급안정화지수_코발트_20240520 (1).csv', encoding='cp949')\ndf_source[['기간','시장위험지수','수급안정화지수']].plot(x='기간')\n\n\n\n\n\n\n\n\n\n광물별 고려요소 및 모델링에 쓸 데이터 관련 아이디어\n\n고려대상 광물들의 세계 생산량 비중 등을 고려할 때 국제수송(수입)을 고려해야할 것으로 보임\n\n조사를 통해 상하이 컨테이너 운임지수(SCFI)를 확인, 국가별 운임지수에 대한 가중치를 반영한 지표로 주요 수입국에 대해 반영 고려\n\n그러나 광물운송의 특성상 컨테이너로 운송하지 않기 때문에 다른 지수를 모색\n\n벌크선에 대한 지수인 발틱운임지수(BDI) 도입 검토\n\n공급 대비 운송량에 대한 수요를 알 수 있음\n벌크선은 광물, 곡물 등을 운송하므로 원자재에 대한 글로벌 수요와 공급을 간접적으로 측정 원자재 소요에 대한 미래의 경제선행지표로도 간주되기도 함\n구체적인 운송수요가 있을 때만 예약되는 벌크선 특성상 특정 목적에 의해 조정되는 경우가 적음\n위키백과에서 위의 내용들 발췌 : https://en.wikipedia.org/wiki/Baltic_Dry_Index\n\n발틱운임지수(BDI)를 데이터로 사용하는 것으로 의견 제안 예정\n\n주요 생산국에 대한 여러 요소의 고려\n\n전쟁, 전염병, 인건비 등을 대상으로 고려할 수는 없을지에 대한 고민\n\n수치화하기 어렵거나, 자료를 구하기 어려울 것으로 보여 일단 Drop"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_1/index.html",
    "href": "posts/meta-dl-creditcard-20240615_1/index.html",
    "title": "[M_Study_3주차과제1] Softmax로 MNIST다루기",
    "section": "",
    "text": "스터디 진행하며 진행한 과제 기록(MNIST, Softmax)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_1/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240615_1/index.html#개요",
    "title": "[M_Study_3주차과제1] Softmax로 MNIST다루기",
    "section": "개요",
    "text": "개요\n참여중인 딥러닝 스터디 3주차 기록입니다.\n\nSoftmax로 MNIST다루기\n강사님이 주신 샘플코드 참고해서, 나에게 맞추거나 추가공부 진행"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_1/index.html#과제-작성-softmax-linear",
    "href": "posts/meta-dl-creditcard-20240615_1/index.html#과제-작성-softmax-linear",
    "title": "[M_Study_3주차과제1] Softmax로 MNIST다루기",
    "section": "과제 작성 (Softmax / Linear)",
    "text": "과제 작성 (Softmax / Linear)\n\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.datasets import mnist\n\n\nMnist Dataset로딩 및 전처리\n\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nfor i in (x_train, y_train, x_test, y_test):\n    print(i.shape)\n\n(60000, 28, 28)\n(60000,)\n(10000, 28, 28)\n(10000,)\n\n\n\nfloat변환\n\nx_train, x_test = np.array(x_train, np.float32), np.array(x_test, np.float32)\n\n\n\nFlatten\n\n# Flatten (num_features=784)\nnum_features = 784 # 28*28 (Data의 Shape)\n\nprint('Flatten전 : ', x_train.shape, x_test.shape)\nx_train, x_test = x_train.reshape(-1, num_features), x_test.reshape(-1, num_features)\nprint('Flatten후 : ', x_train.shape, x_test.shape)\n\nFlatten전 :  (60000, 28, 28) (10000, 28, 28)\nFlatten후 :  (60000, 784) (10000, 784)\n\n\n\n\nNormalize\n\n# Normalize (0~255사이의 값을 0~1 사이의 값으로)\nx_train, x_test = x_train / 255., x_test / 255.\n\n\n\n\n함수 및 파라메터 설정\n\n# Parameters\nlearning_rate = 0.01\ntraining_steps = 1000\nbatch_size = 256\n\nnum_classes = 10 # MNIST의 0~9 숫자 10개\nnum_features = 784 # 28*28 (Data의 Shape)\n\n# Variables\nW = tf.Variable(tf.ones([num_features, num_classes]), name='weight')\nb = tf.Variable(tf.zeros([num_classes]), name='bias')\n\n# Functions\ndef softmax(x):\n    z = tf.matmul(x, W) + b\n    sm = tf.nn.softmax(z)\n    return sm\n\ndef cross_entropy(y_pred, y_true):\n    y_true = tf.one_hot(y_true, depth=num_classes)\n    y_pred = tf.clip_by_value(y_pred, 1e-9, 1.) # clip_by_value에서 1e-9 최소값지정사유 : \n    return tf.reduce_mean(-tf.reduce_sum(y_true * tf.math.log(y_pred), axis=-1))\n\n\ntf.nn.softmax : 0~1 사이로 출력\ntf.one_hot(y_true, depth=num_classes) : y_true인 대상을 depth에 맞춰 원핫인코딩\n  # 샘플\n  tf.one_hot([2], depth=5).numpy()\n  &gt;&gt;&gt; array([[0., 0., 1., 0., 0.]], dtype=float32)\ntf.clip_by_value(y_pred, 1e-9, 1.) : y_pred인 대상을 제시한 min, max에 맞춰 변환\n  # 샘플\n  # 변환 전\n  t = tf.constant([[-1, 0, 1], [2, 3, 4]], dtype=tf.float32)\n  t.numpy()\n  &gt;&gt;&gt; array([[-1.,  0.,  1.],\n     [ 2.,  3.,  4.]], dtype=float32)\n  # 변환 후\n  tf.clip_by_value(t, clip_value_min=0, clip_value_max=2).numpy()\n  &gt;&gt;&gt; array([[0., 0., 1.],\n     [2., 2., 2.]], dtype=float32)\n\n\n# Optimization\ndef accuracy(y_pred, y_true):\n    correct_prediction = tf.equal(tf.argmax(y_pred, 1), tf.cast(y_true, tf.int64))\n    return tf.reduce_mean(tf.cast(correct_prediction, tf.float32), axis = 0)\n\ndef batch_maker(text, data_row, batch_size):\n    random_idx = np.random.randint(data_row, size = batch_size)\n    return x_train[random_idx], y_train[random_idx]\n\ndef run_optimization(x, y):\n    with tf.GradientTape() as g:\n        pred = softmax(x)\n        cost = cross_entropy(pred, y)\n\n    gradients = g.gradient(cost, [W, b])\n\n    optimizer.apply_gradients(zip(gradients, [W, b]))\n\n# Optimizer (Stochastic Gradient Descent)\noptimizer = tf.optimizers.SGD(learning_rate)\n\nfor step in range(training_steps): # training_steps = 1000로 위에서 지정해둠\n    batch_x, batch_y = batch_maker('training', 60000, batch_size) # batch_size = 256로 위에서 지정해둠\n\n    run_optimization(batch_x, batch_y)\n\n    if step % 100 == 0:\n        pred = softmax(batch_x)\n        cost = cross_entropy(pred, batch_y)\n        acc = accuracy(pred, batch_y)\n        print(f\"Step : {step} | loss : {cost} / accuracy : {acc}\")\n\nStep : 0 | loss : 2.287696123123169 / accuracy : 0.6875\nStep : 100 | loss : 1.5578452348709106 / accuracy : 0.7578125\nStep : 200 | loss : 1.188745379447937 / accuracy : 0.8359375\nStep : 300 | loss : 1.010088324546814 / accuracy : 0.796875\nStep : 400 | loss : 0.8610934019088745 / accuracy : 0.859375\nStep : 500 | loss : 0.807215690612793 / accuracy : 0.8359375\nStep : 600 | loss : 0.7144550085067749 / accuracy : 0.8671875\nStep : 700 | loss : 0.7559677362442017 / accuracy : 0.81640625\nStep : 800 | loss : 0.6656553745269775 / accuracy : 0.8515625\nStep : 900 | loss : 0.59657222032547 / accuracy : 0.8828125\n\n\n\n\n학습 후 Validation(Test)\n\n# W와 b가 학습된 model로 Validation(Test Dataset사용)\nprediction = softmax(x_test)\nprint(f\"Test accuracy : {accuracy(prediction, y_test)}\")\n\nTest accuracy : 0.8716999888420105\n\n\n\n\n추가적으로 검증기능 구현해보기\n\n추가적으로, 아래의 기능을 구현해보았음\n\nnumber_to_look을 입력하여 원하는 횟수만큼 모델검증\nrandint를 활용하여 랜덤추출, tested_list로 추출내역 관리하여 중복회피\npyplot으로 형태/예측/정답을 시각화\n\n\n\nimport koreanize_matplotlib\n\n# 시각화로 Validation 확인\nnumber_to_look = 4\ntested_list = []\n\nfor i in range(number_to_look):\n    plt.figure(figsize=(2,2))\n    # 테스트할 데이터 랜덤추출\n    idx = -1\n    while idx not in tested_list:\n        idx = np.random.randint(0, y_test.shape[0])\n        tested_list.append(idx)\n\n    # 결과 확인\n    plt.xlabel(f\"예상:{np.argmax(prediction[idx])} | 정답:{y_test[idx]}\")\n    plt.imshow(np.reshape(x_test[idx], [28, 28]), cmap=plt.cm.binary)\n    plt.show()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_2/index.html",
    "href": "posts/meta-dl-creditcard-20240615_2/index.html",
    "title": "[M_Study_3주차과제2] Neural Network로 MNIST다루기",
    "section": "",
    "text": "스터디 진행하며 진행한 과제 기록(MNIST, Neural Network)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_2/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240615_2/index.html#개요",
    "title": "[M_Study_3주차과제2] Neural Network로 MNIST다루기",
    "section": "개요",
    "text": "개요\n참여중인 딥러닝 스터디 3주차 기록입니다.\n\nNeural Network로 MNIST다루기\n강사님이 주신 샘플코드 참고해서, 나에게 맞추거나 추가공부 진행"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240615_2/index.html#과제-작성-neuralnetwork-nonlinear",
    "href": "posts/meta-dl-creditcard-20240615_2/index.html#과제-작성-neuralnetwork-nonlinear",
    "title": "[M_Study_3주차과제2] Neural Network로 MNIST다루기",
    "section": "과제 작성 (NeuralNetwork / NonLinear)",
    "text": "과제 작성 (NeuralNetwork / NonLinear)\n\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras import layers\nfrom keras.utils import to_categorical\n\nfrom tensorflow.keras.datasets import mnist\n\n\nMnist Dataset로딩 및 전처리\n\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nfor i in (x_train, y_train, x_test, y_test):\n    print(i.shape)\n\n(60000, 28, 28)\n(60000,)\n(10000, 28, 28)\n(10000,)\n\n\n\n# Shape 오류 발생하여 원핫인코딩 수행\n# X는 (28, 28)인데 Y는 그냥 정답(5면 5)여서 그런듯 함\n# ValueError: Arguments `target` and `output` must have the same rank (ndim). Received: target.shape=(None,), output.shape=(None, 10)\n\nx_train = x_train.reshape((60000, 28, 28, 1))\ny_train_one_hot = to_categorical(y_train, num_classes=10)\n\nx_test = x_test.reshape((10000, 28, 28, 1))\ny_test_one_hot = to_categorical(y_test, num_classes=10)\n\n\n\n모델구성\n\nCodestral에게 MNIST데이터셋에 적합한 파라미터와 레이어로 조정해달라고 하여 맞춤\n수업 때 거의 ReLU에요라고 들었는데 마지막 빼고는 거의 ReLU가 사용되었음\nSoftmax는 주로 마지막 층에 쓰인다고 들은 적이 있는데 여기서도 동일하게 되었음 (추가로 알아볼때도 주로 마지막레이어에 쓰인다는 내용 다수 확인)\n\n\n# 모델 구성\n# Mistral에게 Mnist데이터셋이 적합한 레이어와 파라메터로 구성해달라고 해서 조정\nmodel = Sequential([\n    layers.Input((28,28,1)),\n    layers.Conv2D(32, (3,3), padding='same', activation='relu'),\n    layers.BatchNormalization(),\n    layers.Conv2D(64, (3,3), padding='same', activation='relu'),\n    layers.BatchNormalization(),\n    layers.MaxPooling2D((2,2)),\n    layers.Dropout(0.25),\n    layers.Conv2D(128, (3,3), padding='same', activation='relu'),\n    layers.BatchNormalization(),\n    layers.MaxPooling2D((2,2)),\n    layers.Dropout(0.25),\n    layers.Flatten(),\n    layers.Dense(256, activation='relu'),\n    layers.BatchNormalization(),\n    layers.Dropout(0.5),\n    layers.Dense(10, activation='softmax')\n])\nmodel.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=['accuracy'])\n\nmodel.summary()\n\nModel: \"sequential_14\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ conv2d_40 (Conv2D)              │ (None, 28, 28, 32)     │           320 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_52          │ (None, 28, 28, 32)     │           128 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ conv2d_41 (Conv2D)              │ (None, 28, 28, 64)     │        18,496 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_53          │ (None, 28, 28, 64)     │           256 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ max_pooling2d_27 (MaxPooling2D) │ (None, 14, 14, 64)     │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_39 (Dropout)            │ (None, 14, 14, 64)     │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ conv2d_42 (Conv2D)              │ (None, 14, 14, 128)    │        73,856 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_54          │ (None, 14, 14, 128)    │           512 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ max_pooling2d_28 (MaxPooling2D) │ (None, 7, 7, 128)      │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_40 (Dropout)            │ (None, 7, 7, 128)      │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ flatten_14 (Flatten)            │ (None, 6272)           │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_27 (Dense)                │ (None, 256)            │     1,605,888 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_55          │ (None, 256)            │         1,024 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_41 (Dropout)            │ (None, 256)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_28 (Dense)                │ (None, 10)             │         2,570 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 1,703,050 (6.50 MB)\n\n\n\n Trainable params: 1,702,090 (6.49 MB)\n\n\n\n Non-trainable params: 960 (3.75 KB)\n\n\n\n\n\n모델학습 및 학습과정 시각화\n\nhistory = model.fit(x_train, y_train_one_hot, epochs=10, batch_size=64, verbose=0)\nhistory.history\n\n{'accuracy': [0.9526000022888184,\n  0.9849333167076111,\n  0.9872333407402039,\n  0.9904000163078308,\n  0.9906499981880188,\n  0.9917166829109192,\n  0.9925500154495239,\n  0.9933333396911621,\n  0.9935333132743835,\n  0.9948333501815796],\n 'loss': [0.09701579809188843,\n  0.014779138378798962,\n  0.01159658282995224,\n  0.009130637161433697,\n  0.008214634843170643,\n  0.007283014710992575,\n  0.0065074339509010315,\n  0.005834747105836868,\n  0.005641818046569824,\n  0.004907044116407633]}\n\n\n\nplt.plot(history.history['loss'], label='Train loss')\nplt.xlabel('The number of learning')\nplt.ylabel('Cost')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n모델평가 및 모델 활용한 예측\n\n모델평가\n\n\nmodel.evaluate(x_test, y_test_one_hot, verbose=0)\n\n[0.003361478913575411, 0.994700014591217]\n\n\n\n예측\n\n\ny_predict_one_hot = model.predict(x_test)\ny_predict = np.argmax(y_predict_one_hot, axis=1)\ny_predict\n\n313/313 ━━━━━━━━━━━━━━━━━━━━ 3s 10ms/step\n\n\narray([7, 2, 1, ..., 4, 5, 6], dtype=int64)\n\n\n\ny_test\n\narray([7, 2, 1, ..., 4, 5, 6], dtype=uint8)\n\n\n\n\n[추가] 예측치가 틀린값 추출 후 시각화해보기\n\n예측 틀린 값 확인\n\n\nimport pandas as pd\n\ndf_answersheet = pd.DataFrame(y_test, columns=['Y_test(정답)'])\ndf_answersheet['Y_pred(예측)'] = np.argmax(y_predict_one_hot, axis=1)\ndf_answersheet['비교'] = (df_answersheet['Y_test(정답)'] == df_answersheet['Y_pred(예측)'])\ndf_answersheet\n\n\n\n\n\n\n\n\n\nY_test(정답)\nY_pred(예측)\n비교\n\n\n\n\n0\n7\n7\nTrue\n\n\n1\n2\n2\nTrue\n\n\n2\n1\n1\nTrue\n\n\n3\n0\n0\nTrue\n\n\n4\n4\n4\nTrue\n\n\n...\n...\n...\n...\n\n\n9995\n2\n2\nTrue\n\n\n9996\n3\n3\nTrue\n\n\n9997\n4\n4\nTrue\n\n\n9998\n5\n5\nTrue\n\n\n9999\n6\n6\nTrue\n\n\n\n\n10000 rows × 3 columns\n\n\n\n\n\ndf_answersheet['비교'].value_counts()\n\n비교\nTrue     9947\nFalse      53\nName: count, dtype: int64\n\n\n\n예측 틀린 값들의 시각화 및 정답/예측치 비교\n\n\nidx_false = df_answersheet[df_answersheet['비교'] == False].index\nidx_false\n\nIndex([ 445,  449,  947, 1014, 1232, 1242, 1247, 1709, 1878, 1901, 2035, 2070,\n       2118, 2130, 2135, 2414, 2454, 2597, 2654, 2896, 2939, 2953, 3422, 3520,\n       3808, 3985, 4027, 4176, 4284, 4571, 4639, 4699, 4740, 4761, 5749, 5955,\n       6571, 6576, 6597, 6625, 8408, 9009, 9015, 9019, 9587, 9620, 9638, 9642,\n       9664, 9679, 9692, 9698, 9729],\n      dtype='int64')\n\n\n\nimport koreanize_matplotlib\n\n# 시각화로 Validation 확인\nfor i in idx_false.tolist():\n    plt.figure(figsize=(2,2))\n\n    # 결과 확인\n    plt.xlabel(f\"정답:{y_test[i]} | 예상:{y_predict[i]}\")\n    plt.imshow(np.reshape(x_test[i], [28, 28]), cmap=plt.cm.binary)\n    plt.show()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html",
    "href": "posts/meta-dl-creditcard-20240616/index.html",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "",
    "text": "참여중인 딥러닝 스터디 4주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240616/index.html#개요",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "",
    "text": "참여중인 딥러닝 스터디 4주차 기록입니다."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist-설명",
    "href": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist-설명",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "3주차 과제 설명(MNIST 설명)",
    "text": "3주차 과제 설명(MNIST 설명)\n\nBinary(Hypothesis : Sigmoid, CrossEntropy : Y, 1-Y)  → Multiclass(Hypothesis : Softmax, CrossEntropy : \\(Y_1\\), \\(Y_2\\)…)\nMNIST\n\n데이터사이언스, 딥러닝에서의 기초(코딩의 Hello world와 같음)\n사람들의 손글씨 데이터를 모아둔 유명한 데이터 셋\n\n  # tensorflow MNIST로딩 샘플코드\n  from tensorflow.keras.datasets import mnist\n\n  (x_train, y_train), (x_test, y_test) = mnist.load_data()\n  print(x_train.shape, y_train.shape, y_train[0])\n\n  &gt;&gt;&gt;(60000, 28, 28) (60000,) 5 \n  # 6만건의 28*28형태의 데이터 (x_train.shape), 6만건의 0차원 형태 데이터(y_train.shape), 0번째 y_train 정답값(5)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist의-softmax구현",
    "href": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist의-softmax구현",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "3주차 과제 설명(MNIST의 Softmax구현)",
    "text": "3주차 과제 설명(MNIST의 Softmax구현)\n\nMNIST의 Softmax구현\n\nreshape을 사용하는 이유\n\n모델에 통과시키기 위해 행렬을 flatten(28*28 → 784*1)한 후, 다시 Visualize할 때 사용\n\n  img = x_train[i].reshape(28,28)\n  plt.imshow(img, cmap=plt.cm.binary)\nHyper parameter\n\nParameter : W와 b와 같은 학습을 통해 최적화하는 값\nHyper parameter : 모델의 선택(Linear vs Logistic regression), learning_rate, epoch, class(몇개로 나눌지), feature(input data) 등\n\n  # MNIST dataset parameters\n  num_classes = 10\n  num_features = 28 * 28 # 784\n\n  # Training parameters\n  learning_rate = 0.01\n  steps = 1000\n  batch_size = 256\nnp.array : list형태의 train data를 수학적 연산에 유리한 numpy로 변환하기 위해 사용\n\n권장하는 코딩습관 : 아래와 같이 데이터타입을 명시 (안적어도 float32로 기본지정되긴 함)\n\nnp.array(x_train) → np.array(x_train, np.float32)\n\nx_train, x_test = np.array(x_train, np.float32), np.array(x_test, np.float32)\n\n구조변경(flatten)\n\nreshape([-1, num_features]) : flatten 구현\n\n784 data에 reshape([-1, 28]) : reshape의 -1 부분은 28이 됨\n784 data에 reshape([-1, 784]) : reshape의 -1 부분은 1이 됨\n\n# data 구조를 통일\nx_train = x_train.reshape([-1, num_features])\nx_test = x_test.reshape([-1, num_features])\nprint(x_train.shape, x_test.shape)\n&gt;&gt;&gt; (60000, 784) (10000, 784)\n\n데이터 전처리(Normalize, Zero-centering)\n  x_train, x_test  = x_train / 255. , x_test / 255. # Normalizd\n  x_train, x_test = (x_train-np.mean(x_train)), (x_test-np.mean(x_test)) # Zero-Centering\nVariable 설정\n\nW와 b의 Shape은 결정해주어야 함 (W의 차원파악 중요)\n\nW : input dimesion, output dimesion\nb : number of classes(output dimesion)\n\n  W = tf.Variable(tf.ones([num_features, num_classes]), name = 'weight')\n  b = tf.Variable(tf.zeros([num_classes]), name='bias')\n\nHypothesis와 평가방법(accuracy) 등 설정\n  def softmax(x):\n    z = tf.matmul(x, W) + b\n    sm = tf.nn.softmax(z)\n    return sm\n\n  def cross_entropy(y_pred, y_true):\n    y_true = tf.one_hot(y_true, depth=num_classes)\n    y_pred = tf.clip_by_value(y_pred, 1e-9, 1.)\n    return tf.reduce_mean(-tf.reduce_sum(y_true * tf.math.log(y_pred), axis = 1))\n\n  def accuracy(y_pred, y_true):\n    correct_prediction = tf.equal(tf.argmax(y_pred, axis=1), tf.cast(y_true, tf.int64))\n    return tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\nOptimizer\n  optimizer = tf.optimizers.SGD(learning_rate)\n  def run_optimization(x,y):\n    with tf.GradientTape() as tape:\n      pred = softmax(x)\n      loss = cross_entropy(pred, y)\n\n    gradients = tape.gradient(loss, [W,b])\n\n    optimizer.apply_gradients(zip(gradients, [W,b]))\nBatch size구현\n\n아래 코드는 기초적 구현이며, 중복제거나 차례대로 진행되는 기능 등도 있음\n\n왜? 데이터가 시점 등에 따라 패턴이 있을 수 있다\n\n100개의 데이터를 10등분했을 때, 각 데이터마다 패턴이 있을 수 있음\n편향되지 않게 섞는 것이 batch_size의 기본적 컨셉 ```python n_train = x_train.shape[0] # 60000 n_test = x_test.shape[0] # 10000\n\n\ndef train_batch_maker(batch_size): random_idx = np.random.randint(n_train, size = batch_size) # (batch_size,) vector return x_train[random_idx], y_train[random_idx] # (batch_size, 28*28)\ndef test_batch_maker(batch_size): random_idx = np.random.randint(n_test, size = batch_size) # (batch_size,) vector return x_test[random_idx], y_test[random_idx] # (batch_size, 28*28) ```\n\n학습 및 Test\n\n  for step in range(steps):\n  batch_x, batch_y = train_batch_maker(batch_size)\n\n  # Run the optimization to update W and b values\n  run_optimization(batch_x, batch_y)\n\n  if step % 100 == 0:\n    pred = softmax(batch_x)\n    loss = cross_entropy(pred, batch_y)\n    acc = accuracy(pred, batch_y)\n    print(f\"step: {step} loss: {loss} accuracy: {acc}\")\n\n  pred = softmax(x_test)\n  print(f\"Test Accuracy: {accuracy(pred, y_test)}\")\n  &gt;&gt;&gt; Test Accuracy: 0.8712000250816345\n\n  #Predict 5 images from validaton set.\n  num_images = 5\n  test_images = x_test[:num_images]\n  predictions = softmax(test_images)\n\n  # Visualize image and model predcition\n  plt.figure(figsize = (5,5))\n  for i in range(num_images):\n    plt.subplot(1, num_images, i+1)\n    plt.imshow(np.reshape(test_images[i], [28,28]), cmap=plt.cm.binary)\n    plt.xlabel(np.argmax(predictions.numpy()[i]))\n\n  plt.show()\n\n\n\nimage.png"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist의-neural-network구현",
    "href": "posts/meta-dl-creditcard-20240616/index.html#주차-과제-설명mnist의-neural-network구현",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "3주차 과제 설명(MNIST의 Neural Network구현)",
    "text": "3주차 과제 설명(MNIST의 Neural Network구현)\n\nMNIST의 Neural Network구현(기초)\n\nSequential : Python의 list 선언과 유사함\n\n아래 코드의 경우, 사실상 Hidden layer가 없는 단층 Perceptron\nGPT의 경우 하단 모델표에서 Total params가 엄청 많음\n\n  from tensorflow.keras.models import Sequential\n  from tensorflow.keras.layers import Dense\n\n  model = Sequential()\n  model.add(Dense(2, activation = \"sigmoid\", input_dim=2)) # neuron=2, input_dim=2\n  model.add(Dense(1, activation = \"sigmoid\"))              # output_dim = 1\n  model.summary()\n\n  &gt;&gt;&gt;Model: \"sequential\"\n    _________________________________________________________________\n    Layer (type)                Output Shape              Param #   \n    =================================================================\n    dense (Dense)               (None, 2)                 6         \n\n    dense_1 (Dense)             (None, 1)                 3         \n\n    =================================================================\n    Total params: 9 (36.00 Byte)\n    Trainable params: 9 (36.00 Byte)\n    Non-trainable params: 0 (0.00 Byte)\n    _________________________________________________________________\n\n라이브러리를 활용하여 아래와 같이 코드가 간단해짐 (verbose을 0이 아닌값 지정시 진행상태 확인가능)\n\n  model.compile(optimizer = \"SGD\",\n                loss = 'binary_crossentropy',\n                metrics=['accuracy'])\n\n  history = model.fit(x_data, y_data, epochs=1000, batch_size=32, verbose=0)\n\n모델평가\n\n아래와 같이 acc가 낮은 이유는, XOR문제처럼 현재와 같은 단층레이어로는 해결이 어렵기 때문\n\nloss, train_acc = model.evaluate(x_data, y_data, verbose=0)\nprint(f\"train_acc = {train_acc}\")\nprint(f\"loss = {loss}\")\npredict = model.predict(x_data)\nprint(predict)\n&gt;&gt;&gt;train_acc = 0.5\n  loss = 0.6908708810806274\n\n\nMNIST의 Neural Network구현(ANN, 인공신경망 Artificial Neural Network)\n\nDense(10, activation = “sigmoid”) : 뉴런이 10개이며 활성화함수가 Sigmoid\nDense(1, activation = “softmax”) : 활성화 함수로 Softmax 사용\n중요 포인트\n\ninput data의 shape와 일치시키기\noutput activation은 내가 풀고자 하는 문제에 맞춰 잘 지정해야함\n\nMulti-class인데 Sigmoid를 사용한다면 돌아가지 않을 것임 ```python from tensorflow.keras.layers import Flatten\n\n\nmodel = Sequential() model.add(Flatten(input_shape=(28,28))) model.add(Dense(10, activation = “sigmoid”)) model.add(Dense(10, activation = “sigmoid”)) model.add(Dense(1, activation = “softmax”)) model.summary() ```\n하단 모델표의 dense_2 (Dense)의 Param #의 의미\n\n784*10 + 10(bias) : fully-connected layer\n\nModel: \"sequential_1\"\n_________________________________________________________________\nLayer (type)                Output Shape              Param #   \n=================================================================\nflatten (Flatten)           (None, 784)               0         \n\ndense_2 (Dense)             (None, 10)                7850      \n\ndense_3 (Dense)             (None, 10)                110       \n\ndense_4 (Dense)             (None, 1)                 11        \n\n=================================================================\nTotal params: 7971 (31.14 KB)\nTrainable params: 7971 (31.14 KB)\nNon-trainable params: 0 (0.00 Byte)\n\nNeural Network를 잘 사용하려면\n\n하이퍼 파라미터 튜닝 : Activation fuction 어떤 것, 뉴런/레이어 갯수 등 설정\n\n일반적으로 괜찮다고 알려진 값으로 지정해야 모델성능이 쓸만해짐"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240616/index.html#주차-정리",
    "href": "posts/meta-dl-creditcard-20240616/index.html#주차-정리",
    "title": "[M_Study_4주차] Convolutional Neural Network",
    "section": "4주차 정리",
    "text": "4주차 정리\n\nDeep Neural Network (Convolution NN)\n\n딥러닝은 비선형적 관계를 잘 묘사함\n\n과거에는 숫자데이터(금리, 고용률 등)만 다룰 수 있었음\n이미지 등 비정형데이터를 잘 다룰 수 있게됨\n\nCNN(Convolutional Neural Network)\n\n이미지를 분류, 처리하는 기술\n\n분류(Classification) : 대상이 어디에 속하는지 분류\n식별(Detection) : 사진에서의 어떤 객체를 분류하고, 그 객체가 어디에 속하는지 분류\n이러한 분류와 식별을 응용하여 자율주행 자동차, 얼굴인식App 등 구현 가능 (CNN Architecture영향을 받아 발전)\n\n\nCNN의 구성\n\n특성추출(feature learning)\n\n사진은 많은 정보를 포함해 계산량이 너무 많아지므로, 특성추출을 통해 압축이 필요함\nCNN은 모델이 이런 정보에서 어느 부분이 중요한지 찾게 만듦\n특성추출로 압축된 정보를 Neural Network에 넣어, 원본사진 넣은 것과 동일한 것처럼, 빠르고 가볍게 돌아감 (예를 들어 자율주행에 활용하기 위해서는 짧은 시간에 처리해야함)\nConvolution alyer(정보압축) / Pooling layer(정보버림) 등의 반복\n\nClassification\n\nFlatten / Fully-connected / Softmax 등 3주차까지 배운 내용\n\n\nConvolution layer\n\nSource(X)에 Kernel(W)행렬을 곱해 Result(Y)를 만드는것과 같음\n\n원본이미지(Source)의 손실을 최소화하며 잘 압축하는 좋은Kernel값을 찾고자 함\n아다마르곱 활용 : 매칭되는 칸의 숫자끼리 곱하여 더함 \n\nConvolution layer를 통과해 (28,28)이 (14,14)가 되어도 특징 식별 가능\n\nCNN은, 마스크 쓴 사람의 일부 얼굴 특징만으로 사람을 판단하는 것과 같은 방법을 차용\n\nCNN이 잘 작동하기 위한 가정\n\nSpatial Locality : 사진의 일부만 봐도 식별이 가능하다\nPositional invariance : 이미지에서 사과 등 객체가 어디에 있던 사과임\n\n예외 상황 : 엑스레이의 흰색이 위치에 따라 심장, 간 등 다름\n\n\n\nConvolution layer 추가설명\n\nimage(32,32,3)를 filter(3,3,3)가 움직이며 아다마르곱으로 처리\n\nkernel과 filter는 동일한 의미로 사용 \n(32X32X3)image에 (5X5X3)filter 적용시 output은 (28X28X1)\n\noutput은 activation map임(매핑을 했다는 것)\n\n(32X32X3)image에 (5X5X3)filter 4개를 적용하는 이유? \n\n필터가 필요했던 이유는 정보 압축 → 정보가 작아지며 손실 발생 (코끼리의 일부만을 보는 것과 같음)\n각 부분의 정보(4개의 filter)를 모두 모아서 정확히 알 수 있음 (4개의 filter라는 서로 다른 각도에서 본 코끼리를 합쳐서 보게되는 것)\n\n\n\nNested Conv-layers(Convolution layer에 대한 문제)\n\nLayer를 여러번 통과하여 너무 작아지는 문제(get smaller quickly) + 4k와 같은 큰 데이터의 계산량 문제\n이러한 문제를 방지하기 위해 stride와 padding이라는 parameter를 추가\n\nStride\n\n(Input - Filter) / stride + 1\n\n(7x7)image에 (3X3)filter, stride 1 → (7-3)/1 + 1 = (5X5)\n(7x7)image에 (3X3)filter, stride 2 → (7-3)/2 + 1 = (3X3)\n(7x7)image에 (3X3)filter, stride 3 → (7-3)/3 + 1 = (2.33X2.33)\n\noutput 소수인 것은 불가, padding(가장 자리에 0을 붙여줌)을 사용\n\n\n(Input - Filter + 2 \\(*\\) Padding) / stride + 1\n\nPadding을 2배하는 이유는 양쪽 테두리에 각 1개씩 추가되기 때문\n\n\n예시\n\nInput (32x32x3) / 10 Filter(5X5) / stride 1, pad 2\n\nOutput size(=32X32X10) : (32-5+2*2)/1 + 1 → (32X32) → 10개의 필터\nNumber of Parameter(=760) : (Filter (5X5) * Input의 차원 3 + Bias 1) → (553+1) → 필터 10개 → (553+1) * 10\nNumber of Parameter if fully-connected(=31,467,520) : (323210)(3232*3_1)\n\nFully-connected로 31,467,520개 파라미터가 필요했다면, CNN으로 760개 파라미터로 가능해짐\n\n\n\n관례적으로 filter size는 정사각형이지만 직사각형도 가능하다\nPooling Layer : 쓸모없는 정보를 버림\n\nPooling Layer의 종류\n\nMax pooling : 제일 큰 수만 가져옴\nAverage pooling : 평균 가져옴\nParameters 0개 (숫자를 찾는게 아닌 버림. 학습이 일어나지 않음)\n\nPooling Layer의 특징\n\n파라미터수가 0 (학습이 일어나지 않는다, Kernel[Filter]처럼 좋은 숫자를 찾는 작업이 없기 때문)\n\n\n\n\n\n\nFinal project 설명\n\n28만건의 신용카드 데이터로 만들기\n금융데이터는 privacy이슈가 있어 공개시 익명화되어있음\n\n단위가 다르면 연봉, 자산 여부를 역추적할 수 있어, PCA를 통해 익명화 가능\n\nPCA : 데이터 익명화기법은 아니고 처리기법\nV1, V2와 같은 세상에 존재하지 않는 축으로 변환하기때문에 익명화에 좋다\n원래는 상관관계를 0이 되게만드는 테크닉\n\n\nMissing value 처리\n\n평균,최빈,중앙 값 중 프로젝트에 가장 적합한 값 사용하여 대치\n\n상관관계 파악 (Heatmap 분석)\n\n과제의 금융데이터는 PCA로 인해 상관관계가 이미 사라져있음\n\n데이터의 구조 파악\n\nclass : 0정상 1이상거래 (0.17%만이 이상거래 → 모델평가시 고려)\n\n불필요한 컬럼 삭제\nTarget이 합쳐져있는 원본데이터이므로 X, Y로 나누는 작업 필요\n모델 평가\n\n99프로가 정상거래인데 99프로 정상임을 맞췄다면, 단순히 모델이 좋다고 보기 어려움\n\nPrecision, Recall, F1-Score → 이상거래를 몇건 맞췄는지 볼 수 있음\n\n\n평가지표는 f1-score를 사용 예정\n\n바꾸고싶다면 사유 명시(어떤 부분을 중요하게 생각하여 Recall을 기준으로 삼았다)"
  },
  {
    "objectID": "posts/dtcontest-ore-20240615/index.html",
    "href": "posts/dtcontest-ore-20240615/index.html",
    "title": "[공모전] 공공데이터 공모전-4(모델에 대한 Feature개발 및 평가지표)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(모델에 대한 Feature개발 및 평가지표)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240615/index.html#개요",
    "href": "posts/dtcontest-ore-20240615/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-4(모델에 대한 Feature개발 및 평가지표)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\n분석 대상 광물에 대한 HSCODE 등 기준 고민\n모델 평가지표에 대한 고민 : Recall\n모델에 사용할 지표 개발에 대한 부분 (UN Comtrade 활용)\n\n생산국 수출량\n생산국 판매가격\n수입국 수입량"
  },
  {
    "objectID": "posts/dtcontest-ore-20240615/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240615/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-4(모델에 대한 Feature개발 및 평가지표)",
    "section": "내용정리",
    "text": "내용정리\n\n지난 회의정리\n\n모델링에 사용할 지표 중 시장위험지수 제거에 대한 동의\n\n수급안정화지수에 공통항목이 많아 추이가 비슷하여 제외\n\nFeature 중 하나로 BDI지수 추가\nFeature로 사용할 데이터를 추가로 발굴\n\nUN Comtrade database에서도 활용할 데이터 있는지 검토(타 팀원 제보)\n\n잘 만들어진 기존 모델들을 잘 사용하는 방안 고려\n\n이상요소 탐지에 R AnomalyDetection패키지 사용 (타 팀원이 적용예정)\n\n\n\n\n회의내용에 대한 Self고찰 및 아이디어 Develope\n\n분석할 광물에 대해 어떤 기준을 적용할지 고민\n\nUN Comtrade를 활용할 때 어떤 HSCODE를 적용할지에 대한 고민\n\n한국무역통계진흥원에서 제공하는 HSCODE분류서비스를 활용해, 가장 신고율이 높은 HSCODE 채택\n\n‘이차전지용’ 등 여러 용도가 있음에도 가장 높은 신고율은 ’기타’인 것으로 확인해 이 로직은 Drop\n\n현대경제연구원의 2차전지 보고서 중 품목별 HSCODE 내용이 있어 활용 검토\n\n핵심사업에 사용될 광물에 대한 분석이라는 점에서, 2차전지 컨셉 차용이 나쁘지 않은 것으로 보여 활용제안 예정\n\n산화/수산화리튬(282520), 산화/수산화코발트(282200), 황산코발트(283329)\n탄산리튬(283691), 이산화망간(850610), 산화/수산화니켈(282540), 황산니켈(283324)\n\n\n\n\n모델링에 사용할 평가기준에 대한 분석\n\n위험요소 탐지에 대한 모델이므로 Recall 사용으로 제안 예정\n\n위기로 ’판정’하는게 많아져야 위기를 놓치지 않을 확률이 크므로 Recall이 맞다고 생각했음\n\n\n모델링에 사용할 Feature에 대한 생각 (아래의 3개 지표를 개발하여 활용하도록 의견제안 예정)\n\nUN Comtrade의 요소를 바탕으로 아래의 지표를 생성하는 것을 고려\n\n생산국 수출량 : 각 광물의 생산량 상위 국가를 from기준으로 하여 수출(공급)량 판단\n생산국 판매가격 : 각 광물의 판매가격을 수출량으로 나누어 kg당 단가로 판단\n\n가격은 CIF, FOB중 기타비용을 제외하는 FOB를 우선고려, 데이터를 보고 추가결정\n\n수입국 수입량 : 특정 국가에서 수입량 변동이 급격히 변동(상승)하는 것 탐지"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240622/index.html",
    "href": "posts/meta-dl-creditcard-20240622/index.html",
    "title": "[M_Study_4주차과제] CNN으로 MNIST다루기",
    "section": "",
    "text": "스터디 진행하며 진행한 과제 기록(MNIST, CNN)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240622/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240622/index.html#개요",
    "title": "[M_Study_4주차과제] CNN으로 MNIST다루기",
    "section": "개요",
    "text": "개요\n참여중인 딥러닝 스터디 3주차 기록입니다.\n\nCNN로 MNIST다루기\n강사님이 주신 샘플코드 참고해서, 나에게 맞추거나 추가공부 진행"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240622/index.html#과제-작성-mnist-cnn",
    "href": "posts/meta-dl-creditcard-20240622/index.html#과제-작성-mnist-cnn",
    "title": "[M_Study_4주차과제] CNN으로 MNIST다루기",
    "section": "과제 작성 (MNIST CNN)",
    "text": "과제 작성 (MNIST CNN)\n\nimport tensorflow as tf\nfrom tensorflow.keras import datasets\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D, Input\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport koreanize_matplotlib\n\n\n데이터 로드 및 Shape 확인\n\n(X_train, Y_train), (X_test, Y_test) = datasets.mnist.load_data()\nprint(X_train.shape, Y_train.shape, Y_train[0])\nprint(X_test.shape, Y_test.shape, Y_test[0])\n\n(60000, 28, 28) (60000,) 5\n(10000, 28, 28) (10000,) 7\n\n\n\nprint(f\"Min : {X_train[0].min()}, Max : {X_train[0].max()}\")\nplt.figure(figsize=(1,1))\nplt.imshow(X_train[0])\n\nMin : 0, Max : 255\n\n\n\n\n\n\n\n\n\n\n\n3D tensor로 변경 및 float32변환, Normalize\n\n# 3D Tensor\nX_train.reshape(60000,28,28,1)\nX_test.reshape(10000,28,28,1)\n\n# Float32변환\nX_train, X_test = np.array(X_train, np.float32), np.array(X_test, np.float32)\n\n# Normalize (0~255값을 0~1로)\nX_train, X_test = X_train / 255., X_test / 255.\n\n\n\nFeature Learning + Fully-connected layer\n\n### 특성 추출 (Feature Learning)\n\nmodel = Sequential()\nmodel.add(Input(shape=(28, 28, 1)))\n\n# Output계산식(Convolution layer) : (Input - Filter + 2 * Padding) / stride + 1\n\n# 3*3인 Filter(Kernel) 32개, 2번째줄 옵션은 미입력시 기본값 \n#  (Valid Padding은 Padding 미적용을 의미)\n# → Output(activation map=(26,26,32)) : [(28-3+2*0)/1 + 1] * 32(Filter 수)\n# → Weights : (3*3)size*32filter / biases : 32filter\nmodel.add(Conv2D(32, kernel_size=(3, 3), activation='relu', \n                 strides=(1,1), padding='valid', kernel_initializer='glorot_uniform'))\n\n# 2*2인 최대값만 남기는 Pool, 2번째줄 옵션은 미입력시 기본값\n# → Output(activation map=(13,13,32)) : [26/2]\n# → Weights and biases : Pooling은 학습이 일어나지 않는다\nmodel.add(MaxPooling2D(pool_size=(2, 2),\n                       strides=None, padding='valid'))\n\n# 3*3인 Filter(Kernel) 64개\n# → Output(activation map=(11,11,64)) : [(13-3+2*0)/1 + 1] * 64(Filter 수)\n# → Weights : (3*3)size*64filter*32activation map / biases : 64filter\nmodel.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n\n# 2*2인 최대값만 남기는 Pool\n# → Output(activation map=(5,5,64)) : [11/2]\n# → Weights and biases : Pooling은 학습이 일어나지 않는다\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\n# 3*3인 Filter(Kernel) 64개\n# → Output(activation map=(3,3,64)) : [(5-3+2*0)/1 + 1] * 64(Filter 수)\n# → Weights : (3*3)size*64filter*64activation map / biases : 64filter\nmodel.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n\n\n### Fully connected Layer\n\n# flatten shape(576) : [3*3*64]\nmodel.add(Flatten())\n\n# 이전 Layer와 결합. Node=64\n# parameters(36928) : [576*64(weights)+64(biases)]\nmodel.add(Dense(64, activation='relu'))\n\n# 이전 Layer와 결합. Output = 10\n# parameters(650) : [64*10(weights)+10(biases)]\nmodel.add(Dense(10, activation='softmax'))\nmodel.summary()\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ conv2d (Conv2D)                 │ (None, 26, 26, 32)     │           320 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ max_pooling2d (MaxPooling2D)    │ (None, 13, 13, 32)     │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ conv2d_1 (Conv2D)               │ (None, 11, 11, 64)     │        18,496 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ max_pooling2d_1 (MaxPooling2D)  │ (None, 5, 5, 64)       │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ conv2d_2 (Conv2D)               │ (None, 3, 3, 64)       │        36,928 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ flatten (Flatten)               │ (None, 576)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 64)             │        36,928 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 10)             │           650 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 93,322 (364.54 KB)\n\n\n\n Trainable params: 93,322 (364.54 KB)\n\n\n\n Non-trainable params: 0 (0.00 B)\n\n\n\n\n\n모델 컴파일(Loss function, optimizer, metrics 설정)\n\n# Loss function은\n#  Label = number 인 경우 → sparse_categorical_crossentropy (one-hot이 아니므로 메모리소요가 적다)\n#  Label = one-hot 인 경우 → categorical_crossentropy\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\n\n\n모델 학습\n\nhistory = model.fit(X_train, Y_train, epochs=5)\n\nEpoch 1/5\n1875/1875 ━━━━━━━━━━━━━━━━━━━━ 9s 4ms/step - accuracy: 0.9056 - loss: 0.3245\nEpoch 2/5\n1875/1875 ━━━━━━━━━━━━━━━━━━━━ 8s 4ms/step - accuracy: 0.9861 - loss: 0.0442\nEpoch 3/5\n1875/1875 ━━━━━━━━━━━━━━━━━━━━ 10s 5ms/step - accuracy: 0.9901 - loss: 0.0313\nEpoch 4/5\n1875/1875 ━━━━━━━━━━━━━━━━━━━━ 8s 4ms/step - accuracy: 0.9926 - loss: 0.0245\nEpoch 5/5\n1875/1875 ━━━━━━━━━━━━━━━━━━━━ 7s 4ms/step - accuracy: 0.9953 - loss: 0.0163\n\n\n\n\n학습횟수에 따른 Loss(Cost)시각화\n\n# 저장된 값 확인\nhistory.history\n\n{'accuracy': [0.9584500193595886,\n  0.9862833619117737,\n  0.9898499846458435,\n  0.9920166730880737,\n  0.9940166473388672],\n 'loss': [0.13941822946071625,\n  0.04484217241406441,\n  0.032598868012428284,\n  0.025325138121843338,\n  0.01914270594716072]}\n\n\n\n# Plot 시각화\nplt.plot(history.history['loss'], label='Train')\nplt.xlabel('The number of Learning')\nplt.ylabel('Loss')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n모델평가\n\ntest_result = model.evaluate(X_test, Y_test, verbose=2)\nprint()\nprint(test_result)\nprint(f\"Test Loss = {test_result[0]} / Test Accuracy = {test_result[1]}\")\n\n313/313 - 1s - 3ms/step - accuracy: 0.9909 - loss: 0.0343\n\n[0.03433739021420479, 0.9908999800682068]\nTest Loss = 0.03433739021420479 / Test Accuracy = 0.9908999800682068\n\n\n\n\n예측\n\npredictions = model.predict(X_test)\n\n313/313 ━━━━━━━━━━━━━━━━━━━━ 1s 2ms/step\n\n\n\nimport matplotlib as mpl\nmpl.rcParams['figure.max_open_warning'] = 10000\n\nfor i in range(len(predictions)):\n    if np.argmax(predictions[i]) != Y_test[i]:\n        plt.figure(figsize=(2,2))\n        plt.imshow(X_test[i])\n        plt.title(f\"예측{np.argmax(predictions[i])} / 정답{Y_test[i]}\")"
  },
  {
    "objectID": "posts/dtcontest-ore-20240616/index.html",
    "href": "posts/dtcontest-ore-20240616/index.html",
    "title": "[공모전] 공공데이터 공모전-5(UN Comtrade API)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(UNComtradeAPI)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240616/index.html#개요",
    "href": "posts/dtcontest-ore-20240616/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-5(UN Comtrade API)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\nUN Comtrade 사이트로 데이터 받기가 너무 번거로워서 API쪽 확인 후 Jupyter제작"
  },
  {
    "objectID": "posts/dtcontest-ore-20240616/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240616/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-5(UN Comtrade API)",
    "section": "내용정리",
    "text": "내용정리\n\n도입목적\n\nUS Comtrade Database 사이트에서 직접 데이터를 받는 경우, 오류가 여러번 발생\n\n정확한 사유없이 다시 시도하라는 메시지여서 해결방법 찾기가 어려움\n\nAPI를 제공하는 것을 확인\n\n비용없이 사용가능한 API도 있는 것으로 확인하여 활용\n\n\n\n\n필수사항\n\ncomtradeapicall 파이썬 패키지 설치\nAPI Subscription Key 발급 : UN Comtrade Developer에서 발급 (https://comtradedeveloper.un.org/)\n\n가입 후 사용하고자 하는 API를 Subscription\nProfile 메뉴에서 Subscription내역이 보이고, Show로 Key를 확인할 수 있음\n\n\n\n\n사용방법\n\n첫번째 칸에서 필수정보 입력 후 실행\n\n    subscription_key = 'your api key'\n    directory = 'your download directory'\n\n두번째 칸에서 조회정보 입력 후 실행\n\n    hscode = '288512,281325'\n    flow_code = 'M,X' # M : Import / X : Export\n\n원하는 기능으로 이동하여 진행\n\n저장없이 데이터 일부 확인 → Subscription key 필요없는 일부 데이터 확인용 코드로 이동\n\n조회조건(월)입력 후 바로 아래 칸 실행\n\n특정 연도 데이터 저장 필요 → Subscription key 필요한 다운로드 코드로 이동\n\n조회조건 입력 (연단위)에서 4자리 연도 입력하거나, 조회조건 입력 (월단위)에서 6자리 연월 입력\n입력 후 CSV파일 저장(1개월씩 저장) 부분 실행\n\n특정 월 데이터 저장 필요 → Subscription key 필요한 다운로드 코드 (반복문없이 1건 실행)`로 이동\n\n# 조회조건 입력 (월단위)에서 6자리 연월 입력\n입력 후 CSV파일 저장(1개월씩 저장) 부분 실행\n\n\n받아진 데이터의 Row 확인 (한번에 너무 많은 행 받으면 Block당하므로 점검용)\n\n실행하면 저장된 파일들에 대해 정보 제공\n\n  The file 282540,283324_202404.csv has 136 rows.\n  The total : 970.\n데이터 프레임 합치기\n\n실행하면 저장되어있는 파일을 하나로 합친다\n\n\n\n\ngithub reposiroty주소\nhttps://github.com/KR9268/UnComtradeAPI\n\n\n샘플코드(패키지 및 함수)"
  },
  {
    "objectID": "posts/dtcontest-ore-20240616/index.html#기본실행코드-api-key-및-조회조건-등-입력",
    "href": "posts/dtcontest-ore-20240616/index.html#기본실행코드-api-key-및-조회조건-등-입력",
    "title": "[공모전] 공공데이터 공모전-5(UN Comtrade API)",
    "section": "기본실행코드 (API Key 및 조회조건 등 입력)",
    "text": "기본실행코드 (API Key 및 조회조건 등 입력)\n\nimport pandas as pd\nimport requests\nimport comtradeapicall\nimport time\nimport random\nfrom IPython.display import clear_output\nimport os\n\nsubscription_key = 'your api key' # comtrade api subscription key (from comtradedeveloper.un.org)\n\ndirectory = 'your download directory'  # output directory for downloaded files \nproxy_url = '&lt;PROXY URL&gt;'  # optional if you need proxy url\n\n\n조회조건 입력\n\nhscode = '282540,283324'\nflow_code = 'M,X' # M : Import / X : Export\n\n\n\nSubscription key 필요없는 일부 데이터 확인용 코드\n\n# 조회조건 입력\ntotal_period = '202401,202402,202403,202404'\n\n\nmydf = comtradeapicall.previewFinalData(typeCode='C', freqCode='M', clCode='HS', period=total_period,\n                                        reporterCode=None, cmdCode=hscode, flowCode=flow_code, partnerCode=None,\n                                        partner2Code=None,\n                                        customsCode=None, motCode=None, maxRecords=50000, format_output='JSON',\n                                        aggregateBy=None, breakdownMode='classic', countOnly=None, includeDesc=True)\nmydf\n\n\n\n\n\n\n\n\n\ntypeCode\nfreqCode\nrefPeriodId\nrefYear\nrefMonth\nperiod\nreporterCode\nreporterISO\nreporterDesc\nflowCode\n...\nnetWgt\nisNetWgtEstimated\ngrossWgt\nisGrossWgtEstimated\ncifvalue\nfobvalue\nprimaryValue\nlegacyEstimationFlag\nisReported\nisAggregate\n\n\n\n\n0\nC\nM\n20240101\n2024\n1\n202401\n36\nAUS\nAustralia\nM\n...\n20000.00\nFalse\n20600.0\nFalse\n291960.098\n290906.941\n291960.098\n0\nFalse\nTrue\n\n\n1\nC\nM\n20240101\n2024\n1\n202401\n36\nAUS\nAustralia\nM\n...\n20000.00\nFalse\n20600.0\nFalse\n291960.098\n290906.941\n291960.098\n0\nFalse\nTrue\n\n\n2\nC\nM\n20240101\n2024\n1\n202401\n76\nBRA\nBrazil\nM\n...\n1576.83\nTrue\n0.0\nFalse\n47901.000\n47267.000\n47901.000\n6\nFalse\nTrue\n\n\n3\nC\nM\n20240101\n2024\n1\n202401\n76\nBRA\nBrazil\nM\n...\n1520.00\nFalse\n0.0\nFalse\n45083.000\n44570.000\n45083.000\n0\nFalse\nTrue\n\n\n4\nC\nM\n20240101\n2024\n1\n202401\n76\nBRA\nBrazil\nM\n...\n55.83\nTrue\n0.0\nFalse\n1696.000\n1580.000\n1696.000\n6\nFalse\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n495\nC\nM\n20240101\n2024\n1\n202401\n842\nUSA\nUSA\nM\n...\n23000.00\nFalse\n0.0\nFalse\n384800.000\n381720.000\n384800.000\n0\nTrue\nFalse\n\n\n496\nC\nM\n20240101\n2024\n1\n202401\n792\nTUR\nTürkiye\nM\n...\n133887.00\nFalse\n0.0\nFalse\n599898.000\n448243.000\n599898.000\n0\nFalse\nTrue\n\n\n497\nC\nM\n20240101\n2024\n1\n202401\n792\nTUR\nTürkiye\nM\n...\n19887.00\nFalse\n0.0\nFalse\n89176.000\n65031.000\n89176.000\n0\nFalse\nTrue\n\n\n498\nC\nM\n20240101\n2024\n1\n202401\n792\nTUR\nTürkiye\nM\n...\n30000.00\nFalse\n0.0\nFalse\n140402.000\n101488.000\n140402.000\n0\nFalse\nTrue\n\n\n499\nC\nM\n20240101\n2024\n1\n202401\n792\nTUR\nTürkiye\nM\n...\n48000.00\nFalse\n0.0\nFalse\n217920.000\n157511.000\n217920.000\n0\nFalse\nTrue\n\n\n\n\n500 rows × 47 columns\n\n\n\n\n\n\nSubscription key 필요한 다운로드 코드\n\n너무 자주, 많이 호출하면 밴당할 수 있음\n조회조건 입력은 연단위, 월단위 중 하나만 실행\n\n\n# 조회조건 입력 (연단위) - Year Total Period생성기\nyear_txt = '2017'\ntotal_period = []\nfor i in range(12, 0, -1):\n    total_period.append(f\"{year_txt}{str(i).zfill(2)}\")\n\n['201712',\n '201711',\n '201710',\n '201709',\n '201708',\n '201707',\n '201706',\n '201705',\n '201704',\n '201703',\n '201702',\n '201701']\n\n\n\n# 조회조건 입력 (월단위)\ntotal_period = ['201706', '201705']\n\n\n# CSV파일 저장(1개월씩 저장)\nfor each_period in total_period:\n    mydf = comtradeapicall.getFinalData(subscription_key, typeCode='C', freqCode='M', clCode='HS', period=each_period,\n                                        reporterCode=None, cmdCode=hscode, flowCode=flow_code, partnerCode=None,\n                                        partner2Code=None,\n                                        customsCode=None, motCode=None, maxRecords='250000', format_output='JSON',\n                                        aggregateBy=None, breakdownMode='classic', countOnly=None, includeDesc=True)\n    mydf.to_csv(f'{hscode}_{each_period}.csv', index=False)\n    clear_output()\n    print(f'{hscode}_{each_period}.csv')\n    time.sleep(random.randint(1,2))\n\n282540,283324_201705.csv\n\n\n\n\nSubscription key 필요한 다운로드 코드 (반복문없이 1건 실행)\n\n# 조회조건 입력 (월단위)\nperiod_manual = '202404'\n\n\n# CSV파일 저장(1개월씩 저장)\nmydf = comtradeapicall.getFinalData(subscription_key, typeCode='C', freqCode='M', clCode='HS', period=period_manual,\n                                        reporterCode=None, cmdCode=hscode, flowCode=flow_code, partnerCode=None,\n                                        partner2Code=None,\n                                        customsCode=None, motCode=None, maxRecords='250000', format_output='JSON',\n                                        aggregateBy=None, breakdownMode='classic', countOnly=None, includeDesc=True)\nmydf.to_csv(f'{hscode}_{period_manual}.csv', index=False)\nmydf\n\n\n\n\n\n\n\n\n\ntypeCode\nfreqCode\nrefPeriodId\nrefYear\nrefMonth\nperiod\nreporterCode\nreporterISO\nreporterDesc\nflowCode\n...\nnetWgt\nisNetWgtEstimated\ngrossWgt\nisGrossWgtEstimated\ncifvalue\nfobvalue\nprimaryValue\nlegacyEstimationFlag\nisReported\nisAggregate\n\n\n\n\n0\nC\nM\n20240401\n2024\n4\n202404\n757\nCHE\nSwitzerland\nM\n...\n130.000\nFalse\n0.0\nFalse\n1866.447\nNaN\n1866.447\n0\nFalse\nTrue\n\n\n1\nC\nM\n20240401\n2024\n4\n202404\n757\nCHE\nSwitzerland\nX\n...\n11.638\nTrue\n0.0\nFalse\nNaN\n1203.627\n1203.627\n6\nFalse\nTrue\n\n\n2\nC\nM\n20240401\n2024\n4\n202404\n757\nCHE\nSwitzerland\nX\n...\n11.000\nFalse\n0.0\nFalse\nNaN\n1137.675\n1137.675\n0\nFalse\nTrue\n\n\n3\nC\nM\n20240401\n2024\n4\n202404\n757\nCHE\nSwitzerland\nX\n...\n0.638\nTrue\n0.0\nFalse\nNaN\n65.952\n65.952\n6\nFalse\nTrue\n\n\n4\nC\nM\n20240401\n2024\n4\n202404\n842\nUSA\nUSA\nM\n...\n217523.000\nFalse\n0.0\nFalse\n4915370.000\n4866083.000\n4915370.000\n0\nFalse\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n131\nC\nM\n20240401\n2024\n4\n202404\n300\nGRC\nGreece\nM\n...\n24.000\nFalse\n0.0\nFalse\n26.819\nNaN\n26.819\n0\nFalse\nTrue\n\n\n132\nC\nM\n20240401\n2024\n4\n202404\n300\nGRC\nGreece\nM\n...\n24.000\nFalse\n0.0\nFalse\n26.819\nNaN\n26.819\n0\nFalse\nTrue\n\n\n133\nC\nM\n20240401\n2024\n4\n202404\n36\nAUS\nAustralia\nM\n...\n495415.000\nFalse\n502653.0\nFalse\n303606.306\n276999.633\n303606.306\n0\nFalse\nTrue\n\n\n134\nC\nM\n20240401\n2024\n4\n202404\n36\nAUS\nAustralia\nM\n...\n600.000\nFalse\n1038.0\nFalse\n2845.630\n2153.520\n2845.630\n0\nFalse\nTrue\n\n\n135\nC\nM\n20240401\n2024\n4\n202404\n36\nAUS\nAustralia\nM\n...\n494815.000\nFalse\n501615.0\nFalse\n300760.676\n274846.113\n300760.676\n0\nFalse\nTrue\n\n\n\n\n136 rows × 47 columns\n\n\n\n\n\n\n받아진 데이터의 Row수 확인\n\n한번에 너무 많이 받으면 Block당할 수 있으니 받은 데이터 Row수 확인 필요\n\n\ntotal_rows = 0\n\n# Iterate over all files in the directory\nfor filename in os.listdir(directory):\n    if filename.startswith((hscode)) and filename.endswith('.csv'):  # Check if the file is a CSV file and starts with the specified prefixes\n        filepath = os.path.join(directory, filename)\n        df = pd.read_csv(filepath)\n        num_rows = len(df)\n        total_rows += num_rows\n        print(f'The file {filename} has {num_rows} rows.')\n\n# Print the total number of rows\nprint(f'The total : {total_rows}.')\n\nThe file 282540,283324_201705.csv has 136 rows.\nThe file 282540,283324_201706.csv has 698 rows.\nThe file 282540,283324_202404.csv has 136 rows.\nThe total : 970.\n\n\n\n\n데이터프레임합치기\n\n# Initialize an empty list to store the dataframes\ndfs = []\n\n# Iterate over all files in the directory\nfor filename in os.listdir(directory):\n    if filename.startswith((hscode)) and filename.endswith('.csv'):  # Check if the file is a CSV file and starts with the specified prefixes\n        filepath = os.path.join(directory, filename)\n        df = pd.read_csv(filepath)\n        dfs.append(df)\n\n# Concatenate all the dataframes in the list into a single dataframe\nmerged_df = pd.concat(dfs, ignore_index=True)\nmerged_df.to_csv(f'{hscode}_merged.csv', index=False)"
  },
  {
    "objectID": "posts/dtcontest-ore-20240621/index.html",
    "href": "posts/dtcontest-ore-20240621/index.html",
    "title": "[공모전] 공공데이터 공모전-6(니켈기준 Plot짜보기)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(니켈기준 Plot짜보기)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240621/index.html#개요",
    "href": "posts/dtcontest-ore-20240621/index.html#개요",
    "title": "[공모전] 공공데이터 공모전-6(니켈기준 Plot짜보기)",
    "section": "개요",
    "text": "개요\n\n2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가해보기로 함\n\nhttps://datacontest.kr/apply/applyAdd/3\n\n각자 광물 하나씩 담당해서 러프하게 보고서 Plot짜보기"
  },
  {
    "objectID": "posts/dtcontest-ore-20240621/index.html#내용정리",
    "href": "posts/dtcontest-ore-20240621/index.html#내용정리",
    "title": "[공모전] 공공데이터 공모전-6(니켈기준 Plot짜보기)",
    "section": "내용정리",
    "text": "내용정리\n\n지난 회의정리\n\n국제거래 관련 데이터는 UN Comtrade database 활용하기\n아래 4개 광물에 대해 분석 진행하고, HSCODE기준 적용\n\n리튬 : 산화/수산화리튬(282520), 탄산리튬(283691)\n코발트 : 산화/수산화코발트(282200), 황산코발트(283329)\n망간 : 이산화망간(850610)\n니켈 : 산화/수산화니켈(282540), 황산니켈(283324)\n\n각자 광물을 1~2개 담당해서 공모전 보고서 양식에 맞게 고민해보기\n\n분석 배경\n어떤 Feature와 모델 사용\n기대효과\n\n\n\n\n회의내용에 대한 Self고찰 및 아이디어 Develope\n\n기존에 니켈에 대해 분석한게 있어서 해당 내용으로 정리해보기\n\n제안배경\n\n니켈의 용도\n니켈의 국가별 소비량 급증(공공데이터포털의 데이터 기준)\n\n2011년 대비 2배이상 전체 소비량 증가\n중국, 인도네시아를 중심으로 소비량이 대폭 증가함\n\n니켈의 국가별 생산량 편중(공공데이터포털의 데이터 기준)\n\n데이터에 Mine, Refined로 2종류가 있었음\n니켈은 해외에서 가공된 형태를 수입하여 사용, 국산화 진행중\n\nRefined만 추려서 산출하기로 함\n\n중국 34.3%, 인도네시아 20.3%로 2개 국가가 과반수\n\n\n제안배경 요약 : 니켈의 소비량 증가와 생산량 편중으로, 공급 리스크가 큰 상황에서 위기요소 탐지의 필요성 대두\n고려요소(사용하고자 한 Feature)\n\n생산국 수출량 : 광물의 특정 생산국 비중이 높은 점을 고려하여, 해당 국가의 광물 수출량의 이상탐지\n수입국 수입량 : 광물을 수입하는 타 국가의 수입량 증감을 확인하여 이상탐지\n생산국 판매액 : 주요 생산국의 대외 판매액을 기준으로 광물의 가격변동을 탐지\n\n기준 : FOB가격(물류나 보험료를 제외한 순수 물품가격)을 판매량으로 나누어 kg당 가격 산출\n\n다만 데이터를 보니 Null인 경우가 있어 primaryvalue라는 가격컬럼을 사용키로 함\n\n\nBDI(Baltic Dry Index) : 광물이 수입을 통해 조달된다는 점과, 광물운송은 벌크선을 통해 진행됨을 착안하여 물류문제에 대한 이상탐지 요소로 포함\n\n벌크선의 수요/가격에 대한 측면뿐 아니라 경기선행지표로도 사용되고 있음(원자재의 이동을 통해 생산증가 등의 예측)\n\n\n각 Feature의 전처리 방안\n\nPeriod를 기준으로 국가별 합산(groupby)\n사용하고자 하는 컬럼(가격, 수출입량)이 null인 경우에만 drop\nExponential smoothing 모델에 넣어 예측값 산출예정으로 yyyymmdd포맷으로 날짜 처리\n실제값+예측값을 합친 후 Anomality패키지(R의 AnomalyDetection 이상탐지 패키지)로 이상탐지\n각 Period별로 이상치가 발생한 Feature의 수를 합산하여 구간척도로 위기구간을 제안 (정상/경계/주의/위기 등)\n\n기대효과는 시간부족으로 향후 고민\n\n모델에서 예측한 미래구간에서 위기가 탐지되는 경우, 사전 구매 등 광물의 비축 등을 미리 진행\n위의 사항을 통한 공급망리스크 회피 및 자국 핵심산업 경쟁력 확보\n\n\n\n\n\n보고내용 Jupyter작성 초안\n\n제안배경\n\n작성시 참고사항 : 관련 현황 및 문제점 등 빅데이터 분석을 구상하고 제안한 배경에 대해서 작성 (활용 분야, 활용빈도, 중요성 등)\n\n\n니켈은 배터리 및 연료전지 소재, 다양한 촉매, 태양광 지지대의 도금, 내부식성이 필요한 해양구조물 등에 사용 (재생에너지, 친황경자동차 분야에 필수적)\n니켈의 국가별 소비량은 급증하고 있음 (보고서는 하단의 시각화 그래프만 사용)\n\n\n4차 핵심사업에 소요되는 광물로 2011년 대비 소비량 약 2배 증가\n\n\nimport requests\nimport json\nimport pandas as pd\n\n# 한국광해광업공단_광종별 소비현황에 대한 주소를 하단 `데이터 현황`에서 url부분에 붙여넣기\nurl = 'https://raw.githubusercontent.com/KR9268/db_datagokr/main/komir_consume.csv'\ndf_consume = pd.read_csv(url, encoding='cp949', low_memory=False)\ndf_consume_nickel = df_consume[df_consume['광종']=='니켈']\ndf_consume_nickel.head()\n\n\n\n\n\n\n\n\n\n2011 소비량\n2012 소비량\n2013 소비량\n2014 소비량\n2015 소비량\n2016 소비량\n2017 소비량\n2018 소비량\n2019 소비량\n2020 소비량\n2021 소비량\n2022 소비량\n2023 소비량\n광종\n국가\n단위\n대륙\n품목\n\n\n\n\n224\n9.334\n8.391\n7.965\n7.571\n6.667\n7.021\n8.423\n7.978\n9.052\n10.016\n6.101\n7.152\n8.386\n니켈\nAustria\n천톤\nEUROPE\nrefined\n\n\n225\n29.794\n18.827\n26.000\n29.129\n35.022\n31.415\n29.080\n34.137\n35.190\n33.392\n34.046\n25.826\n34.825\n니켈\nBelgium\n천톤\nEUROPE\nrefined\n\n\n226\n0.157\n0.125\n0.141\n0.137\n0.167\n0.120\n0.114\n0.134\n0.149\n0.179\n0.211\n0.185\n0.149\n니켈\nBulgaria\n천톤\nEUROPE\nrefined\n\n\n227\n3.595\n1.891\n0.410\n3.011\n2.882\n2.997\n2.870\n2.163\n2.223\n2.000\n2.297\n1.513\n1.827\n니켈\nCzech Republic\n천톤\nEUROPE\nrefined\n\n\n228\n0.046\n0.189\n0.063\n0.056\n0.242\n0.372\n0.346\n0.589\n0.544\n0.397\n0.269\n0.560\n0.517\n니켈\nDenmark\n천톤\nEUROPE\nrefined\n\n\n\n\n\n\n\n\n\n# 단위가 여럿인 경우 등 확인 후 통일\nfor each_column in df_consume_nickel.columns:\n    if '소비량' not in each_column:\n        print(f\"{each_column} : {df_consume_nickel[each_column].unique()}\")\n\n광종 : ['니켈']\n국가 : ['Austria' 'Belgium' 'Bulgaria' 'Czech Republic' 'Denmark' 'Finland'\n 'France' 'Germany' 'Greece' 'Hungary' 'Italy' 'Macedonia' 'Norway'\n 'Poland' 'Portugal' 'Romania' 'Russia' 'Serbia' 'Slovenia' 'Spain'\n 'Sweden' 'Switzerland' 'Ukraine' 'United Kingdom' 'South Africa' 'China'\n 'Hong Kong' 'India' 'Indonesia' 'Japan' 'Kazakhstan' 'Malaysia'\n 'North Korea' 'Philippines' 'Saudi Arabia' 'Singapore' 'South Korea'\n 'Taiwan' 'Thailand' 'Turkey' 'United Arab Emirates' 'Vietnam' 'Argentina'\n 'Brazil' 'Canada' 'Chile' 'Cuba' 'Mexico' 'U.S.A.' 'Australia'\n 'New Zealand']\n단위 : ['천톤']\n대륙 : ['EUROPE' 'AFRICA' 'ASIA' 'AMERICA' 'OCEANIA']\n품목 : ['refined']\n\n\n\n# 단일 항목인 광종, 단위, 품목 제거 (메모리확보 7.6+ KB → 6.4+ KB)\ndf_consume_nickel = df_consume_nickel[['2011 소비량', '2012 소비량', '2013 소비량', '2014 소비량', '2015 소비량', '2016 소비량',\n       '2017 소비량', '2018 소비량', '2019 소비량', '2020 소비량', '2021 소비량', '2022 소비량', '2023 소비량', '국가', '대륙','품목']]\ndf_consume_nickel.head()\n\n\n\n\n\n\n\n\n\n2011 소비량\n2012 소비량\n2013 소비량\n2014 소비량\n2015 소비량\n2016 소비량\n2017 소비량\n2018 소비량\n2019 소비량\n2020 소비량\n2021 소비량\n2022 소비량\n2023 소비량\n국가\n대륙\n품목\n\n\n\n\n224\n9.334\n8.391\n7.965\n7.571\n6.667\n7.021\n8.423\n7.978\n9.052\n10.016\n6.101\n7.152\n8.386\nAustria\nEUROPE\nrefined\n\n\n225\n29.794\n18.827\n26.000\n29.129\n35.022\n31.415\n29.080\n34.137\n35.190\n33.392\n34.046\n25.826\n34.825\nBelgium\nEUROPE\nrefined\n\n\n226\n0.157\n0.125\n0.141\n0.137\n0.167\n0.120\n0.114\n0.134\n0.149\n0.179\n0.211\n0.185\n0.149\nBulgaria\nEUROPE\nrefined\n\n\n227\n3.595\n1.891\n0.410\n3.011\n2.882\n2.997\n2.870\n2.163\n2.223\n2.000\n2.297\n1.513\n1.827\nCzech Republic\nEUROPE\nrefined\n\n\n228\n0.046\n0.189\n0.063\n0.056\n0.242\n0.372\n0.346\n0.589\n0.544\n0.397\n0.269\n0.560\n0.517\nDenmark\nEUROPE\nrefined\n\n\n\n\n\n\n\n\n\n전체 소비량 증가\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport koreanize_matplotlib\n\nplt.figure(figsize=(20,4))\nsns.lineplot(df_consume_nickel.sum(numeric_only=True))\nplt.title('니켈 소비량 추이')\n\nText(0.5, 1.0, '니켈 소비량 추이')\n\n\n\n\n\n\n\n\n\n\n국가별 소비량 증가\n\n중국, 인도네시아를 중심으로 2011년 대비 소비량 대폭 증가\n\n\n\nnickel_by_country = df_consume_nickel.groupby('국가').sum(numeric_only=True)\nnickel_by_country.head(5)\n\n\n\n\n\n\n\n\n\n2011 소비량\n2012 소비량\n2013 소비량\n2014 소비량\n2015 소비량\n2016 소비량\n2017 소비량\n2018 소비량\n2019 소비량\n2020 소비량\n2021 소비량\n2022 소비량\n2023 소비량\n\n\n국가\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArgentina\n0.974\n0.806\n0.892\n0.501\n0.528\n0.475\n0.535\n0.523\n0.526\n0.274\n0.544\n0.443\n0.452\n\n\nAustralia\n1.600\n1.600\n1.600\n1.600\n1.608\n1.600\n1.600\n1.600\n1.600\n1.600\n1.600\n1.600\n1.600\n\n\nAustria\n9.334\n8.391\n7.965\n7.571\n6.667\n7.021\n8.423\n7.978\n9.052\n10.016\n6.101\n7.152\n8.386\n\n\nBelgium\n29.794\n18.827\n26.000\n29.129\n35.022\n31.415\n29.080\n34.137\n35.190\n33.392\n34.046\n25.826\n34.825\n\n\nBrazil\n26.910\n22.455\n21.180\n26.616\n18.062\n25.506\n22.269\n22.376\n16.480\n12.062\n17.697\n17.782\n11.645\n\n\n\n\n\n\n\n\n\n# 표준편차가 상위 10개 국가 추출\ndescribed_nickel_by_country = nickel_by_country.transpose().describe()\nstd_described_nickel_by_country = described_nickel_by_country.loc['std'].sort_values(ascending=False)[0:10]\nstd_described_nickel_by_country\n\n국가\nChina           440.092028\nIndonesia       154.306424\nIndia            18.577287\nU.S.A.           16.972706\nTaiwan           16.607094\nSouth Africa     12.951598\nGermany          12.118787\nJapan             9.753820\nSouth Korea       9.739035\nItaly             9.129311\nName: std, dtype: float64\n\n\n\n# 표준편차 상위 10개국 그래프\nindex_country = std_described_nickel_by_country.index.tolist()\n\nplt.figure(figsize=(20,5))\nsns.lineplot(nickel_by_country.transpose()[index_country])\n\n\n\n\n\n\n\n\n\n# 표준편차 상위 10개국 중 중국제외한 그래프\nindex_country.remove('China')\n\nplt.figure(figsize=(20,5))\nsns.lineplot(nickel_by_country.transpose()[index_country])\n\n\n\n\n\n\n\n\n\n# 표준편차 상위 10개국 중 인도네시아 제외한 그래프\nindex_country.remove('Indonesia')\n\nplt.figure(figsize=(20,5))\nsns.lineplot(nickel_by_country.transpose()[index_country])\n\n\n\n\n\n\n\n\n\n니켈의 생산량\n\n\n주요 2개국 생산량이 58.3%로 편중(인도네시아, 중국, Refined니켈 기준)\n\n\n# 한국광해광업공단_광종별 소비현황에 대한 주소를 하단 `데이터 현황`에서 url부분에 붙여넣기\nurl = 'https://raw.githubusercontent.com/KR9268/db_datagokr/main/komir_product_country.csv'\ndf_product = pd.read_csv(url, encoding='cp949', low_memory=False)\ndf_product.head()\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n광종\n국가\n단위\n대륙\n품목\n\n\n\n\n0\n561.354\n800.316\n657.1\n605.215\n787.404\n738.612\n740.380\n760.244\n1043.343\n619.748\n675.269\n669.926\n542.114\n알루미늄\nBosnia\n천톤\nEUROPE\nbauxite\n\n\n1\n0.000\n0.000\n0.0\n0.000\n11.900\n9.800\n12.200\n11.800\n14.300\n14.100\n14.500\n13.800\n13.800\n알루미늄\nCroatia\n천톤\nEUROPE\nbauxite\n\n\n2\n80.800\n90.129\n100.0\n71.100\n70.000\n110.000\n110.000\n110.000\n120.760\n123.496\n142.764\n120.000\n120.000\n알루미늄\nFrance\n천톤\nEUROPE\nbauxite\n\n\n3\n2324.000\n1815.328\n1844.0\n1876.000\n1831.270\n1880.000\n1927.145\n1559.360\n1379.123\n1428.639\n1227.000\n1173.000\n869.100\n알루미늄\nGreece\n천톤\nEUROPE\nbauxite\n\n\n4\n277.800\n255.100\n93.7\n14.400\n8.300\n16.700\n4.000\n5.000\n0.000\n0.000\n0.000\n0.000\n0.000\n알루미늄\nHungary\n천톤\nEUROPE\nbauxite\n\n\n\n\n\n\n\n\n\ndf_nickel_product = df_product[df_product['광종']=='니켈']\ndf_nickel_product.head(5)\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n광종\n국가\n단위\n대륙\n품목\n\n\n\n\n442\n3.528\n0.728\n2.086\n4.889\n6.309\n3.952\n5.301\n4.204\n2.830\n3.764\n3.615\n1.423\n0.548\n니켈\nAlbania\n천톤\nEUROPE\nmine\n\n\n443\n19.081\n19.955\n19.579\n19.830\n10.643\n22.034\n36.201\n43.572\n38.530\n41.429\n42.098\n60.360\n69.568\n니켈\nFinland\n천톤\nEUROPE\nmine\n\n\n444\n21.100\n21.550\n19.350\n21.410\n19.750\n19.394\n19.080\n17.890\n13.715\n7.060\n4.755\n1.680\n0.000\n니켈\nGreece\n천톤\nEUROPE\nmine\n\n\n445\n7.632\n4.436\n7.607\n6.724\n6.650\n4.306\n7.120\n4.791\n3.314\n3.958\n4.735\n0.339\n0.360\n니켈\nKosovo\n천톤\nEUROPE\nmine\n\n\n446\n3.600\n1.704\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n니켈\nMacedonia\n천톤\nEUROPE\nmine\n\n\n\n\n\n\n\n\n\n# 단위가 여럿인 경우 등 확인 후 통일\nfor each_column in df_nickel_product.columns:\n    if '생산량' not in each_column:\n        print(f\"{each_column} : {df_nickel_product[each_column].unique()}\")\n\n광종 : ['니켈']\n국가 : ['Albania' 'Finland' 'Greece' 'Kosovo' 'Macedonia' 'Norway' 'Poland'\n 'Russia' 'Spain' 'Botswana' 'Ivory Coast' 'Madagascar' 'Morocco'\n 'South Africa' 'Zambia' 'Zimbabwe' 'China' 'Indonesia' 'Kazakhstan'\n 'Myanmar' 'Philippines' 'Turkey' 'Vietnam' 'Brazil' 'Canada' 'Colombia'\n 'Cuba' 'Dominican Republic' 'Guatemala' 'U.S.A.' 'Venezuela' 'Australia'\n 'New Caledonia' 'Papua New Guinea' 'Austria' 'France' 'Ukraine'\n 'United Kingdom' 'India' 'Japan' 'South Korea']\n단위 : ['천톤']\n대륙 : ['EUROPE' 'AFRICA' 'ASIA' 'AMERICA' 'OCEANIA']\n품목 : ['mine' 'refined']\n\n\n\n# 단일 항목인 광종, 단위, 품목 제거 (메모리확보 9.4+ KB → 8.4+ KB)\ndf_nickel_product = df_nickel_product[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량', '2023 생산량', '국가', '대륙','품목']]\ndf_nickel_product.head()\n\n\n\n\n\n\n\n\n\n2011 생산량\n2012 생산량\n2013 생산량\n2014 생산량\n2015 생산량\n2016 생산량\n2017 생산량\n2018 생산량\n2019 생산량\n2020 생산량\n2021 생산량\n2022 생산량\n2023 생산량\n국가\n대륙\n품목\n\n\n\n\n442\n3.528\n0.728\n2.086\n4.889\n6.309\n3.952\n5.301\n4.204\n2.830\n3.764\n3.615\n1.423\n0.548\nAlbania\nEUROPE\nmine\n\n\n443\n19.081\n19.955\n19.579\n19.830\n10.643\n22.034\n36.201\n43.572\n38.530\n41.429\n42.098\n60.360\n69.568\nFinland\nEUROPE\nmine\n\n\n444\n21.100\n21.550\n19.350\n21.410\n19.750\n19.394\n19.080\n17.890\n13.715\n7.060\n4.755\n1.680\n0.000\nGreece\nEUROPE\nmine\n\n\n445\n7.632\n4.436\n7.607\n6.724\n6.650\n4.306\n7.120\n4.791\n3.314\n3.958\n4.735\n0.339\n0.360\nKosovo\nEUROPE\nmine\n\n\n446\n3.600\n1.704\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\n0.000\nMacedonia\nEUROPE\nmine\n\n\n\n\n\n\n\n\n\n# 니켈에 대한 국가별 생산량\ndf2_produce_country_mine = df_nickel_product[df_nickel_product['품목']=='mine'].groupby(by=['국가'])[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량', '2023 생산량']].sum()\ndf2_produce_country_refined = df_nickel_product[df_nickel_product['품목']=='refined'].groupby(by=['국가'])[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량', '2023 생산량']].sum()\n\n\n# 니켈에 대한 국가별 생산량의 총 합계(Mine)\ndf2_produce_country_total_mine = df2_produce_country_mine[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량', '2023 생산량']].sum(axis=1).sort_values(ascending=False)\ndf2_produce_country_total_mine[0:10]\n\n국가\nIndonesia        9543.539\nPhilippines      4762.154\nRussia           3057.635\nAustralia        2612.548\nNew Caledonia    2453.547\nCanada           2448.002\nChina            1274.216\nBrazil            988.699\nCuba              680.208\nSouth Africa      561.815\ndtype: float64\n\n\n\n# 니켈에 대한 국가별 생산량의 총 합계(Refined)\ndf2_produce_country_total_refined = df2_produce_country_refined[['2011 생산량', '2012 생산량', '2013 생산량', '2014 생산량', '2015 생산량', '2016 생산량',\n       '2017 생산량', '2018 생산량', '2019 생산량', '2020 생산량', '2021 생산량', '2022 생산량', '2023 생산량']].sum(axis=1).sort_values(ascending=False)\ndf2_produce_country_total_refined[0:10]\n\n국가\nChina            8813.411\nIndonesia        5204.761\nRussia           2458.088\nJapan            2295.233\nCanada           1742.140\nAustralia        1521.416\nNorway           1178.114\nNew Caledonia     936.948\nBrazil            809.897\nFinland           712.412\ndtype: float64\n\n\n\n# 니켈 총생산량 내림차순 기준 상위 10개국 Pie chart (Refined한정)\ntarget_country =df2_produce_country_total_refined[0:10][0:10].index.tolist()\ndf2_produce_country_total_refined.loc[target_country].plot(kind='pie',startangle=145, autopct='%.1f%%', pctdistance=0.8)\nplt.title('국가별 니켈 총생산량 비중(2011~2023,  Refined)')\n\nText(0.5, 1.0, '국가별 니켈 총생산량 비중(2011~2023,  Refined)')\n\n\n\n\n\n\n\n\n\n\n\n분석 내용 및 분석 결과\n\n작성시 참고사항 : 구체적인 내용을 자유롭게 기술하되, 세부적이고 구체적으로 작성\n\n\n고려사항(사용하고자 한 Feature)\n\n아래의 상황을 모델에 포함하여 고려하고자 하였습니다\n\n생산국 수출량 : 광물의 특정 생산국 비중이 높은 점을 고려하여, 해당 국가의 광물 수출량의 이상탐지\n수입국 수입량 : 광물을 수입하는 타 국가의 수입량 증감을 확인하여 이상탐지\n생산국 판매액 : 주요 생산국의 대외 판매액을 기준으로 광물의 가격변동을 탐지\n\n기준 : FOB가격(물류나 보험료를 제외한 순수 물품가격)을 판매량으로 나누어 kg당 가격 산출\n\nBDI(Baltic Dry Index) : 광물이 수입을 통해 조달된다는 점과, 광물운송은 벌크선을 통해 진행됨을 착안하여 물류문제에 대한 이상탐지 요소로 포함\n\n\n\nimport pandas as pd\nimport xlwings as xw\n\ndef filter_df(df:pd.DataFrame, from_country:str, export:bool, returnvalue:str=None, to_country:str=None):\n    '''\n        dataframe에서 특정 옵션 데이터를 필터링 하기 위한 함수\n    '''\n    flowCode = 'X' if export is True else 'M'\n    filter_to_country = (df['partnerDesc']==to_country) if to_country is not None else True\n\n    # DataFrame복사\n    df_copy = df[(df['reporterDesc']==from_country) & filter_to_country & (df['flowCode']==flowCode)].copy()\n\n    # DataFrame전처리 : 날짜값 변환(str로변환, 연/월 분리)\n    df_copy['period'] = df_copy['period'].astype('int').astype('str')\n    df_copy['period_year'] = df_copy['period'].str[:4]\n    df_copy['period_month'] = df_copy['period'].str[-2:]\n    df_copy['period_dateformat'] = pd.to_datetime(df_copy['refPeriodId'], format='%Y%m%d')\n\n    # 반환 컬럼\n    if returnvalue is not None:\n        df_copy = df_copy[returnvalue]\n    else:\n        pass\n\n    return df_copy\n\ndef preprocessing_kpi_uscomtrade(df:pd.DataFrame, type:str):\n    df[['netWgt','primaryValue']] = df[['netWgt','primaryValue']].dropna()\n\n    # 출발국가에 따라 기준값 세팅\n    if df['reporterDesc'].unique() in ['China','Indonesia']:\n        criteria_wt = 'netWgt'\n        criteria_value = 'primaryValue'\n    else:\n        criteria_wt = 'netWgt'\n        criteria_value = 'primaryValue'\n\n    # 기간(period출력)\n    #period = 'period'\n    period = 'period_dateformat'\n\n    # 산출\n    if type == 'Price':\n        df_return = df.groupby(period).sum(numeric_only=True)[criteria_value] / df.groupby(period).sum(numeric_only=True)[criteria_wt]\n    elif type == 'ExportQty':\n        df_return = df.groupby(period).sum(numeric_only=True)[criteria_wt]\n    elif type == 'ImportQty':\n        temp_dict = {}\n        for each_country in df['partnerDesc'].unique():\n            if each_country != 'World':\n                temp_df = df[df['partnerDesc']==each_country]\n                temp_dict[each_country] = temp_df.groupby(period).sum(numeric_only=True)['netWgt']\n        return temp_dict\n    \n    return df_return\n\n\n\n지표별 데이터 전처리(Null제거 및 기준별 Groupby 및 계산처리)\n\n중국과 인도네시아의 수출가격(니켈)\n중국과 인도네시아의 수출량(니켈)\n국가별 수입량(니켈)\n\n\nwb = xw.Book('Z:\\\\GoogleDrive\\\\공공데이터 활용 아이디어 공모전\\\\282540,283324_merged.csv')\nsht = wb.sheets[0]\nrange_df = sht.range('A2:BL'+str(sht.used_range.last_cell.row))\ndf_un_nickel_all = sht.used_range.options(pd.DataFrame,index=0).value\nwb.close()\n\ndf_un_nickel_all\n\n\n\n\n\n\n\n\n\ntypeCode\nfreqCode\nrefPeriodId\nrefYear\nrefMonth\nperiod\nreporterCode\nreporterISO\nreporterDesc\nflowCode\n...\nnetWgt\nisNetWgtEstimated\ngrossWgt\nisGrossWgtEstimated\ncifvalue\nfobvalue\nprimaryValue\nlegacyEstimationFlag\nisReported\nisAggregate\n\n\n\n\n0\nC\nM\n20110101.0\n2011.0\n1.0\n201101.0\n32.0\nARG\nArgentina\nM\n...\n1500.000\nFalse\n0.0\nFalse\n4.060111e+04\n0.000\n4.060111e+04\n0.0\nFalse\nTrue\n\n\n1\nC\nM\n20110101.0\n2011.0\n1.0\n201101.0\n36.0\nAUS\nAustralia\nM\n...\n120.000\nFalse\n0.0\nFalse\n1.844344e+04\n0.000\n1.844344e+04\n0.0\nFalse\nTrue\n\n\n2\nC\nM\n20110101.0\n2011.0\n1.0\n201101.0\n36.0\nAUS\nAustralia\nX\n...\n12000.000\nFalse\n0.0\nFalse\n0.000000e+00\n11942.675\n1.194267e+04\n0.0\nFalse\nTrue\n\n\n3\nC\nM\n20110101.0\n2011.0\n1.0\n201101.0\n40.0\nAUT\nAustria\nM\n...\n0.000\nFalse\n0.0\nFalse\n5.477600e+02\n0.000\n5.477600e+02\n0.0\nFalse\nTrue\n\n\n4\nC\nM\n20110101.0\n2011.0\n1.0\n201101.0\n56.0\nBEL\nBelgium\nM\n...\n6609.260\nFalse\n0.0\nFalse\n1.813610e+05\n0.000\n1.813610e+05\n0.0\nFalse\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n105246\nC\nM\n20240401.0\n2024.0\n4.0\n202404.0\n392.0\nJPN\nJapan\nX\n...\n90547.000\nFalse\n0.0\nFalse\nNaN\n294094.768\n2.940948e+05\n0.0\nTrue\nFalse\n\n\n105247\nC\nM\n20240401.0\n2024.0\n4.0\n202404.0\n376.0\nISR\nIsrael\nM\n...\n3178.379\nTrue\n0.0\nFalse\n1.800000e+04\nNaN\n1.800000e+04\n6.0\nFalse\nTrue\n\n\n105248\nC\nM\n20240401.0\n2024.0\n4.0\n202404.0\n376.0\nISR\nIsrael\nM\n...\n529.730\nTrue\n0.0\nFalse\n3.000000e+03\nNaN\n3.000000e+03\n6.0\nTrue\nFalse\n\n\n105249\nC\nM\n20240401.0\n2024.0\n4.0\n202404.0\n376.0\nISR\nIsrael\nM\n...\n2648.649\nTrue\n0.0\nFalse\n1.500000e+04\nNaN\n1.500000e+04\n6.0\nTrue\nFalse\n\n\n105250\nC\nM\n20240401.0\n2024.0\n4.0\n202404.0\n392.0\nJPN\nJapan\nM\n...\n2502000.000\nFalse\n0.0\nFalse\n1.017666e+07\nNaN\n1.017666e+07\n0.0\nFalse\nTrue\n\n\n\n\n105251 rows × 47 columns\n\n\n\n\n\n# 인도네시아의 수출가격, 수출량, 수입량\nprice_indonesia_raw = filter_df(df=df_un_nickel_all, from_country='Indonesia', to_country=None, export=True, returnvalue=None)\n\nprice_indonesia = preprocessing_kpi_uscomtrade(price_indonesia_raw, 'Price')\nexport_qty_indonesia = preprocessing_kpi_uscomtrade(price_indonesia_raw, 'ExportQty')\nimport_qty_from_indonesia = preprocessing_kpi_uscomtrade(price_indonesia_raw, 'ImportQty')\n\n\n# 중국의 수출가격, 수출량, 수입량\nprice_china_raw = filter_df(df=df_un_nickel_all, from_country='China', to_country=None, export=True, returnvalue=None)\n\nprice_china = preprocessing_kpi_uscomtrade(price_china_raw, 'Price')\nexport_qty_china =  preprocessing_kpi_uscomtrade(price_china_raw, 'ExportQty')\nimport_qty_from_china = preprocessing_kpi_uscomtrade(price_china_raw, 'ImportQty')\n\n\n\n각 지표에 대해 예측수행\n\nExponential smoothing으로 예측\n\n타 팀원의 LSTM활용한 모델 등을 활용할 것으로 예상\n\n데이터를 시각화하여 계절성 등을 먼저 확인하고자 함\n데이터 확인용 시각화\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport koreanize_matplotlib\n\n\n%matplotlib inline\ndatasource = pd.DataFrame(price_china)\n\nplt.figure(figsize=(20,4))\nplt.xticks(rotation=45)\n#plt.gca().set_xticks(datasource.index)\nsns.lineplot(datasource)\n\n\n\n\n\n\n\n\n\nExponential Smoothing모델로 예측\n\n\n# ExponentialSmoothing 모델 활용\nfrom statsmodels.tsa.holtwinters import ExponentialSmoothing\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\ndf = price_china\n\ndef predict_exponential(df:pd.DataFrame, month_to_expect:int):\n# 모델 학습\n    model = ExponentialSmoothing(df.values, trend='add', seasonal='add', seasonal_periods=12)\n    fit = model.fit()\n\n    # 예측 수행 (12개월)\n    forecast = fit.forecast(steps=month_to_expect)\n\n    # 날짜배열 생성\n    months= []\n    start_month = max(df.index)+ relativedelta(months=1)\n    end_month = max(df.index) + relativedelta(months=month_to_expect)\n    current_month = start_month\n    while current_month &lt;= end_month:\n        months.append(current_month)\n        current_month += relativedelta(months=1)\n\n    # 날짜+예측값 Series 생성\n    forecast = pd.Series(data=forecast, index=months)\n    return forecast\n\nforecast = predict_exponential(df=price_china, month_to_expect=12)\nforecast\n\n2024-01-01    14.324603\n2024-02-01    15.397100\n2024-03-01    14.578083\n2024-04-01    14.589412\n2024-05-01    15.382925\n2024-06-01    15.244014\n2024-07-01    15.578931\n2024-08-01    15.535253\n2024-09-01    15.241216\n2024-10-01    15.326029\n2024-11-01    15.416176\n2024-12-01    15.462405\ndtype: float64\n\n\n\n# 예측 결과 시각화\nplt.figure(figsize=(12, 6))\nplt.plot(df.index, df.values, label='실제 데이터')\nplt.plot(forecast.index, forecast, label='예측 데이터', linestyle='--')\nplt.xlabel('날짜')\nplt.ylabel('수급안정화지수')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n예측값을 데이터에 추가\n\nprice_china_plus_forecast = pd.concat([price_china, forecast])\nprice_indonesia_plus_forecast = pd.concat([price_indonesia, forecast])\n\n\n\n각 지표에 대해 이상탐지 (R Abnomality 패키지 활용)\n\n중국과 인도네시아의 수출가격(니켈) : 기간별 가격(예측치 포함)에 대한 이상탐지\n중국과 인도네시아의 수출량(니켈) : 기간별 수출량(예측치 포함)에 대한 이상탐지\n국가별 수입량(니켈) : 국가별 수입량(예측치 포함)에 대한 이상탐지\n수급안정화지수 : 예측치에 대한 이상탐지\nBDI : 예측치에 대한 이상탐지\nRStudio 등 설치했으나 구동문제가 있어, 팀원 상의 후에도 이 모델을 사용하는 경우 조치 예정\n\n\n\n이상탐지 결과 취합 및 위기요소 판단\n\n각 지표에 대해 아래와 같은 평가점수를 부여\n\n이상없음 0 / 이상탐지 1\n\n이상 탐지된 지표 수에 따라 구간별 위기상황 부여 (0정상 1경계 2주의 3위기 등)\n\n\n\n\n활용데이터\n\n분석 대상이 되는 데이터와 이에 대한 항목을 모두 작성\n\n공공데이터포털 수급안정화 지수\n\n외부 데이터를 활용하였다면 그에 대한 세부적인 내용 기재 및 활용 이유 제시\n\nInvesting.com BDI지수\nUN Comtrade 수출입현황"
  },
  {
    "objectID": "posts/dtcontest-ore-20240621/index.html#활용데이터",
    "href": "posts/dtcontest-ore-20240621/index.html#활용데이터",
    "title": "[공모전] 공공데이터 공모전-6(니켈기준 Plot짜보기)",
    "section": "활용데이터",
    "text": "활용데이터\n\n분석 대상이 되는 데이터와 이에 대한 항목을 모두 작성\n\n공공데이터포털 수급안정화 지수\n\n외부 데이터를 활용하였다면 그에 대한 세부적인 내용 기재 및 활용 이유 제시\n\nInvesting.com BDI지수\nUN Comtrade 수출입현황"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html",
    "href": "posts/dtcontest-ore-20240624/index.html",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "",
    "text": "2024년 12회 산업통상자원부 공공데이터 활용 아이디어 공모전 참가 기록.(광물 전체 제안배경 작성)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#회의내용에-대한-self고찰-및-아이디어-develope",
    "href": "posts/dtcontest-ore-20240624/index.html#회의내용에-대한-self고찰-및-아이디어-develope",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "회의내용에 대한 Self고찰 및 아이디어 Develope",
    "text": "회의내용에 대한 Self고찰 및 아이디어 Develope"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#지난-회의정리",
    "href": "posts/dtcontest-ore-20240624/index.html#지난-회의정리",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "지난 회의정리",
    "text": "지난 회의정리\n\n내가 진행할 과업\n\nUN Comtreade API개발한 것을 기반으로 광물별 데이터 저장 및 바로 사용할수 있도록 db화\n\n기존에 만들어둔 공공데이터포털 데이터 공유용 git을 활용하여 모든 데이터 관리 예정\n\n링크 : https://github.com/KR9268/db_datagokr\n\n\n분석을 구상하고 제안한 배경에 대해 작성\n\n기존의 니켈뿐 아니라 분석 대상 광석 전체에 대해 분석 진행\n해당 내용 기반으로 분석의 당위성 부여 예정\n\n활용데이터에 대한 정리\n\n활용한 외부데이터와 내용, 활용이유 정리\n\n\n타 팀원들 진행할 과업\n\nLSTM 등 예측 모델에 대한 설명\nProphet 등 이상탐지 모델에 대한 설명\n만들어둔 db활용하여 데이터 추가가공 및 전처리\n모델링 및 모델학습\n\n다같이 진행할 과업\n\n분석으로 인한 기대(파급)효과"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#제안배경",
    "href": "posts/dtcontest-ore-20240624/index.html#제안배경",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "제안배경",
    "text": "제안배경\n\n현황 및 제안목적\n\n탄소중립 등 환경에 대한 관심과, 전기차 배터리 등 미래 유망산업의 핵심광물 수요 증가\n\n리튬, 니켈, 코발트, 망간은 전기차 이차전지의 원료로, 배터리 양극재 등에 필요한 핵심금속\n세계은행 예상에 따르면 배터리 시장은 2050년까지 크게 성장할 전망 (2050년에는 2018년 기준 450%이상 수요증가할 것으로 예상)  출처 : Minerals for Climate Action: The Mineral Intensity of the Clean Energy Transition(2020), The World Bank\n\n\n\n핵심광물 매장이 특정 국가에 심하게 편중되어 있어 상당한 공급망 리스크 존재\n\n광물/국가별 매장량 추이\n\n니켈 : 인도네시아(42%), 호주(18.3%), 브라질(12.2%) 등 \n코발트 : 콩고(57%), 호주(16.1%) 등 \n리튬 : 칠레(33.6%), 호주(22.4%), 아르헨티나(13%) 등 \n망간 : 남아프리카(31.4%), 호주(26.2%), 중국(14.7%) 등  출처 : USGS Mineral Commodity Summaries 2024 데이터로 가공 https://www.sciencebase.gov/catalog/item/65a6e45fd34e5af967a46749\n\n\n\n\n핵심광물 조달에 대한 수입경쟁 심화\n\n각 광물에 대한 국가별 수입량은 2014년 대비 상승세를 보이고 있음\n\n다만, 리튬은 전기차 캐즘이나 배터리시장 경쟁심화 등 여러 요소로 감소된 것으로 추정\n\n배터리시장의 한국업체 점유율 전년비 5.3%하락\n전기차 캐즘 : Chasm, 대중화 전 수요가 감소하는 것\n\n\n\n\n\n\nimage.png\n\n\n출처 : USGS Mineral Commodity Summaries 2024 데이터로 가공 https://www.sciencebase.gov/catalog/item/65a6e45fd34e5af967a46749\n\n각 광물에 대한 국가별 수입량은 2014년 대비 상승세를 보이고 있음\n\n한국 : 희소금속 산업 발전대책 2.0 추진 (확보-비축-순환 수급에 대한 3중 안정망 등)\n미국 : 중요 광물 공급을 위한 연방정부 전략 추진 (수입의존 저감 및 공급망 확보 등)\n일본 : 신 국제자원 전략 추진 (비축제도 재검토, 광종별 확보책 구축, 확보를 위한 국제협력 도출 등)\nEU : EIP Raw materials 추진 (자원의 채광,재활용 등에 대한 시험적 대응, 희소자원에 대한 대체 이용처 도출 등)\n\n\n출처 : 한눈에 보는 6대 핵심광물 이슈분석, 한국지질자원연구원\n\n광물별 상위 수입국 현황(하단 참조)\n\n광물별 상위 수입국 현황 - 니켈 (단위 : kt[킬로톤])\n\nIndex 0~4 : 1~5순위 / Index 5 : 합계\n\n\n\n\n\nShow the code\ntarget_ore = '니켈'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nBrazil\n29,012\nBrazil\n34,127\nBrazil\n19,720\nJapan\n112,033\nJapan\n135,167\nJapan\n191,793\nJapan\n200,127\nJapan\n206,021\nJapan\n173,627\nChina\n256,142\n\n\n1\nGermany\n11,705\nRep. of Korea\n27,394\nChina\n15,197\nRep. of Korea\n53,085\nRep. of Korea\n52,446\nBelgium\n34,111\nBelgium\n31,329\nChina\n98,853\nChina\n119,071\nJapan\n124,779\n\n\n2\nTurkiye\n2,203\nCanada\n16,517\nGermany\n14,054\nChina\n21,639\nAustralia\n21,776\nRep. of Korea\n31,817\nCanada\n21,353\nBelgium\n41,121\nBelgium\n43,286\nBelgium\n41,815\n\n\n3\nSwitzerland\n1,344\nGermany\n12,654\nCanada\n13,500\nGermany\n13,939\nBelgium\n20,963\nCanada\n25,360\nChina\n16,340\nCanada\n21,410\nCanada\n18,103\nMalaysia\n26,280\n\n\n4\nSpain\n1,292\nThailand\n4,923\nRep. of Korea\n8,951\nIndia\n11,978\nChina\n20,569\nAustralia\n19,640\nAustralia\n13,834\nMalaysia\n10,150\nRep. of Korea\n14,469\nCanada\n13,364\n\n\n5\n45,555\n95,615\n71,421\n212,674\n250,921\n302,721\n282,983\n377,554\n368,556\n462,380\n\n\n\n\n\n\n\n광물별 상위 수입국 현황 - 코발트 (단위 : kt[킬로톤])\n\n\n\nShow the code\ntarget_ore = '코발트'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nGermany\n360,060\nGermany\n366,375\nUSA\n444,837\nUSA\n496,572\nUSA\n471,603\nUnited Kingdom\n546,036\nGermany\n571,008\nGermany\n660,773\nGermany\n488,970\nGermany\n529,288\n\n\n1\nSweden\n213,809\nSweden\n220,380\nGermany\n347,106\nUnited Kingdom\n345,329\nGermany\n329,296\nGermany\n380,888\nUSA\n472,193\nUSA\n295,225\nItaly\n250,075\nUnited Kingdom\n395,371\n\n\n2\nBrazil\n154,625\nBrazil\n124,744\nSweden\n201,729\nGermany\n299,495\nFinland\n277,965\nUSA\n348,198\nUnited Kingdom\n371,668\nItaly\n232,667\nBrazil\n191,783\nUSA\n219,089\n\n\n3\nNetherlands\n124,798\nCanada\n93,406\nBrazil\n137,948\nItaly\n195,547\nUnited Kingdom\n264,720\nItaly\n217,586\nItaly\n217,804\nUnited Kingdom\n198,261\nAustria\n186,431\nJapan\n189,547\n\n\n4\nBelgium\n90,674\nRep. of Korea\n76,266\nNetherlands\n101,162\nSweden\n182,634\nItaly\n228,860\nFrance\n176,344\nSweden\n159,068\nSweden\n187,343\nSweden\n164,849\nSweden\n180,823\n\n\n5\n943,966\n881,171\n1,232,782\n1,519,578\n1,572,444\n1,669,052\n1,791,741\n1,574,269\n1,282,108\n1,514,119\n\n\n\n\n\n\n\n광물별 상위 수입국 현황 - 리튬 (단위 : kt[킬로톤])\n\n\n\nShow the code\ntarget_ore = '리튬'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nBelgium\n11,844\nRep. of Korea\n35,014\nChina\n47,227\nJapan\n69,609\nRep. of Korea\n91,029\nRep. of Korea\n124,094\nRep. of Korea\n130,051\nRep. of Korea\n189,821\nChina\n278,358\nChina\n324,683\n\n\n1\nSpain\n6,852\nBelgium\n18,782\nUSA\n33,806\nChina\n61,411\nJapan\n86,273\nJapan\n118,216\nChina\n101,259\nChina\n169,226\nRep. of Korea\n238,878\nJapan\n109,344\n\n\n2\nGermany\n3,900\nCanada\n7,502\nBelgium\n24,300\nRep. of Korea\n55,620\nChina\n46,158\nChina\n59,437\nJapan\n97,427\nJapan\n108,999\nJapan\n120,350\nUSA\n34,261\n\n\n3\nTurkiye\n3,313\nGermany\n6,237\nRussian Federation\n11,620\nUSA\n34,820\nUSA\n36,507\nUSA\n26,740\nUSA\n26,229\nUSA\n27,766\nNetherlands\n17,332\nNetherlands\n12,724\n\n\n4\nNetherlands\n1,376\nSpain\n5,638\nCanada\n10,842\nBelgium\n17,840\nBelgium\n21,817\nFrance\n16,984\nBelgium\n16,554\nRussian Federation\n19,591\nUSA\n15,192\nUnited Kingdom\n6,761\n\n\n5\n27,285\n73,173\n127,794\n239,299\n281,784\n345,471\n371,519\n515,402\n670,112\n487,772\n\n\n\n\n\n\n\n광물별 상위 수입국 현황 - 망간 (단위 : kt[킬로톤])\n\n\n\nShow the code\ntarget_ore = '망간'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nGermany\n1,762,753\nChina, Hong Kong SAR\n6,596,207\nChina, Hong Kong SAR\n6,430,363\nChina, Hong Kong SAR\n4,445,408\nUSA\n5,646,705\nUSA\n5,337,518\nUSA\n5,522,054\nUSA\n6,726,526\nGermany\n4,296,848\nUSA\n7,890,263\n\n\n1\nBrazil\n1,139,607\nGermany\n2,047,818\nUSA\n3,899,931\nUSA\n4,356,834\nChina, Hong Kong SAR\n5,317,808\nChina, Hong Kong SAR\n5,014,159\nChina, Hong Kong SAR\n4,943,913\nGermany\n4,675,819\nJapan\n2,842,379\nGermany\n3,032,223\n\n\n2\nBelgium\n847,525\nBelgium\n1,255,255\nGermany\n3,361,475\nGermany\n2,858,660\nGermany\n2,722,953\nGermany\n3,163,188\nGermany\n4,058,559\nChina, Hong Kong SAR\n4,648,238\nChina, Hong Kong SAR\n2,556,882\nJapan\n2,457,672\n\n\n3\nSpain\n498,741\nBrazil\n1,015,417\nRussian Federation\n1,509,007\nJapan\n2,302,316\nChina\n2,504,820\nChina\n2,789,753\nChina\n2,812,012\nTunisia\n2,484,856\nPoland\n1,565,781\nChina, Hong Kong SAR\n2,360,582\n\n\n4\nTurkiye\n457,040\nRep. of Korea\n443,342\nChina\n1,213,518\nRussian Federation\n1,732,776\nJapan\n2,433,654\nJapan\n2,398,831\nJapan\n2,636,763\nJapan\n2,484,354\nChina\n1,529,201\nPoland\n1,547,787\n\n\n5\n4,705,666\n11,358,039\n16,414,293\n15,695,994\n18,625,940\n18,703,449\n19,973,301\n21,019,792\n12,791,091\n17,288,526\n\n\n\n\n\n\n출처 : UN COMTRADE DB의 자료를 가공  참고 : https://www.sedaily.com/NewsView/2D7TKJ4UE9\n\n핵심광물을 확보하기 위해 경쟁국들은 다양한 전략을 추진중\n\n한국 : 희소금속 산업 발전대책 2.0 추진 (확보-비축-순환 수급에 대한 3중 안정망 등)\n미국 : 중요 광물 공급을 위한 연방정부 전략 추진 (수입의존 저감 및 공급망 확보 등)\n일본 : 신 국제자원 전략 추진 (비축제도 재검토, 광종별 확보책 구축, 확보를 위한 국제협력 도출 등)\nEU : EIP Raw materials 추진 (자원의 채광,재활용 등에 대한 시험적 대응, 희소자원에 대한 대체 이용처 도출 등)\n\n\n출처 : 한눈에 보는 6대 핵심광물 이슈분석, 한국지질자원연구원\n\n\n현황요약 및 제안목적\n\n아래와 같은 상황에서 한국도 핵심광물 비축이나 국산화 노력 등이 이루어지고 있음\n\n핵심광물의 수요증가(전기차 등 환경에 대한 관심과 배터리 시장의 성장)\n공급망 위기(생산지 편중)\n수급경쟁 심화(경쟁국의 확보전략 추진, 수입량 증대)\n\n그럼에도 생산지 편중, 경쟁국은 통제 불가능 요소로, 여전히 공급망 리스크가 상당함\n이러한 상황에서 미래 핵심산업의 경쟁력 확보를 이끌어낼 핵심 원재료(광물)의 확보를 위해, 각 상황에 대한 예측과 위기요소를 탐지할, 위기요소 탐지모델을 도입하고자 함\n\n\n\n\n도입 방법\n\n분석대상 정립\n\n핵심광물로 니켈, 코발트, 리튬, 망간을 지정하고, 국제기준인 6자리 HSCODE를 기준으로 함\n\n산화코발트(282200), 황산코발트(283329), 산화/수산화리튬(282520), 탄산리튬(283691)\n산화/수산화니켈(282540), 황산니켈(283324), 이산화망간(850610)\n\n\n\n\n고려요소(Feature) 선정\n\n국가별 자원수입량을 통해 경쟁자의 활동(광물이동의 편중 등)을 관찰\n\n위의 HSCODE로 전세계 수출입현황을 알 수 있는 UN Comtrade DB API로 데이터 확보\n\n중량당 가격(Price per Weight)을 가격변수로 고려\n\n수출입데이터의 Value(Price)와 Netweight로 연월 데이터 산출\n\n핵심광물 생산지가 해외에 편중되어 국제운송이 필수이므로, 물류에 대해 BDI지수로 관찰\n\nBDI : Baltic Dry Index. 원자재 운송에 사용되는 건화물선에 대한 운임비용 지수\n원자재 이동이라는 점에서 경기선행지표로도 인식되고 있음(향후 시장상황에 대한 지표)\n\n\n\n\n예측 및 이상탐지\n\n고려요소에 대해 ARIMA, 홀트윈터스 지수평활법을 시작으로 LSTM 등 AI모델로 예측 진행\n예측 데이터 기반으로 AnomalyDetection(R, 파이썬의 Prophet) 등을 활용한 이상탐지 진행"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#기대효과",
    "href": "posts/dtcontest-ore-20240624/index.html#기대효과",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "기대효과",
    "text": "기대효과\n사업화방안, 제안 결과를 실행하여 얻을 수 있는 사회 파급(기대) 효과에 대해 구체적으로 작성\n\n기대효과\n\n[수익성 강화] 시장전망 예측 및 이상요소 탐지를 바탕으로 양극재 생산업계의 부정적 래깅효과 방지\n\n래깅 효과 : 원재료 투입 시차(구입시점과 생산투입시점간 차이)에서 비롯되는 손익\n\n참고 : https://www.thelec.kr/news/articleView.html?idxno=28424\n\n\n[원자재 공금망 안정화]수급안정을 통한 연계산업(전지재료 → 이차전지 → 전기차)의 공급사슬 안정성 확보"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#usgs-자료분석-광물별-매장량-산출",
    "href": "posts/dtcontest-ore-20240624/index.html#usgs-자료분석-광물별-매장량-산출",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "USGS 자료분석 (광물별 매장량 산출)",
    "text": "USGS 자료분석 (광물별 매장량 산출)\n\n\nShow the code\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom IPython.display import display, HTML\nimport plotly.express as px\n\n\n\n\nShow the code\nores = {'니켈':\n        {'csv_name':'mcs2024-nicke_world.csv',\n        'csv_df':''},\n         '코발트':\n         {'csv_name':'mcs2024-cobal_world.csv',\n        'csv_df':''},\n         '리튬':\n         {'csv_name':'mcs2024-lithi_world.csv',\n        'csv_df':''},\n         '망간':\n         {'csv_name':'mcs2024-manga_world.csv',\n        'csv_df':''}}\n\n\n\n\nShow the code\n# CSV리딩\nfor ore in ores.keys():\n    # CSV리딩\n    ores[ore]['csv_df'] = pd.read_csv(ores[ore]['csv_name'])\n\n    # 데이터 전처리\n    ## Null처리\n    ores[ore]['csv_df'] = ores[ore]['csv_df'].filter(regex='^(?!Unnamed)').dropna(subset=['Country'])\n\n    ## 킬로톤인 경우 톤으로 변환(컬럼 추가)\n    if 'Reserves_kt' in ores[ore]['csv_df'].columns:\n        ores[ore]['csv_df']['Reserves_t'] = ores[ore]['csv_df']['Reserves_kt'] * 1000\n\n    ## 숫자에 섞인 기호 처리 후 변환\n    if ores[ore]['csv_df']['Reserves_t'].dtype=='O':\n        ores[ore]['csv_df']['Reserves_t'] = ores[ore]['csv_df']['Reserves_t'].str.replace('&gt;','')\n        ores[ore]['csv_df']['Reserves_t'] = ores[ore]['csv_df']['Reserves_t'].str.replace(',','')\n        ores[ore]['csv_df']['Reserves_t'] = ores[ore]['csv_df']['Reserves_t'].str.strip().astype(int)\n    \n    ## 국가명 변환(튀르키예 등)\n    ores[ore]['csv_df']['Country'] = ores[ore]['csv_df']['Country'].str.replace('T체rkiye','Turkiye')\n\n    # 매장량 (실제값)\n    ores[ore]['reserve_df_actual'] = ores[ore]['csv_df'].copy()\n    ores[ore]['reserve_df_actual'] = pd.DataFrame(ores[ore]['csv_df'].groupby('Country').sum()['Reserves_t'])\n    ores[ore]['reserve_df_actual']['Reserves_t'].astype(int)\n    ores[ore]['reserve_df_actual'] = ores[ore]['reserve_df_actual'].drop('World total (rounded)')\n\n    ores[ore]['reserve_df_actual'] = ores[ore]['reserve_df_actual'].copy()\n    ores[ore]['reserve_df_actual']['Reserves_t_total'] = int(ores[ore]['reserve_df_actual'].sum().item())\n    ores[ore]['reserve_df_actual']['Reserves_portion'] = ores[ore]['reserve_df_actual']['Reserves_t']/ores[ore]['reserve_df_actual']['Reserves_t_total']\n    ores[ore]['reserve_df_actual'] = ores[ore]['reserve_df_actual'].sort_values(by='Reserves_portion', ascending=False)\n\n\n\n\nShow the code\n# 시각화용 DataFrame\nfor ore in ores.keys():\n    ores[ore]['plotly_df'] = ores[ore]['reserve_df_actual'].copy()\n    ores[ore]['plotly_df'] = ores[ore]['plotly_df'].reset_index()\n    for i, _ in enumerate(ores[ore]['plotly_df'].index):\n        value = f\"{ores[ore]['plotly_df']['Country'][i]}&lt;br&gt;{int(ores[ore]['plotly_df']['Reserves_t'][i]/1000):,} kt &lt;br&gt;{ores[ore]['plotly_df']['Reserves_portion'][i]*100:.1f}%\"\n        ores[ore]['plotly_df'].loc.__setitem__((i, 'Country'), value)  \n\n\n\n\nShow the code\nfor ore in ores.keys():\n    # Data\n    data = ores[ore]['plotly_df']\n\n    # Create treemap\n    fig = px.treemap(data, path=['Country'], values='Reserves_portion', title=ore,\n                        labels=ores[ore]['plotly_df']['Reserves_t'], width=700, height=380)\n    fig.update_traces(textposition='middle center')\n    fig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#un-comtrade-자료분석광물별-top5수입국",
    "href": "posts/dtcontest-ore-20240624/index.html#un-comtrade-자료분석광물별-top5수입국",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "UN Comtrade 자료분석(광물별 Top5수입국)",
    "text": "UN Comtrade 자료분석(광물별 Top5수입국)\n\n\nShow the code\nores_uncomtrade_url = {'니켈':\n        {'csv_url':['https://raw.githubusercontent.com/KR9268/db_datagokr/main/282540,283324_merged(since2011).csv',\n                    'https://raw.githubusercontent.com/KR9268/db_datagokr/main/282540,283324_merged(since2021).csv'],\n        'csv_df':''},\n         '코발트':\n         {'csv_url':['https://raw.githubusercontent.com/KR9268/db_datagokr/main/282200,283329_merged(since2011).csv',\n                    'https://raw.githubusercontent.com/KR9268/db_datagokr/main/282200,283329_merged(since2021).csv'],\n        'csv_df':''},\n         '리튬':\n         {'csv_url':['https://raw.githubusercontent.com/KR9268/db_datagokr/main/282520,283691_merged(since2011).csv',\n                    'https://raw.githubusercontent.com/KR9268/db_datagokr/main/282520,283691_merged(since2021).csv'],\n        'csv_df':''},\n         '망간':\n         {'csv_url':['https://raw.githubusercontent.com/KR9268/db_datagokr/main/850610_merged(since2011).csv',\n                    'https://raw.githubusercontent.com/KR9268/db_datagokr/main/850610_merged(since2021).csv'],\n        'csv_df':''}}\n\n\n\n\nShow the code\n# CSV리딩\nfor ore in ores_uncomtrade_url.keys():\n    temp_list_for_df_concat = []\n    for each_url in ores_uncomtrade_url[ore]['csv_url']:\n        temp_list_for_df_concat.append(pd.read_csv(each_url, encoding='cp949', low_memory=False))\n    ores_uncomtrade_url[ore]['csv_df'] = pd.concat(temp_list_for_df_concat)\n\n\n\n\nShow the code\n# 기간데이터 전처리 & 데이터 가공 및 순위산출\n\ndef preprocess_df(df_copy):\n    # 날짜변환\n    df_copy['period'] = df_copy['period'].astype('int').astype('str')\n    df_copy['period_year'] = df_copy['period'].str[:4]\n    df_copy['period_month'] = df_copy['period'].str[-2:]\n    df_copy['period_dateformat'] = pd.to_datetime(df_copy['refPeriodId'], format='%Y%m%d')\n\n    # 단위당 가격\n    df_copy['value_per_qty'] = df_copy['primaryValue']/df_copy['qty']\n    df_copy['value_per_qty'] = df_copy['value_per_qty'].replace([np.inf, -np.inf], 0)\n\n    # 국가명 변환(튀르키예 등)\n    df_copy['reporterDesc'] = df_copy['reporterDesc'].str.replace('T체rkiye','Turkiye')\n    df_copy['partnerDesc'] = df_copy['partnerDesc'].str.replace('T체rkiye','Turkiye')\n    return df_copy\n\nfor ore in ores_uncomtrade_url.keys():\n    ## 기간데이터 전처리\n    ores_uncomtrade_url[ore]['csv_df'] = preprocess_df(ores_uncomtrade_url[ore]['csv_df'])\n    ## 데이터 가공 및 순위산출(groupby)\n    ores_uncomtrade_url[ore]['df_groupby_value'] =ores_uncomtrade_url[ore]['csv_df'][ores_uncomtrade_url[ore]['csv_df']['flowCode']=='M'].groupby(['refYear','reporterDesc']).sum(numeric_only=True)['primaryValue']\n    ores_uncomtrade_url[ore]['df_groupby_value'] =ores_uncomtrade_url[ore]['csv_df'][ores_uncomtrade_url[ore]['csv_df']['flowCode']=='M'].groupby(['refYear','reporterDesc']).sum(numeric_only=True)['qty']\n    #ores_uncomtrade_url[ore]['df_groupby_value'] =ores_uncomtrade_url[ore]['csv_df'][ores_uncomtrade_url[ore]['csv_df']['flowCode']=='M'].groupby(['refYear','reporterDesc']).sum(numeric_only=True)['value_per_qty']\n\n\n\n\nShow the code\n# 상위 5개국 산출\n\ndef return_top5(df_groupby, list_removing_year):\n    dict_top_all_year = {}\n    dict_top_all_year_value = {}\n    dict_top_all_year_total = {}\n    dict_top_all_year_value_sum = {}\n\n    year_index = list(set(df_groupby.index.get_level_values(0)))\n    for _ in list_removing_year:\n        year_index.remove(_)\n    year_index.sort()\n\n    for each_year in year_index:\n        top5 = df_groupby[each_year].sort_values(ascending=False)\n        if 'World' in top5.index:\n            top5 = top5.drop('World')\n        top5_index = top5.index.tolist()[:5]\n\n        top5_value = []\n        top5_index_and_value=[]\n        for index_country in top5_index:\n            # top5_value.append(top5[index_country])\n            # top5_index_and_value.append(f\"{index_country}\\n{top5[index_country]:,.0f}\")\n\n            top5_value.append(top5[index_country]/1000)\n            top5_index_and_value.append(f\"{index_country}\\n{top5[index_country]/1000:,.0f}\")\n        \n        dict_top_all_year[each_year] = top5_index\n        dict_top_all_year_value[each_year] = top5_value\n\n        dict_top_all_year_total[each_year] = top5_index_and_value\n        dict_top_all_year_value_sum[each_year] = f\"{sum(top5_value):,.0f}\"\n\n    return pd.concat([pd.DataFrame(dict_top_all_year_total), \n                      pd.DataFrame(dict_top_all_year_value_sum, \n                                   index=[5])]) \n\nfor ore in ores_uncomtrade_url.keys():\n    ores_uncomtrade_url[ore]['df_top5'] = return_top5(ores_uncomtrade_url[ore]['df_groupby_value'], [2011,2012,2013,2024])\n\n\n\n\nShow the code\ntarget_ore = '코발트'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nGermany\n360,060\nGermany\n366,375\nUSA\n444,837\nUSA\n496,572\nUSA\n471,603\nUnited Kingdom\n546,036\nGermany\n571,008\nGermany\n660,773\nGermany\n488,970\nGermany\n529,288\n\n\n1\nSweden\n213,809\nSweden\n220,380\nGermany\n347,106\nUnited Kingdom\n345,329\nGermany\n329,296\nGermany\n380,888\nUSA\n472,193\nUSA\n295,225\nItaly\n250,075\nUnited Kingdom\n395,371\n\n\n2\nBrazil\n154,625\nBrazil\n124,744\nSweden\n201,729\nGermany\n299,495\nFinland\n277,965\nUSA\n348,198\nUnited Kingdom\n371,668\nItaly\n232,667\nBrazil\n191,783\nUSA\n219,089\n\n\n3\nNetherlands\n124,798\nCanada\n93,406\nBrazil\n137,948\nItaly\n195,547\nUnited Kingdom\n264,720\nItaly\n217,586\nItaly\n217,804\nUnited Kingdom\n198,261\nAustria\n186,431\nJapan\n189,547\n\n\n4\nBelgium\n90,674\nRep. of Korea\n76,266\nNetherlands\n101,162\nSweden\n182,634\nItaly\n228,860\nFrance\n176,344\nSweden\n159,068\nSweden\n187,343\nSweden\n164,849\nSweden\n180,823\n\n\n5\n943,966\n881,171\n1,232,782\n1,519,578\n1,572,444\n1,669,052\n1,791,741\n1,574,269\n1,282,108\n1,514,119\n\n\n\n\n\n\n\n\nShow the code\ntarget_ore = '리튬'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nBelgium\n11,844\nRep. of Korea\n35,014\nChina\n47,227\nJapan\n69,609\nRep. of Korea\n91,029\nRep. of Korea\n124,094\nRep. of Korea\n130,051\nRep. of Korea\n189,821\nChina\n278,358\nChina\n324,683\n\n\n1\nSpain\n6,852\nBelgium\n18,782\nUSA\n33,806\nChina\n61,411\nJapan\n86,273\nJapan\n118,216\nChina\n101,259\nChina\n169,226\nRep. of Korea\n238,878\nJapan\n109,344\n\n\n2\nGermany\n3,900\nCanada\n7,502\nBelgium\n24,300\nRep. of Korea\n55,620\nChina\n46,158\nChina\n59,437\nJapan\n97,427\nJapan\n108,999\nJapan\n120,350\nUSA\n34,261\n\n\n3\nTurkiye\n3,313\nGermany\n6,237\nRussian Federation\n11,620\nUSA\n34,820\nUSA\n36,507\nUSA\n26,740\nUSA\n26,229\nUSA\n27,766\nNetherlands\n17,332\nNetherlands\n12,724\n\n\n4\nNetherlands\n1,376\nSpain\n5,638\nCanada\n10,842\nBelgium\n17,840\nBelgium\n21,817\nFrance\n16,984\nBelgium\n16,554\nRussian Federation\n19,591\nUSA\n15,192\nUnited Kingdom\n6,761\n\n\n5\n27,285\n73,173\n127,794\n239,299\n281,784\n345,471\n371,519\n515,402\n670,112\n487,772\n\n\n\n\n\n\n\n\nShow the code\ntarget_ore = '망간'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nGermany\n1,762,753\nChina, Hong Kong SAR\n6,596,207\nChina, Hong Kong SAR\n6,430,363\nChina, Hong Kong SAR\n4,445,408\nUSA\n5,646,705\nUSA\n5,337,518\nUSA\n5,522,054\nUSA\n6,726,526\nGermany\n4,296,848\nUSA\n7,890,263\n\n\n1\nBrazil\n1,139,607\nGermany\n2,047,818\nUSA\n3,899,931\nUSA\n4,356,834\nChina, Hong Kong SAR\n5,317,808\nChina, Hong Kong SAR\n5,014,159\nChina, Hong Kong SAR\n4,943,913\nGermany\n4,675,819\nJapan\n2,842,379\nGermany\n3,032,223\n\n\n2\nBelgium\n847,525\nBelgium\n1,255,255\nGermany\n3,361,475\nGermany\n2,858,660\nGermany\n2,722,953\nGermany\n3,163,188\nGermany\n4,058,559\nChina, Hong Kong SAR\n4,648,238\nChina, Hong Kong SAR\n2,556,882\nJapan\n2,457,672\n\n\n3\nSpain\n498,741\nBrazil\n1,015,417\nRussian Federation\n1,509,007\nJapan\n2,302,316\nChina\n2,504,820\nChina\n2,789,753\nChina\n2,812,012\nTunisia\n2,484,856\nPoland\n1,565,781\nChina, Hong Kong SAR\n2,360,582\n\n\n4\nTurkiye\n457,040\nRep. of Korea\n443,342\nChina\n1,213,518\nRussian Federation\n1,732,776\nJapan\n2,433,654\nJapan\n2,398,831\nJapan\n2,636,763\nJapan\n2,484,354\nChina\n1,529,201\nPoland\n1,547,787\n\n\n5\n4,705,666\n11,358,039\n16,414,293\n15,695,994\n18,625,940\n18,703,449\n19,973,301\n21,019,792\n12,791,091\n17,288,526\n\n\n\n\n\n\n\n\nShow the code\ntarget_ore = '니켈'\n\nores_uncomtrade_url[target_ore]['df_top5_html'] = ores_uncomtrade_url[target_ore]['df_top5'].copy()\nfor each_year in ores_uncomtrade_url[target_ore]['df_top5'].columns:\n    ores_uncomtrade_url[target_ore]['df_top5_html'][each_year] = ores_uncomtrade_url[target_ore]['df_top5_html'][each_year].str.replace('\\n','&lt;br&gt;')\n\n# HWP파일 작성용 CSV저장, 자동 줄바꿈 적용시 아래 표기처럼 복사/붙여넣기 가능\nores_uncomtrade_url[target_ore]['df_top5'].to_excel(f\"Top5Country_{target_ore}.xlsx\")\ndisplay(HTML(ores_uncomtrade_url[target_ore]['df_top5_html'].to_html(escape=False)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nBrazil\n29,012\nBrazil\n34,127\nBrazil\n19,720\nJapan\n112,033\nJapan\n135,167\nJapan\n191,793\nJapan\n200,127\nJapan\n206,021\nJapan\n173,627\nChina\n256,142\n\n\n1\nGermany\n11,705\nRep. of Korea\n27,394\nChina\n15,197\nRep. of Korea\n53,085\nRep. of Korea\n52,446\nBelgium\n34,111\nBelgium\n31,329\nChina\n98,853\nChina\n119,071\nJapan\n124,779\n\n\n2\nTurkiye\n2,203\nCanada\n16,517\nGermany\n14,054\nChina\n21,639\nAustralia\n21,776\nRep. of Korea\n31,817\nCanada\n21,353\nBelgium\n41,121\nBelgium\n43,286\nBelgium\n41,815\n\n\n3\nSwitzerland\n1,344\nGermany\n12,654\nCanada\n13,500\nGermany\n13,939\nBelgium\n20,963\nCanada\n25,360\nChina\n16,340\nCanada\n21,410\nCanada\n18,103\nMalaysia\n26,280\n\n\n4\nSpain\n1,292\nThailand\n4,923\nRep. of Korea\n8,951\nIndia\n11,978\nChina\n20,569\nAustralia\n19,640\nAustralia\n13,834\nMalaysia\n10,150\nRep. of Korea\n14,469\nCanada\n13,364\n\n\n5\n45,555\n95,615\n71,421\n212,674\n250,921\n302,721\n282,983\n377,554\n368,556\n462,380"
  },
  {
    "objectID": "posts/dtcontest-ore-20240624/index.html#un-comtrade-자료분석연도별-광물수입량-산출",
    "href": "posts/dtcontest-ore-20240624/index.html#un-comtrade-자료분석연도별-광물수입량-산출",
    "title": "[공모전] 공공데이터 공모전-7(광물 전체 제안배경 작성)",
    "section": "UN Comtrade 자료분석(연도별 광물수입량 산출)",
    "text": "UN Comtrade 자료분석(연도별 광물수입량 산출)\n\n\nShow the code\nplt.rcParams['font.family'] = 'Nanum Gothic'\n\nfig, ax = plt.subplots(figsize=(20, 4), ncols=3)\n\nfor ore in ores_uncomtrade_url.keys():\n    sns_index = ores_uncomtrade_url[ore]['df_top5'].columns.tolist()\n    sns_value = ores_uncomtrade_url[ore]['df_top5'].values[5].tolist()\n    sns_df = pd.DataFrame(sns_value, index=sns_index, columns=[ore])\n    sns_df = sns_df[ore].str.replace(',','').astype(int)\n\n    if ore in ['망간']:\n        target_ax = ax[0]\n    elif ore in ['니켈','리튬']:\n        target_ax = ax[1]\n    elif ore in ['니켈','코발트']:\n        target_ax = ax[2]\n\n    sns_df.plot(ax=target_ax)\n\n    target_ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: '{:,}'.format(int(x))))\n\nfor each_ax in ax:\n    each_ax.legend()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html",
    "href": "posts/meta-dl-creditcard-20240623/index.html",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "",
    "text": "참여중인 딥러닝 스터디 5주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#개요",
    "href": "posts/meta-dl-creditcard-20240623/index.html#개요",
    "title": "[M_Study_5주차] Overfitting Control",
    "section": "",
    "text": "참여중인 딥러닝 스터디 5주차 기록입니다."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#주차-과제정리",
    "href": "posts/meta-dl-creditcard-20240623/index.html#주차-과제정리",
    "title": "[M_Study_5주차] Overfitting Control",
    "section": "4주차 과제정리",
    "text": "4주차 과제정리\n# MNIST Data Load\n(x_train, y_train), (x_test, y_test) = datasets.mnist.load_data()\nprint(x_train.shape, y_train.shape, y_train[0])\n&gt;&gt;&gt; (60000, 28, 28) (60000,) 5\n\nx_train = x_train.reshape((60000,28,28,1))\n\n위 코드와 같이 reshape 하는 이유\n\n이미지 처리의 코드는 기본적으로 3차원이 들어오게 되어있음\n\n관례적으로 앞의 샘플(60000)은 제외(표기생략)하고 뒤에 있는 부분(28,28)을 사용하는데, 2차원임\nreshape로 (28,28,1)과 같이 통상의 이미지를 처리하는 형식으로 만들어줌 \n\n\nCNN은 2개의 단계로 진행 (Feature Learning + Classification)\n\nFeature Learning\n  # Step 1. Feature Learning\n  model = Sequential()\n\n  # output size formula: { (N - F + 2P) / stride } +1\n  # parameter formual: K(F^2 * C + 1)\n\n  # filter number: 32, filter_size = 3x3, (default) stride = 1, padding = 'valid' (= no padding)\n  model.add(Conv2D(32, (3,3), activation = \"relu\", input_shape = (28,28,1)))\n  # output shape = {(28-3)/1} +1 = 26 =&gt; feature map = 26 x 26 x 32\n\n  # pool_size = 2x2, stride = None, padding = \"valid\" (= no padding)\n  model.add(MaxPooling2D((2,2)))\n  # output shape = 26/2 = 13 =&gt; feature map = 13 x 13 x 32\n\n  model.add(Conv2D(64, (3,3), activation = \"relu\"))\n  # output shape = {(13-3)/1} +1 = 11 =&gt; feature map = 11 x 11 x 64\n\n  model.add(MaxPooling2D((2,2)))\n  # output shape = 11/2 = 5,5 =&gt; 5 =&gt; feature map = 5 x 5 x 64\n\n  model.add(Conv2D(64, (3,3), activation = \"relu\"))\n  # output shape = {(5-3)/1} +1 = 3 x 3 x 64\nClassification\n  # Step 2. Fully Conneted Layer\n  model.add(Flatten())\n  model.add(Dense(64, activation = \"relu\"))\n  model.add(Dense(10, activation = \"softmax\"))\n\nMulticlass문제에는 Output Activation function을 Softmax로 한다 \n\n# model compile: cost function, optimizer, metric 설정\nmodel.compile(optimizer=\"adam\",\n          loss = 'sparse_categorical_crossentropy',\n          metrics = ['accuracy'])\n# Training\nhistory = model.fit(x_train, y_train, epochs=5)\n&gt;&gt;&gt;Epoch 1/5\n1875/1875 [==============================] - 12s 4ms/step - loss: 0.1554 - accuracy: 0.9520\nEpoch 2/5\n1875/1875 [==============================] - 7s 4ms/step - loss: 0.0497 - accuracy: 0.9843\nEpoch 3/5\n1875/1875 [==============================] - 8s 4ms/step - loss: 0.0344 - accuracy: 0.9891\nEpoch 4/5\n1875/1875 [==============================] - 8s 4ms/step - loss: 0.0266 - accuracy: 0.9917\nEpoch 5/5\n1875/1875 [==============================] - 8s 4ms/step - loss: 0.0229 - accuracy: 0.9926\n\n지난번 ANN 등 보다 좋은 정확도나온 이유(기존ML 등 대비)\n\n파라미터의 수가 늘어나, 비선형적 관계를 많이 표현가능해짐\n\n(CNN을 쓰며)지난번보다 Layer를 깊게(많이) 만듦\n뉴런의 수 증가\n\n하이퍼 파라미터 조정(Relu사용 등)\nAdam Optimizer의 사용\n\n\n  # Prediction example\n  predictions = model.predict(x_test)\n\n  print(predictions[0])\n  print(np.argmax(predictions[0]))\n  print(y_test[0])\n\n  &gt;&gt;&gt; [1.3171346e-07 2.3666507e-08 5.0742160e-06 8.5065667e-06 9.7597770e-08\n 5.1097163e-07 6.6373372e-11 9.9998188e-01 1.0004998e-06 2.8241509e-06]\n\n위 코드의 predictions[0]의 10개값\n\nSoftmax로 도출된, 0~9 중 어떤 값에 속할 지에 대한 확률\n\nGPU로 모델을 돌리는 방법\n\n실습 중인 경우는 GPU가 필요할 정돈 아니지만, 보통의 프로젝트는 GPU사용이 필수적\n\nwith tf.device('/device:GPU:0')\n\nwith tf.device('/device:GPU:0'):\n  # Feature Learning\n  model = Sequential()\n  model.add(Conv2D(32, (3,3), input_shape = (28,28,1)))\n  model.add(MaxPooling2D((2,2)))\n  model.add(Conv2D(64, (3,3)))\n  model.add(MaxPooling2D((2,2)))\n  model.add(Conv2D(64, (3,3)))\n  # Fully Conneted Layer\n  model.add(Flatten())\n  model.add(Dense(64, activation = \"relu\"))\n  model.add(Dense(10, activation = \"softmax\"))\n  model.summary()\n  # model compile: cost function, optimizer, metric 설정\n  model.compile(optimizer=\"adam\",\n                loss = 'sparse_categorical_crossentropy',\n                metrics = ['accuracy'])\n  # Training\n  history = model.fit(x_train, y_train, epochs=5)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#주차-수업정리",
    "href": "posts/meta-dl-creditcard-20240623/index.html#주차-수업정리",
    "title": "[M_Study_5주차] Overfitting Control",
    "section": "5주차 수업정리",
    "text": "5주차 수업정리\n\nHyper parameter(하이퍼 파라미터)\n\n위 과제에서의 성능향상은, CNN의 적용(계산량의 감소)보다는, 하이퍼 파라미터조정에서 기인함\n하이퍼 파라미터 : 사람이 정해주는 레이어 갯수, 뉴런의 갯수 등 \n\n\n(1) Activation functions : Sigmoid, tanh, ReLU 등\n\n비선형성을 부여하기 위해 사용. 어떤 것을 쓰냐에 따라 Neural Network성능에 큰 영향\nActivation functions의 종류\n\nSigmoid : 0~1 출력. Logistic regression 등 오래부터 쓰였던 함수.\n\n0~1 사이이기 때문에 확률적 해석이 가능\n문제\n\nKilling Gradient : 가장 치명적 문제. 미분값이 0이 되는 구간은 학습이 일어나지 않음\nOutput not Zero-centered : 치명적 문제. 학습은 되지만, 레이어를 통과할 때마다 왜곡 심화(같은 방향으로만 학습)\n\nSGD에서는 Batch-size 반복마다 일종의 자정작용이 있어 약간 완화되기는 함\n\nComputationally expensive : 학습이 안될 정도의 큰 문제는 아님. Exponential계산 등 계산량이 많음\n\n\ntanh : -1~1 출력.\n\nZero-centered이므로 왜곡이 일어나지는 않음\n문제 : 여전히 Killing Gradient문제가 존재하여 Neural Network에서 쓰기는 부적절\n\nReLU(Rectified Linear Unit) : 음수면 0, 양수면 그대로\n\nComputationaliy very efficient(음수면 0반환)\nKilling Gradient문제는 없음. 기울기가 0인 지점이 없으므로(단 0인 부분은 미분이 되지 않음)\n문제\n\nOutput not Zero-centered(Batch-size 적용시 큰 문제가 되진 않음)\n0인 부분은 미분이 되지 않음(0인 경우는 미분값 지정하는 방법으로 해결 가능)\nDead ReLU : 한번 0이되면, Layer가 계속 되어도 기울기가 업데이트 되지 않고 0\n\n\nLeaky ReLU(Rectified Linear Unit)  \n\n음수인 경우 0이 아닌 0.01\\(x\\)를 적용하여Dead ReLU문제 해결 가능\n효율적인 계산이나 Sigmoid/Tanh대비 빠른 장점 등 ReLU의 장점 존재\n문제 : additional paremeter(0.01\\(x\\))를 계산해야해서 계산량이 늘어나기는 함\n\nELU(Exponential Linear Unit) :\n\n기존처럼 인위적인 지정(구간별 미분값 등)없이, 모든 지점에서 자연스럽게 미분이 가능하도록 Exponential 적용\n문제 : 계산량이 늘어남\n\nExponential연산은 nvidia환경에서 지원이 되는 편이긴 함\n\n\n\nActivation function의 적용\n\n기본적으로는 ReLU를 사용. Dead ReLU문제가 있긴하지만 일반적인 프로젝트 수준에서는 무방\n단 Computation자원이 충분하다면 Leaky ReLU나 ELU 사용 가능\nSigmoid나 Tanh는 Hidden layer의 Activation function으로 사용X(Killing Gradient문제로 학습되지 않음)\n참고 : GPT계열 등 대규모 모델은 ReLU계열이나 GELU(ELU를 Gausssian으로 바꾼)\n\n\n\n\n(2) Weight Initialization\n\nGradient Descent에서 임의의 점에서 시작했었던 것과 달리, 좋은 시작지점에서 시작하고자 하는 것\n임의의 크거나 작은 Weight로 시작하는 경우와 문제\n\nSmall Gaussian Random : 작은 Weight로 시작한 경우\n\nLayer를 통과할때마다 한 곳으로 수렴(0으로 수렴)되어 학습이 되지 않음 \n\nLarge  Gaussian Random : 큰 Weight로 시작한 경우\n\nLayer를 통과할때마다 양쪽으로 발산(1,-1로 수렴)되어 학습이 되지 않음 \n\nReLU를 적용하더라도 위와 비슷한 문제는 발생\n\nXavier Initialization : Input dimension에 루트를 씌운 것으로 나눠 준 Weight 사용 (64차원이라면 8로 나눔)\n\nInput variance와 Output variance 맞춰 좋은 시작점(Weight)에서 시작\nLayer를 여러번 통과해도 Robust한 정규분포 모양으로 나오게 됨  \n\nKaiming/MSRA Initialization for ReLU : 2/Input dimension 을 루트 씌운 것으로 나눈 Weight 사용\n\n\n\n\nLearning rate Scheduling\n\n어떤 Learning rate가 가장 좋은가?  \n\nVery high : 이동이 너무 커서 Loss가 급격히 상승\nLow : 이동이 너무 작아서 오래걸림\nHigh : 처음엔 적절한 rate보다도 학습이 빠르지만, 일정 수준부터 Loss감소가 없음\n적절한 rate를 통해, 적절한 속도로 optimum point로 도달하도록 해야함\n\nLearning rate Scheduling(Decay)의 구상\n\nHigh(빠름) → Good(적절) → Low 의 rate를 적용하면 되지 않는지에 대한 의문으로 시작\nEpoch에 따라 learning rate를 조절하여 효율적인 학습속도 구현 (↔︎ constant learning rate) \n모든 프로젝트에 직관을 적용한 Scheduling은 어려우며, 모든 프로젝트에 적용가능한 Scheduling은 없음.\n\n정해진 Scheduling은방식(Cosine, Linear, Inverse Sqrt 등)이 존재\n\n\n\n\n(1) Learning rate Scheduling의 종류 : Cosine, Linear, Inverse Sqrt 등\n\n크게 3가지 종류가 있음\n\nLinear Learning rate : [세심하게 학습] 가장 기본적. Epoch을 거듭할수록 rate 감소\nCosine Learning rate : [빠른 학습] High rate를 좀 더 오래 유지\nInverse Sqrt rate : [무난하게 학습] rate를 빠르게 감소시킴. Optimal Point를 세밀하게 찾고 싶을 때 사용\n\n분야마다 많이 사용되는 방법은 다름\n\n자연어처리는 큰 모델을 다루고 학습데이터가 많은 편이므로 Cosine Learning rate Scheduler 사용\n작은 문제나 모델이라면 Linear/Inverse Sqrt earning rate Scheduler 고려 가능\n\nLearning rate Warm-up?\n\n눈으로 Loss 등을 보며 감을 잡는 구간\n\nLoss가 엄청 높게 튀는 경우 Learning rate가 높으므로 낮춤\n\n\n참고\n\nHyper parameter가 적용되는 부분\n\nActivation function은 레이어마다 적용\nLearning rate epoch마다 적용\nWeight Initialization은 처음에만 적용\n\n대략적인 가이드라인\n\n레이어나 뉴런의 수는 가이드라인이 없는 편 (실험해보며 조정)\n\n레이어의 수가 많을수록 복잡한/비선형적인 관계를 표현 가능\n레이어의 수가 30개가 좋은지 50개가 좋은진 알 수 없음\n\nLearning rate는 특정 값이 높거나 낮다고 볼 수 없음 (실험해보며 조정)\n\nLoss값이 너무 튀면 learning rate를 먼저 조정 (대부분 말도안되게 튀는 것은 learning rate문제)\n\n\n우선순위 : (loss가 튐)Learning rate 조정 → Optimizer\n\n\n\n\n\nRegularization for Overfitting\n\n(1) Overfitting\n\n새로운 데이터에 대해서는 잘 동작하지 않음 (↔︎Underfitting. 학습한 데이터도 처리하지 못함. 과거의 전통적 머신러닝[모델의 한계 등])\n파라미터의 갯수가 늘어나고 복잡해지는 경우 많음\n\n\n\n(2) Regularization\n\n파라미터가 커질수록 오차도 커짐 → 파라미터가 커져 Overfitting이 일어나는 것을 방지\n람다(\\(\\lambda\\))의 크기로 패널티의 크기를 설정. 커질수록 하단 Boundary(L2는 원형, L1은 마름모)는 작아짐\n기존의 최적화 지점(Parameter제약 없을 때)에서 그래프의 화살표 방향(Boundary안)으로 이동\nRegularization 종류\n\nRidge Regression(L2 Norm) : 기존의 오차정의(MSE 등)에, Penalty term으로 파라미터를 제곱해서 더함  \nLasso Regression(L1 Norm) : 기존의 오차정의(MSE 등)에, Penalty term으로 파라미터를 절대값으로 더함 (Ridge와의 차이점 : 필요없는 파라미터를 삭제해줌)  \n\n\n\n\n(1) Regularization for Deep Nueral Networks\n\nWeight decay\n\nRidge(L1, 제곱, 원형마름모Boundary), Lasso(L2, 절대값, 마름모Boundary)의 적용\nMultiple regression 등 과거엔 많이 쓰였지만 딥러닝에선 잘 안쓰임\n\nEarly stopping\n\nTrain set에서 Validation set을 분리해두고, Validation점수가 높아질때까지(Loss저하) 학습\n\nTest loss가 Overfitting지점부터 발생하는 점을 참고\n\nAcuraccy와 같은 Metric으로 적용하는 것이 트렌드\nLoss는 미분가능 & 작을수록 좋은 지표 등을 이유로 채택했지만 실제 알고싶은 것은 Loss가 아닌 Accuracy임\nF1-score 등은 미분 불가로 적용 불가했지만, 측정 목적이라면 Accuracy를 채택\n단점 : 측정을 위한 Validation set을 만들기 위해 데이터가 많이 필요(데이터가 적은 바이오분야 등은 적용 어려움)\n\n다만 딥러닝은 보통 데이터가 많은 경우에 사용하므로 Early stopping 적용이 가능함\n\n주의점 : Train/Validation/Test로 나눌 때, Test Set은 정한 뒤엔 건드리지 않는다 (Train set에서 나눈 Train set와 Validation set의 비율 조절은 가능하다)\nFinal metric으로 사용된다\n\nDrop out\n\nRandom한 뉴런을 끈다\n다소 무식하지만 효과가 좋아 잘 사용됨(GPT 등에서도 활용)\n\n예시) 고양이의 눈/귀/코를 특징으로 잡을 때, 호랑이의 눈이 들어온다면 오류가 발생할 수 있는데, 눈에 대한 특징(뉴런)이 꺼져있다면 오류를 방지할 수 있다\n\nCut out(Drop out의 응용) : 사진에서 특정 부분을 Random하게 삭제하여 입력하여 판단시키는 방법으로 Overfitting극복\nLarge fully-connected layers에 사용\n\n\n\n\n\nOptimization\n\nSGD : 전체 데이터를 다 넣기 어려워 Batch를 적용해 극복\n\n\n(1) SGD의 문제\n\nJittering문제 : 원하는 것은 전체 파라미터의 최적화지만, 특정 파라미터만 학습이 진행됨\n\n예를 들어 자산&월급이 있을 때, 값이 큰 자산 위주로 최적화가 진행됨\nSingular value가 큰 쪽으로 학습이 이루어짐\n\nLocal optimum문제 : 전체의 최적이 아닌, 부분의 최적인 Local Optimum에 빠지는 문제\n\n다만, 딥러닝에서는 거의 일어나지 않는 문제임. 모든 파라미터 대부분이 양수거나 음수인 특수한 상황에서 발생\n\nSaddle points문제 : 말의 안장같이 생겨, 극소인 동시에 극대인 지점이 발생. 학습이 이루어지지 않는 문제\n\n오히려 Saddle point문제가 딥러닝에서는 더 많이 발생 (미분값이 여러개의 양수/음수가 섞임)\n\nInaccurate Gradient Estimation문제\n\n어느정도까지는(~50% 정도) Batch size가 클수록 성능향상이 있음\n\n장비(메모리)가 유효하게 많을때만 가능한 방법으로, 잘 갖춰진 환경에서만 적용 가능함(Google의 연구논문이었음)\n\n즉 현실적으로는 Batch size 확대는 적용이 어려운 점이 있음\n\n82.76~83% 구간의 변화로, Practical하게 유의미한 결과로 보긴 어려움(Academic한 측면에서 유의미)\n\n적용Insignt : 나에게 1만개의 데이터가 있을 때, 5천 건 정도의 Size(2의 배수인 4096으로) 적용\n\n\n\n\n(2) SGD의 문제들에 대한 해결방법\n\nSGD + Momentum (Saddle Points문제 해결)\n\n현실과 달리 GD의 적용시에는 관성이 없으므로 Saddle point에서 멈추게 되므로, 관성을 주어 해결\n\nLocal minimum에서는 적용 불가. saddle point형태이기에 가능한 방법 \n\n\nAdaGrad[AdaptiveGrad] (Jittering문제 해결)\n\nScale이 달라 발생하는 문제이므로, Scaling을 해주어 맞춰줌\n\nRMSProp [Leaky AdaGrad] (AdaGrad문제 해결)\n\nAdaGrad가 나누기를 반복하다보니 분모가 커져 0에 수렴하는 문제를 해결\n현재의 비율과 과거의 비율을 조절해 분모가 너무 커지는 것을 방지\nAdaGrad의 Scaling개념을 이해하며 사용하는 것이 중요\n\nAdam\n\nRMSProp + SGD with Momentum\n\nFirst vs Second order Optimization : 실전적으로 잘 쓰이지 않음\n\n역행렬이 있다는 점에서 계산량이 많아 쓰기 어렵다는 직관적 이해 정도 갖기\n\n\n\n\n\nBatch Normalization\n\nData Preprocessing (Nomalization)\n\n통상적으로 Zero-centering, Scaling 두가지를 해 줌\nLayer를 통과할 때마다 왜곡이 커지는 문제를 방지 \n\nZero-centering : 중심에서 점점 멀어지는 문제 해결 (평균을 뺀다)\nScaling : 분포가 점점 길어지는 문제 해결 (표준편차 등 특정 숫자로 나눠 준다)\n\n일반적인 ML은 처음에 전처리를 하면 되지만, DL은 레이어를 통과하며 다시 왜곡이 심해질 수 있음\n\n왜곡을 막기 위해 레이어 통과마다 반복하는 Batch Normalization을 진행\n\n\n\n\nBatch Normalization\n\n레이어를 통과할 대마다 Zero-centering, Scaling을 해줌\nDrop-out과 함께 많이 사용됨\n적용은\n\nActivation function 적용하기 전에\nFully-connected layer 통과한 다음에\n\n\n\n\nBatch Normalization의 종류\n\nBatch / Layer / Instance / Group Normalization\n기본적으로는 대부분은 Batch Normalization을 많이 사용(특히 이미지)\n자연어 처리는 Layer Normalization을 사용"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#hyper-parameter하이퍼-파라미터",
    "href": "posts/meta-dl-creditcard-20240623/index.html#hyper-parameter하이퍼-파라미터",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "Hyper parameter(하이퍼 파라미터)",
    "text": "Hyper parameter(하이퍼 파라미터)\n\n위 과제에서의 성능향상은, CNN의 적용(계산량의 감소)보다는, 하이퍼 파라미터조정에서 기인함\n하이퍼 파라미터 : 사람이 정해주는 레이어 갯수, 뉴런의 갯수 등 \n\n\n(1) Activation functions : Sigmoid, tanh, ReLU 등\n\n비선형성을 부여하기 위해 사용. 어떤 것을 쓰냐에 따라 Neural Network성능에 큰 영향\nActivation functions의 종류\n\nSigmoid : 0~1 출력. Logistic regression 등 오래부터 쓰였던 함수.\n\n0~1 사이이기 때문에 확률적 해석이 가능\n문제\n\nKilling Gradient : 가장 치명적 문제. 미분값이 0이 되는 구간은 학습이 일어나지 않음\nOutput not Zero-centered : 치명적 문제. 학습은 되지만, 레이어를 통과할 때마다 왜곡 심화(같은 방향으로만 학습)\n\nSGD에서는 Batch-size 반복마다 일종의 자정작용이 있어 약간 완화되기는 함\n\nComputationally expensive : 학습이 안될 정도의 큰 문제는 아님. Exponential계산 등 계산량이 많음\n\n\ntanh : -1~1 출력.\n\nZero-centered이므로 왜곡이 일어나지는 않음\n문제 : 여전히 Killing Gradient문제가 존재하여 Neural Network에서 쓰기는 부적절\n\nReLU(Rectified Linear Unit) : 음수면 0, 양수면 그대로\n\nComputationaliy very efficient(음수면 0반환)\nKilling Gradient문제는 없음. 기울기가 0인 지점이 없으므로(단 0인 부분은 미분이 되지 않음)\n문제\n\nOutput not Zero-centered(Batch-size 적용시 큰 문제가 되진 않음)\n0인 부분은 미분이 되지 않음(0인 경우는 미분값 지정하는 방법으로 해결 가능)\nDead ReLU : 한번 0이되면, Layer가 계속 되어도 기울기가 업데이트 되지 않고 0\n\n\nLeaky ReLU(Rectified Linear Unit)  \n\n음수인 경우 0이 아닌 0.01\\(x\\)를 적용하여Dead ReLU문제 해결 가능\n효율적인 계산이나 Sigmoid/Tanh대비 빠른 장점 등 ReLU의 장점 존재\n문제 : additional paremeter(0.01\\(x\\))를 계산해야해서 계산량이 늘어나기는 함\n\nELU(Exponential Linear Unit) :\n\n기존처럼 인위적인 지정(구간별 미분값 등)없이, 모든 지점에서 자연스럽게 미분이 가능하도록 Exponential 적용\n문제 : 계산량이 늘어남\n\nExponential연산은 nvidia환경에서 지원이 되는 편이긴 함\n\n\n\nActivation function의 적용\n\n기본적으로는 ReLU를 사용. Dead ReLU문제가 있긴하지만 일반적인 프로젝트 수준에서는 무방\n단 Computation자원이 충분하다면 Leaky ReLU나 ELU 사용 가능\nSigmoid나 Tanh는 Hidden layer의 Activation function으로 사용X(Killing Gradient문제로 학습되지 않음)\n참고 : GPT계열 등 대규모 모델은 ReLU계열이나 GELU(ELU를 Gausssian으로 바꾼)\n\n\n\n\n(2) Weight Initialization\n\nGradient Descent에서 임의의 점에서 시작했었던 것과 달리, 좋은 시작지점에서 시작하고자 하는 것\n임의의 크거나 작은 Weight로 시작하는 경우와 문제\n\nSmall Gaussian Random : 작은 Weight로 시작한 경우\n\nLayer를 통과할때마다 한 곳으로 수렴(0으로 수렴)되어 학습이 되지 않음 \n\nLarge  Gaussian Random : 큰 Weight로 시작한 경우\n\nLayer를 통과할때마다 양쪽으로 발산(1,-1로 수렴)되어 학습이 되지 않음 \n\nReLU를 적용하더라도 위와 비슷한 문제는 발생\n\nXavier Initialization : Input dimension에 루트를 씌운 것으로 나눠 준 Weight 사용 (64차원이라면 8로 나눔)\n\nInput variance와 Output variance 맞춰 좋은 시작점(Weight)에서 시작\nLayer를 여러번 통과해도 Robust한 정규분포 모양으로 나오게 됨  \n\nKaiming/MSRA Initialization for ReLU : 2/Input dimension 을 루트 씌운 것으로 나눈 Weight 사용"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#learning-rate-scheduling",
    "href": "posts/meta-dl-creditcard-20240623/index.html#learning-rate-scheduling",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "Learning rate Scheduling",
    "text": "Learning rate Scheduling\n\n어떤 Learning rate가 가장 좋은가?  \n\nVery high : 이동이 너무 커서 Loss가 급격히 상승\nLow : 이동이 너무 작아서 오래걸림\nHigh : 처음엔 적절한 rate보다도 학습이 빠르지만, 일정 수준부터 Loss감소가 없음\n적절한 rate를 통해, 적절한 속도로 optimum point로 도달하도록 해야함\n\nLearning rate Scheduling(Decay)의 구상\n\nHigh(빠름) → Good(적절) → Low 의 rate를 적용하면 되지 않는지에 대한 의문으로 시작\nEpoch에 따라 learning rate를 조절하여 효율적인 학습속도 구현 (↔︎ constant learning rate) \n모든 프로젝트에 직관을 적용한 Scheduling은 어려우며, 모든 프로젝트에 적용가능한 Scheduling은 없음.\n\n정해진 Scheduling은방식(Cosine, Linear, Inverse Sqrt 등)이 존재\n\n\n\n\n(1) Learning rate Scheduling의 종류\n\n크게 3가지 종류가 있음\n\nLinear Learning rate : [세심하게 학습] 가장 기본적. Epoch을 거듭할수록 rate 감소\nCosine Learning rate : [빠른 학습] High rate를 좀 더 오래 유지\nInverse Sqrt rate : [무난하게 학습] rate를 빠르게 감소시킴. Optimal Point를 세밀하게 찾고 싶을 때 사용\n\n분야마다 많이 사용되는 방법은 다름\n\n자연어처리는 큰 모델을 다루고 학습데이터가 많은 편이므로 Cosine Learning rate Scheduler 사용\n작은 문제나 모델이라면 Linear/Inverse Sqrt earning rate Scheduler 고려 가능\n\nLearning rate Warm-up?\n\n눈으로 Loss 등을 보며 감을 잡는 구간\n\nLoss가 엄청 높게 튀는 경우 Learning rate가 높으므로 낮춤\n\n\n\n\n\n(2) 기타 참고사항\n\nHyper parameter가 적용되는 부분\n\nActivation function은 레이어마다 적용\nLearning rate epoch마다 적용\nWeight Initialization은 처음에만 적용\n\n대략적인 가이드라인\n\n레이어나 뉴런의 수는 가이드라인이 없는 편 (실험해보며 조정)\n\n레이어의 수가 많을수록 복잡한/비선형적인 관계를 표현 가능\n레이어의 수가 30개가 좋은지 50개가 좋은진 알 수 없음\n\nLearning rate는 특정 값이 높거나 낮다고 볼 수 없음 (실험해보며 조정)\n\nLoss값이 너무 튀면 learning rate를 먼저 조정 (대부분 말도안되게 튀는 것은 learning rate문제)\n\n\n우선순위 : (loss가 튐)Learning rate 조정 → Optimizer"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#regularization-for-overfitting",
    "href": "posts/meta-dl-creditcard-20240623/index.html#regularization-for-overfitting",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "Regularization for Overfitting",
    "text": "Regularization for Overfitting\n\n(1) Overfitting\n\n새로운 데이터에 대해서는 잘 동작하지 않음 (↔︎Underfitting. 학습한 데이터도 처리하지 못함. 과거의 전통적 머신러닝[모델의 한계 등])\n파라미터의 갯수가 늘어나고 복잡해지는 경우 많음\n\n\n\n(2) Regularization\n\n파라미터가 커질수록 오차도 커짐 → 파라미터가 커져 Overfitting이 일어나는 것을 방지\n람다(\\(\\lambda\\))의 크기로 패널티의 크기를 설정. 커질수록 하단 Boundary(L2는 원형, L1은 마름모)는 작아짐\n기존의 최적화 지점(Parameter제약 없을 때)에서 그래프의 화살표 방향(Boundary안)으로 이동\n\n\nRidge Regression(L2 Norm)\n\n기존의 오차정의(MSE 등)에, Penalty term으로 파라미터를 제곱해서 더함  \n\n\n\nLasso Regression(L1 Norm)\n\n기존의 오차정의(MSE 등)에, Penalty term으로 파라미터를 절대값으로 더함 (Ridge와의 차이점 : 필요없는 파라미터를 삭제해줌)  \n\n\n\n\n(3) Regularization for Deep Nueral Networks\n\nWeight decay\n\nRidge(L1, 제곱, 원형마름모Boundary), Lasso(L2, 절대값, 마름모Boundary)의 적용\nMultiple regression 등 과거엔 많이 쓰였지만 딥러닝에선 잘 안쓰임\n\n\n\nEarly stopping\n\nTrain set에서 Validation set을 분리해두고, Validation점수가 높아질때까지(Loss저하) 학습\n\nTest loss가 Overfitting지점부터 발생하는 점을 참고\n\nAcuraccy와 같은 Metric으로 적용하는 것이 트렌드\nLoss는 미분가능 & 작을수록 좋은 지표 등을 이유로 채택했지만 실제 알고싶은 것은 Loss가 아닌 Accuracy임\nF1-score 등은 미분 불가로 적용 불가했지만, 측정 목적이라면 Accuracy를 채택\n단점 : 측정을 위한 Validation set을 만들기 위해 데이터가 많이 필요(데이터가 적은 바이오분야 등은 적용 어려움)\n\n다만 딥러닝은 보통 데이터가 많은 경우에 사용하므로 Early stopping 적용이 가능함\n\n주의점 : Train/Validation/Test로 나눌 때, Test Set은 정한 뒤엔 건드리지 않는다 (Train set에서 나눈 Train set와 Validation set의 비율 조절은 가능하다)\nFinal metric으로 사용된다\n\n\n\nDrop out\n\nRandom한 뉴런을 끈다\n다소 무식하지만 효과가 좋아 잘 사용됨(GPT 등에서도 활용)\n\n예시) 고양이의 눈/귀/코를 특징으로 잡을 때, 호랑이의 눈이 들어온다면 오류가 발생할 수 있는데, 눈에 대한 특징(뉴런)이 꺼져있다면 오류를 방지할 수도 있다\n\nCut out(Drop out의 응용) : 사진에서 특정 부분을 Random하게 삭제하여 입력하여 판단시키는 방법으로 Overfitting극복\nLarge fully-connected layers에 사용"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#optimization",
    "href": "posts/meta-dl-creditcard-20240623/index.html#optimization",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "Optimization",
    "text": "Optimization\n\nSGD : 전체 데이터를 다 넣기 어려워 Batch를 적용해 극복\n\n\n(1) SGD의 문제\n\nJittering문제 : 원하는 것은 전체 파라미터의 최적화지만, 특정 파라미터만 학습이 진행됨\n\n예를 들어 자산&월급이 있을 때, 값이 큰 자산 위주로 최적화가 진행됨\nSingular value가 큰 쪽으로 학습이 이루어짐\n\nLocal optimum문제 : 전체의 최적이 아닌, 부분의 최적인 Local Optimum에 빠지는 문제\n\n다만, 딥러닝에서는 거의 일어나지 않는 문제임. 모든 파라미터 대부분이 양수거나 음수인 특수한 상황에서 발생\n\nSaddle points문제 : 말의 안장같이 생겨, 극소인 동시에 극대인 지점이 발생. 학습이 이루어지지 않는 문제\n\n오히려 Saddle point문제가 딥러닝에서는 더 많이 발생 (미분값이 여러개의 양수/음수가 섞임)\n\nInaccurate Gradient Estimation문제\n\n어느정도까지는(~50% 정도) Batch size가 클수록 성능향상이 있음\n\n장비(메모리)가 유효하게 많을때만 가능한 방법으로, 잘 갖춰진 환경에서만 적용 가능함(Google의 연구논문이었음)\n\n즉 현실적으로는 Batch size 확대는 적용이 어려운 점이 있음\n\n82.76~83% 구간의 변화로, Practical하게 유의미한 결과로 보긴 어려움(Academic한 측면에서 유의미)\n\n적용Insignt : 나에게 1만개의 데이터가 있을 때, 5천 건 정도의 Size(2의 배수인 4096으로) 적용\n\n\n\n\n(2) SGD의 문제들에 대한 해결방법\n\nSGD + Momentum (Saddle Points문제 해결)\n\n현실과 달리 GD의 적용시에는 관성이 없으므로 Saddle point에서 멈추게 되므로, 관성을 주어 해결\n\nLocal minimum에서는 적용 불가. saddle point형태이기에 가능한 방법 \n\n\nAdaGrad[AdaptiveGrad] (Jittering문제 해결)\n\nScale이 달라 발생하는 문제이므로, Scaling을 해주어 맞춰줌\n\nRMSProp [Leaky AdaGrad] (AdaGrad문제 해결)\n\nAdaGrad가 나누기를 반복하다보니 분모가 커져 0에 수렴하는 문제를 해결\n현재의 비율과 과거의 비율을 조절해 분모가 너무 커지는 것을 방지\nAdaGrad의 Scaling개념을 이해하며 사용하는 것이 중요\n\nAdam\n\nRMSProp + SGD with Momentum\n\nFirst vs Second order Optimization : 실전적으로 잘 쓰이지 않음\n\n역행렬이 있다는 점에서 계산량이 많아 쓰기 어렵다는 직관적 이해 정도 갖기"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240623/index.html#batch-normalization",
    "href": "posts/meta-dl-creditcard-20240623/index.html#batch-normalization",
    "title": "[M_Study_5주차] Overfitting Control & Hyper-Parameter",
    "section": "Batch Normalization",
    "text": "Batch Normalization\n\nData Preprocessing (Nomalization)\n\n통상적으로 Zero-centering, Scaling 두가지를 해 줌\nLayer를 통과할 때마다 왜곡이 커지는 문제를 방지 \n\nZero-centering : 중심에서 점점 멀어지는 문제 해결 (평균을 뺀다)\nScaling : 분포가 점점 길어지는 문제 해결 (표준편차 등 특정 숫자로 나눠 준다)\n\n일반적인 ML은 처음에 전처리를 하면 되지만, DL은 레이어를 통과하며 다시 왜곡이 심해질 수 있음\n\n왜곡을 막기 위해 레이어 통과마다 반복하는 Batch Normalization을 진행\n\n\n\n\nBatch Normalization\n\n레이어를 통과할 대마다 Zero-centering, Scaling을 해줌\nDrop-out과 함께 많이 사용됨\n적용은\n\nActivation function 적용하기 전에\nFully-connected layer 통과한 다음에\n\n\n\n\nBatch Normalization의 종류\n\nBatch / Layer / Instance / Group Normalization\n기본적으로는 대부분은 Batch Normalization을 많이 사용(특히 이미지)\n자연어 처리는 Layer Normalization을 사용"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240630/index.html",
    "href": "posts/meta-dl-creditcard-20240630/index.html",
    "title": "[M_Study_6주차] 자연어처리 및 RNN관련 기초내용",
    "section": "",
    "text": "참여중인 딥러닝 스터디 6주차 기록입니다.\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240630/index.html#자연어처리-관련-기초적인-내용",
    "href": "posts/meta-dl-creditcard-20240630/index.html#자연어처리-관련-기초적인-내용",
    "title": "[M_Study_6주차] 자연어처리 및 RNN관련 기초내용",
    "section": "자연어처리 관련 기초적인 내용",
    "text": "자연어처리 관련 기초적인 내용\n\n시계열데이터(Sequential Data)\n\n시계열데이터(Sequential Data) : 문장(순서를 가진 단어들), 영상, 주가, 태풍의 이동경로 등  (자연어처리도 시계열데이터의 하위분야 중 하나)\n기본적으로 Input - Output - 그 사이의 function 을 파악하면 좋으며, 아래는 예시임\n\n태풍으로 인한 날짜별 피해액을 알고자 할 때 : Input도 Output도 시계열\n태풍의 소멸시기 예측 : Input은 시계열이지만 Output은 single output\n단어가 문법적으로 맞는지 : 시계열 문제\n문장의 주제가 어떤 것인지(과학? 문학?) : single output\n그림을 묘사하는 문장 생성 : 시계열이 아닌 Input과 시계열인 Output\n\n\n\n\nProblem types 예시\n\nOne-to-one : (Image classification) 숫자 이미지를 input으로 받아 정답 숫자를 output\nMany-to-one : (Frame → Class) 태풍의 이동경로, 속도를 input으로 하여 언제사라질지 output\nMany-to-many : (Frames → Classes) 태풍의 이동경로, 속도를 input으로 하여 날짜별 피해액 output\nOne-to-many : (Image → Words. Image captioning) 고양이 사진을 input으로, 이에 대한 묘사 문장을 output\nMany-to-many : (Video → words. Video captioning) 5개 단어의 영어문장을 input으로, 3개 단어의 한글문장으로 output\n\n\n\nWord Embedding\n\n단어를 모델에 인식시키려면 숫자로 매핑하는 과정이 필요 (알파벳은 유니코드 등으로 표현이 되지만, 단어는 그렇지 못함)\n숫자로 매핑하며 단어의 다양한 관계를 나타낼 수 있도록 벡터로 표현. 이를 Word Embedding이라고 함\n\n임의의 정수로 매핑할 때, 비슷한 단어일수록 숫자의 차이가 적게 만듦 (baby 12, boy 13, child 14와 같이)\n다만 girl이라는 단어가 나온다면 문제가 생길 수 있음 (boy 옆에 이미 baby가 있음)\n해결방법 : 벡터로 만든다. 자릿수를 늘려 표현할 수 있는 관계가 많아짐 (boy[13,14], girl[14,13]과 같이 정의하면 벡터간 거리가 같다)\n다양한 관계로 나타낼 수 있도록 벡터로 표현하게 됨 (Word Embedding) (참고로 GPT는 512차원이나 768차원정도 됨)\n\n처음엔 랜덤한 벡터였지만, 학습할수록 벡터가 변경되어 단어간의 관계를 표현\n\n\n\nWord2vec\n\n가지고 있는 단어(토큰)를, 문장에 빈 칸을 두어 맞추게 함\n\n예를 들어 5만 개의 단어 중 정답인 into가 들어오지 않으면 감점 후 다시 학습(5만가지의 Classification)\n\nWord2vec이 아닌, 단어(토큰)를 주고 주변의 단어를 맞추게 하는 방법도 있지만 요즘은 많이 쓰지 않는 추세\n언어모델의 학습은, 예를 들면 위키피디아의 문장을 가져와, 문장에 빈칸을 만들고 빈칸의 단어를 정답으로 만든 뒤, cross entropy 측정 등 진행\nWord2vec학습을 마치면 단어의 관계를 묘사하게 됨"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240630/index.html#rnn",
    "href": "posts/meta-dl-creditcard-20240630/index.html#rnn",
    "title": "[M_Study_6주차] 자연어처리 및 RNN관련 기초내용",
    "section": "RNN",
    "text": "RNN\n\nRNN을 활용한 감정분석 사례(Many-to-one)\n\nRNN(Recurrent Neural Networks)이라는 딥러닝으로 시계열을 처리하는 기초적인 architecture 적용 (이미지와 달리 문장은 길이가 항상 바뀐다)\n랜덤한 \\(h_0\\)을 시작으로, 현재의 단어 \\(x_1\\)부터 더해가면 최종적으로 \\(h_t\\)에 모든 문장의 정보가 들어있음 \n현재의 단어 \\(x_t\\)와, 이전까지의 단어들 \\(h_{t-1}\\) 중 어떤 것을 더 많이 반영할지를 정하는 파라미터 \\(W_hh\\), \\(W_xh\\) \n각 부분의 \\(W_hh\\), \\(W_xh\\)는 동일한 값 (Shared parameter) 예를 들어 \\(W_hh\\)값이 다르다면 단어의 수만큼 \\(W_hh\\)가 필요하며, 문장길이가 바뀔 때마다 학습을 다르게 해야함 \nSigmoid함수를 통과하여 0.5를 기준으로 긍정/부정 등을 평가하여 감정분석하는 방식 적용\nBackpropagation(Chain rule)을 사용해 학습\n\n\n\nRNN을 활용한 Many-to-many 적용케이스 (태풍의 날짜별 피해액 등)\n\nhidden state(\\(h_1\\))마다 예측(\\(\\hat{y}\\))을 하고, 예측에 대해 실제값과 cross entropy비교 및 Backpropagation \nMulti-layer RNN \nRNN의 장단점\n\n장점\n\nInput(문장의 길이 등)이 다른 문제에 대해 대처가 가능\nParameter share로 모델의 크기가 커지지 않게 됨\n(이론적으로) 마지막 step에는 모든 정보가 들어있게 됨\n\n단점\n\n느리다\nVanishing gradient(학습이 안됨) : 미분값이 0에 수렴하여 학습이 일어나지 않음 (↔︎ Exploding gradient)\nlong-range dependency(장기기억 소실, 학습은 되지만 초반부는 잊음) : 문장 초반부의 단어는 0에 수렴하며 잊게되고, 후반부의 내용만 잘 전달됨\n\n\n\n\n\nLSTM(Long Short Term Memory)\n\n장기기억을 잊는 문제를 해결하기 위해, 보존할 수 있는 (장기기억만을 담당하는)cell gate 추가 (RNN의 핵심적 아이디어를 조금 발전시킨 것)\n문제\n\n여전히 Vanishing gradient는 존재함\nlong-range dependency도 문장이 너무 길어지면 다시 발생\n\nTransformer가 등장하며 잘 안쓰이게 되었음\n\n\n\nGRU(Gated Recurrent Units)\n\nLSTM보다 간소화되었음\nTransformer가 등장하며 잘 안쓰이게 되었음\n다만 LSTM이나 GRU 모두 선박이나 태풍의 이동경로 등의 작은 규모는 적용할만 함 (Transformer는 상당히 큰 모델임)\n\n자연어는 Transformer 사용(위의 사례도 Transformer사용시 더 좋아짐)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html",
    "href": "posts/meta-dl-creditcard-20240710/index.html",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "",
    "text": "Kaggle(Credit Card Fraud detection) Keras Tuner실습\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#데이터-전처리",
    "href": "posts/meta-dl-creditcard-20240710/index.html#데이터-전처리",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "데이터 전처리",
    "text": "데이터 전처리\n\nimport pandas as pd\nimport sqlite3\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.model_selection import train_test_split\n\n# Create a connection to the SQLite database\nconn = sqlite3.connect('creditcard.db')\n\n# Read the data from the database into a pandas DataFrame\ndf = pd.read_sql_query(\"SELECT * FROM creditcard\", conn)\n\n# Close the connection\nconn.close()\n\n# 거래액 0인 값 제거\ndf_filtered1 = df[df['Amount'] != 0].copy()\ndf_filtered1\n\n# Dataset 나누고 Scaler 적용\ndf_x = df_filtered1.drop(['Time', 'Class'], axis=1).copy()\ndf_y = df_filtered1['Class'].copy()\n\nscaler_minmax = MinMaxScaler()\ndf_x_scaled = scaler_minmax.fit_transform(df_x)\n\nscaler_std = StandardScaler()\ndf_x_scaled = scaler_std.fit_transform(df_x_scaled)\n\n# train + test\nx_train, x_test = train_test_split(df_x_scaled, test_size=0.3)\ny_train, y_test = train_test_split(df_y, test_size=0.3)\n\n# train + validation\nx_train, x_validate = train_test_split(x_train, test_size=0.3)\ny_train, y_validate = train_test_split(y_train, test_size=0.3)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---optimizer-설정-예제",
    "href": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---optimizer-설정-예제",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "Keras Tuner - Optimizer 설정 예제",
    "text": "Keras Tuner - Optimizer 설정 예제\n\nimport tensorflow as tf\nimport keras_tuner as kt\n\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential([\n        tf.keras.layers.Input((29,1)),\n        tf.keras.layers.Flatten(),\n        tf.keras.layers.Dense(128, activation='relu'),\n        tf.keras.layers.Dropout(0.2),\n        tf.keras.layers.Dense(1, activation='sigmoid') # 이진분류이므로 Sigmoid사용\n    ])\n\n    # For optimizer\n    optimizer=hp.Choice('optimizer',values=['Nadam','adam','sgd','rmsprop', 'Ftrl','Adamax','adadelta','Adagrad'])\n     \n    model.compile(optimizer=optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\ntuner=kt.RandomSearch(build_model,\n                     objective=kt.Objective('val_loss', direction='min'),\n                     overwrite=True,\n                     max_trials=9)\n\ntuner.search(x_train,y_train,epochs=5,validation_data=(x_test,y_test))\n\nTrial 2 Complete [00h 00m 56s]\nval_F1Score: 0.002878308529034257\n\nBest val_F1Score So Far: 0.002878308529034257\nTotal elapsed time: 00h 01m 57s\n\n\n\nBest Optimizer 출력\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'optimizer': 'Nadam'}"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---neuron-수-설정-예제",
    "href": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---neuron-수-설정-예제",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "Keras Tuner - Neuron 수 설정 예제",
    "text": "Keras Tuner - Neuron 수 설정 예제\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # For Neurons\n    units=hp.Int('units',min_value=5,max_value=150,step=5)\n\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n    model.add(tf.keras.layers.Dense(units, activation='relu'))\n    model.add(tf.keras.layers.Dropout(0.2))\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n\n    model.compile(optimizer='Nadam', loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\ntuner=kt.RandomSearch(build_model,\n                     objective=kt.Objective('val_loss', direction='min'),# accuracy 미사용\n                     overwrite=True,\n                     max_trials=9,\n                     project_name='randomsearch_neuron')\n\ntuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 00m 44s]\nval_loss: 0.012561993673443794\n\nBest val_loss So Far: 0.012475043535232544\nTotal elapsed time: 00h 06m 42s\n\n\n\nBest Neuron의 수 출력\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'units': 130}"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---hidden-layer수-설정-예제",
    "href": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---hidden-layer수-설정-예제",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "Keras Tuner - Hidden layer수 설정 예제",
    "text": "Keras Tuner - Hidden layer수 설정 예제\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n    model.add(tf.keras.layers.Dense(130, activation='relu'))\n\n    # For Hidden Layers\n    for i in range(hp.Int('number_of_layers',min_value=1,max_value=10)):\n        model.add(tf.keras.layers.Dense(130,activation='relu'))\n\n    model.add(tf.keras.layers.Dropout(0.2))\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n\n    model.compile(optimizer='Adamax', loss='binary_crossentropy',metrics=['F1Score'])\n    return model\n\ntuner=kt.RandomSearch(build_model,\n                     objective=kt.Objective('val_loss', direction='min'),# accuracy 미사용\n                     overwrite=True,\n                     max_trials=9,\n                     project_name='randomsearch_hidden_layer')\n\ntuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 01m 35s]\nval_loss: 0.012566009536385536\n\nBest val_loss So Far: 0.012515497393906116\nTotal elapsed time: 00h 10m 45s\n\n\n\nBest Hidden Layer의 수 출력\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'number_of_layers': 8}"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---optimizer-neuron-hidden-layer-등-동시설정-예제",
    "href": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---optimizer-neuron-hidden-layer-등-동시설정-예제",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "Keras Tuner - Optimizer, Neuron, Hidden layer 등 동시설정 예제",
    "text": "Keras Tuner - Optimizer, Neuron, Hidden layer 등 동시설정 예제\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # Input & Flatten\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n\n    # Hidden Layers\n    for i in range(hp.Int('num_layers',min_value=1,max_value=20)):\n\n        # For Dense\n        units = hp.Int('units',min_value=5,max_value=150,step=5) # For Neurons\n        activation = hp.Choice('activation'+str(i),values=['relu','elu']) # For Activation\n\n        model.add(tf.keras.layers.Dense(units, activation=activation))\n\n        # For Dropout\n        dropout_rate = hp.Choice('dropout'+str(i),values=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])\n\n        model.add(tf.keras.layers.Dropout(dropout_rate))\n\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n        \n    \n    optimizer=hp.Choice('optimizer',values=['Nadam'])\n    model.compile(optimizer=optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\nwith tf.device('/device:GPU:0'):\n    tuner=kt.RandomSearch(build_model,\n                        objective=kt.Objective('val_F1Score', direction='max'),# accuracy 미사용\n                        overwrite=True,\n                        max_trials=9,\n                        project_name='randomsearch_model')\n\n\n    tuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 01m 10s]\nval_F1Score: 0.0028702165000140667\n\nBest val_F1Score So Far: 0.0028861388564109802\nTotal elapsed time: 00h 18m 28s\n\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'num_layers': 12,\n 'units': 90,\n 'activation0': 'relu',\n 'dropout0': 0.9,\n 'optimizer': 'Nadam',\n 'activation1': 'relu',\n 'dropout1': 0.1,\n 'activation2': 'relu',\n 'dropout2': 0.1,\n 'activation3': 'relu',\n 'dropout3': 0.1,\n 'activation4': 'relu',\n 'dropout4': 0.1,\n 'activation5': 'relu',\n 'dropout5': 0.1,\n 'activation6': 'relu',\n 'dropout6': 0.1,\n 'activation7': 'relu',\n 'dropout7': 0.1,\n 'activation8': 'relu',\n 'dropout8': 0.1,\n 'activation9': 'relu',\n 'dropout9': 0.1,\n 'activation10': 'relu',\n 'dropout10': 0.1,\n 'activation11': 'relu',\n 'dropout11': 0.1}"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---모델-저장",
    "href": "posts/meta-dl-creditcard-20240710/index.html#keras-tuner---모델-저장",
    "title": "[M_Study_별도 공부] Keras Tuner",
    "section": "Keras Tuner - 모델 저장",
    "text": "Keras Tuner - 모델 저장\n\nmodel_2= tuner.get_best_models(num_models=1)[0]\nmodel_2.summary()\n\nc:\\Users\\kibok\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\keras\\src\\saving\\saving_lib.py:576: UserWarning: Skipping variable loading for optimizer 'nadam', because it has 2 variables whereas the saved optimizer has 55 variables. \n  saveable.load_own_variables(weights_store.get(inner_path))\n\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ flatten (Flatten)               │ (None, 29)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 90)             │         2,700 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout (Dropout)               │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_1 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_2 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_2 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_3 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_3 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_4 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_4 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_5 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_5 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_6 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_6 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_7 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_7 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_8 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_8 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_9 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_9 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_10 (Dense)                │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_10 (Dropout)            │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_11 (Dense)                │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_11 (Dropout)            │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_12 (Dense)                │ (None, 1)              │            91 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 92,881 (362.82 KB)\n\n\n\n Trainable params: 92,881 (362.82 KB)\n\n\n\n Non-trainable params: 0 (0.00 B)\n\n\n\n\n# 모델 학습\nhistory = model_2.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_2.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_2.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 15s 2ms/step - F1Score: 0.0031 - loss: 0.0463\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0222\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0031 - loss: 0.0144\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0032 - loss: 0.0202\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0200\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0166\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0036 - loss: 0.0167\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 12s 3ms/step - F1Score: 0.0032 - loss: 0.0131\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 11s 3ms/step - F1Score: 0.0033 - loss: 0.0229\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 11s 3ms/step - F1Score: 0.0032 - loss: 0.0216\n* 모델평가\n4334/4334 - 4s - 1ms/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 787us/step - F1Score: 0.0029 - loss: 0.0113"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240711/index.html",
    "href": "posts/meta-dl-creditcard-20240711/index.html",
    "title": "[M_Study_최종과제] 신용카드 이상거래 탐지 모델링",
    "section": "",
    "text": "Kaggle CreditCard Fraud Detection (개선예정)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240711/index.html#데이터-확인kaggle-설명",
    "href": "posts/meta-dl-creditcard-20240711/index.html#데이터-확인kaggle-설명",
    "title": "[M_Study_최종과제] 신용카드 이상거래 탐지 모델링",
    "section": "데이터 확인(Kaggle 설명)",
    "text": "데이터 확인(Kaggle 설명)\n\nKaggle 링크 : https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud\n컬럼별 정보\n\nV1~V28 : may be result of a PCA Dimensionality reduction to protect user identities and sensitive features(v1-v28)\nAmount : Transaction amount\nClass : 1 for fraudulent transactions, 0 otherwise"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240711/index.html#데이터-확인-및-전처리",
    "href": "posts/meta-dl-creditcard-20240711/index.html#데이터-확인-및-전처리",
    "title": "[M_Study_최종과제] 신용카드 이상거래 탐지 모델링",
    "section": "데이터 확인 및 전처리",
    "text": "데이터 확인 및 전처리\n\nimport pandas as pd\nimport sqlite3\n\n# Create a connection to the SQLite database\nconn = sqlite3.connect('creditcard.db')\n\n# Read the data from the database into a pandas DataFrame\ndf = pd.read_sql_query(\"SELECT * FROM creditcard\", conn)\n\n# Close the connection\nconn.close()\ndf\n\n\n\n\n\n\n\n\n\nTime\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n...\nV21\nV22\nV23\nV24\nV25\nV26\nV27\nV28\nAmount\nClass\n\n\n\n\n0\n0.0\n-1.359807\n-0.072781\n2.536347\n1.378155\n-0.338321\n0.462388\n0.239599\n0.098698\n0.363787\n...\n-0.018307\n0.277838\n-0.110474\n0.066928\n0.128539\n-0.189115\n0.133558\n-0.021053\n149.62\n0\n\n\n1\n0.0\n1.191857\n0.266151\n0.166480\n0.448154\n0.060018\n-0.082361\n-0.078803\n0.085102\n-0.255425\n...\n-0.225775\n-0.638672\n0.101288\n-0.339846\n0.167170\n0.125895\n-0.008983\n0.014724\n2.69\n0\n\n\n2\n1.0\n-1.358354\n-1.340163\n1.773209\n0.379780\n-0.503198\n1.800499\n0.791461\n0.247676\n-1.514654\n...\n0.247998\n0.771679\n0.909412\n-0.689281\n-0.327642\n-0.139097\n-0.055353\n-0.059752\n378.66\n0\n\n\n3\n1.0\n-0.966272\n-0.185226\n1.792993\n-0.863291\n-0.010309\n1.247203\n0.237609\n0.377436\n-1.387024\n...\n-0.108300\n0.005274\n-0.190321\n-1.175575\n0.647376\n-0.221929\n0.062723\n0.061458\n123.50\n0\n\n\n4\n2.0\n-1.158233\n0.877737\n1.548718\n0.403034\n-0.407193\n0.095921\n0.592941\n-0.270533\n0.817739\n...\n-0.009431\n0.798278\n-0.137458\n0.141267\n-0.206010\n0.502292\n0.219422\n0.215153\n69.99\n0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n284802\n172786.0\n-11.881118\n10.071785\n-9.834783\n-2.066656\n-5.364473\n-2.606837\n-4.918215\n7.305334\n1.914428\n...\n0.213454\n0.111864\n1.014480\n-0.509348\n1.436807\n0.250034\n0.943651\n0.823731\n0.77\n0\n\n\n284803\n172787.0\n-0.732789\n-0.055080\n2.035030\n-0.738589\n0.868229\n1.058415\n0.024330\n0.294869\n0.584800\n...\n0.214205\n0.924384\n0.012463\n-1.016226\n-0.606624\n-0.395255\n0.068472\n-0.053527\n24.79\n0\n\n\n284804\n172788.0\n1.919565\n-0.301254\n-3.249640\n-0.557828\n2.630515\n3.031260\n-0.296827\n0.708417\n0.432454\n...\n0.232045\n0.578229\n-0.037501\n0.640134\n0.265745\n-0.087371\n0.004455\n-0.026561\n67.88\n0\n\n\n284805\n172788.0\n-0.240440\n0.530483\n0.702510\n0.689799\n-0.377961\n0.623708\n-0.686180\n0.679145\n0.392087\n...\n0.265245\n0.800049\n-0.163298\n0.123205\n-0.569159\n0.546668\n0.108821\n0.104533\n10.00\n0\n\n\n284806\n172792.0\n-0.533413\n-0.189733\n0.703337\n-0.506271\n-0.012546\n-0.649617\n1.577006\n-0.414650\n0.486180\n...\n0.261057\n0.643078\n0.376777\n0.008797\n-0.473649\n-0.818267\n-0.002415\n0.013649\n217.00\n0\n\n\n\n\n284807 rows × 31 columns\n\n\n\n\n\nNull값 확인\n\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 284807 entries, 0 to 284806\nData columns (total 31 columns):\n #   Column  Non-Null Count   Dtype  \n---  ------  --------------   -----  \n 0   Time    284807 non-null  float64\n 1   V1      284807 non-null  float64\n 2   V2      284807 non-null  float64\n 3   V3      284807 non-null  float64\n 4   V4      284807 non-null  float64\n 5   V5      284807 non-null  float64\n 6   V6      284807 non-null  float64\n 7   V7      284807 non-null  float64\n 8   V8      284807 non-null  float64\n 9   V9      284807 non-null  float64\n 10  V10     284807 non-null  float64\n 11  V11     284807 non-null  float64\n 12  V12     284807 non-null  float64\n 13  V13     284807 non-null  float64\n 14  V14     284807 non-null  float64\n 15  V15     284807 non-null  float64\n 16  V16     284807 non-null  float64\n 17  V17     284807 non-null  float64\n 18  V18     284807 non-null  float64\n 19  V19     284807 non-null  float64\n 20  V20     284807 non-null  float64\n 21  V21     284807 non-null  float64\n 22  V22     284807 non-null  float64\n 23  V23     284807 non-null  float64\n 24  V24     284807 non-null  float64\n 25  V25     284807 non-null  float64\n 26  V26     284807 non-null  float64\n 27  V27     284807 non-null  float64\n 28  V28     284807 non-null  float64\n 29  Amount  284807 non-null  float64\n 30  Class   284807 non-null  int64  \ndtypes: float64(30), int64(1)\nmemory usage: 67.4 MB\n\n\n\nAmount가 0인 값 확인\n\n결제에 대한 Validation 등에 대한 기록으로 추정\n이상거래(Class 1)인 데이터도 있긴 하지만, 실질적인 돈의 이동이 없는 것을 이상거래로 잡아야할지에 대한 의문\nAmount 0인 값은 제외하는 것으로 결정\n\n\n\ndf[df['Amount']==0]\n\n\n\n\n\n\n\n\n\nTime\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n...\nV21\nV22\nV23\nV24\nV25\nV26\nV27\nV28\nAmount\nClass\n\n\n\n\n383\n282.0\n-0.356466\n0.725418\n1.971749\n0.831343\n0.369681\n-0.107776\n0.751610\n-0.120166\n-0.420675\n...\n0.020804\n0.424312\n-0.015989\n0.466754\n-0.809962\n0.657334\n-0.043150\n-0.046401\n0.0\n0\n\n\n514\n380.0\n-1.299837\n0.881817\n1.452842\n-1.293698\n-0.025105\n-1.170103\n0.861610\n-0.193934\n0.592001\n...\n-0.272563\n-0.360853\n0.223911\n0.598930\n-0.397705\n0.637141\n0.234872\n0.021379\n0.0\n0\n\n\n534\n403.0\n1.237413\n0.512365\n0.687746\n1.693872\n-0.236323\n-0.650232\n0.118066\n-0.230545\n-0.808523\n...\n-0.077543\n-0.178220\n0.038722\n0.471218\n0.289249\n0.871803\n-0.066884\n0.012986\n0.0\n0\n\n\n541\n406.0\n-2.312227\n1.951992\n-1.609851\n3.997906\n-0.522188\n-1.426545\n-2.537387\n1.391657\n-2.770089\n...\n0.517232\n-0.035049\n-0.465211\n0.320198\n0.044519\n0.177840\n0.261145\n-0.143276\n0.0\n1\n\n\n575\n430.0\n-1.860258\n-0.629859\n0.966570\n0.844632\n0.759983\n-1.481173\n-0.509681\n0.540722\n-0.733623\n...\n0.268028\n0.125515\n-0.225029\n0.586664\n-0.031598\n0.570168\n-0.043007\n-0.223739\n0.0\n0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n283719\n171817.0\n-0.750414\n0.904175\n0.996461\n0.427284\n1.720336\n0.929256\n0.794272\n0.176719\n-1.836261\n...\n0.050750\n0.115532\n-0.623995\n-0.186896\n0.733759\n2.558151\n-0.188835\n0.001654\n0.0\n0\n\n\n283782\n171870.0\n2.083677\n-0.065811\n-1.442870\n0.135416\n0.043035\n-1.306975\n0.335835\n-0.371635\n0.730560\n...\n-0.147536\n-0.246599\n0.194758\n-0.082277\n0.012887\n-0.069278\n-0.048995\n-0.065482\n0.0\n0\n\n\n283949\n172027.0\n2.132569\n-0.057836\n-1.724522\n-0.030326\n0.412146\n-0.903088\n0.345843\n-0.348132\n0.722638\n...\n-0.188739\n-0.343876\n0.105024\n-0.763831\n0.117381\n-0.027682\n-0.047514\n-0.071700\n0.0\n0\n\n\n284085\n172140.0\n-2.210521\n-1.039425\n0.189704\n-1.291932\n3.742120\n-1.665061\n3.120388\n-2.324089\n0.364926\n...\n-0.286359\n1.326003\n-0.361764\n-0.268117\n1.051309\n0.334629\n-1.930149\n-0.899888\n0.0\n0\n\n\n284770\n172759.0\n-0.822731\n1.270140\n-0.138566\n0.479620\n1.242101\n0.795218\n0.454284\n0.556038\n-1.550610\n...\n0.138766\n0.450908\n-0.192146\n-0.196218\n-0.261664\n2.372675\n-0.042743\n0.109613\n0.0\n0\n\n\n\n\n1825 rows × 31 columns\n\n\n\n\n\ndf_filtered1 = df[df['Amount'] != 0].copy()\ndf_filtered1\n\n\n\n\n\n\n\n\n\nTime\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n...\nV21\nV22\nV23\nV24\nV25\nV26\nV27\nV28\nAmount\nClass\n\n\n\n\n0\n0.0\n-1.359807\n-0.072781\n2.536347\n1.378155\n-0.338321\n0.462388\n0.239599\n0.098698\n0.363787\n...\n-0.018307\n0.277838\n-0.110474\n0.066928\n0.128539\n-0.189115\n0.133558\n-0.021053\n149.62\n0\n\n\n1\n0.0\n1.191857\n0.266151\n0.166480\n0.448154\n0.060018\n-0.082361\n-0.078803\n0.085102\n-0.255425\n...\n-0.225775\n-0.638672\n0.101288\n-0.339846\n0.167170\n0.125895\n-0.008983\n0.014724\n2.69\n0\n\n\n2\n1.0\n-1.358354\n-1.340163\n1.773209\n0.379780\n-0.503198\n1.800499\n0.791461\n0.247676\n-1.514654\n...\n0.247998\n0.771679\n0.909412\n-0.689281\n-0.327642\n-0.139097\n-0.055353\n-0.059752\n378.66\n0\n\n\n3\n1.0\n-0.966272\n-0.185226\n1.792993\n-0.863291\n-0.010309\n1.247203\n0.237609\n0.377436\n-1.387024\n...\n-0.108300\n0.005274\n-0.190321\n-1.175575\n0.647376\n-0.221929\n0.062723\n0.061458\n123.50\n0\n\n\n4\n2.0\n-1.158233\n0.877737\n1.548718\n0.403034\n-0.407193\n0.095921\n0.592941\n-0.270533\n0.817739\n...\n-0.009431\n0.798278\n-0.137458\n0.141267\n-0.206010\n0.502292\n0.219422\n0.215153\n69.99\n0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n284802\n172786.0\n-11.881118\n10.071785\n-9.834783\n-2.066656\n-5.364473\n-2.606837\n-4.918215\n7.305334\n1.914428\n...\n0.213454\n0.111864\n1.014480\n-0.509348\n1.436807\n0.250034\n0.943651\n0.823731\n0.77\n0\n\n\n284803\n172787.0\n-0.732789\n-0.055080\n2.035030\n-0.738589\n0.868229\n1.058415\n0.024330\n0.294869\n0.584800\n...\n0.214205\n0.924384\n0.012463\n-1.016226\n-0.606624\n-0.395255\n0.068472\n-0.053527\n24.79\n0\n\n\n284804\n172788.0\n1.919565\n-0.301254\n-3.249640\n-0.557828\n2.630515\n3.031260\n-0.296827\n0.708417\n0.432454\n...\n0.232045\n0.578229\n-0.037501\n0.640134\n0.265745\n-0.087371\n0.004455\n-0.026561\n67.88\n0\n\n\n284805\n172788.0\n-0.240440\n0.530483\n0.702510\n0.689799\n-0.377961\n0.623708\n-0.686180\n0.679145\n0.392087\n...\n0.265245\n0.800049\n-0.163298\n0.123205\n-0.569159\n0.546668\n0.108821\n0.104533\n10.00\n0\n\n\n284806\n172792.0\n-0.533413\n-0.189733\n0.703337\n-0.506271\n-0.012546\n-0.649617\n1.577006\n-0.414650\n0.486180\n...\n0.261057\n0.643078\n0.376777\n0.008797\n-0.473649\n-0.818267\n-0.002415\n0.013649\n217.00\n0\n\n\n\n\n282982 rows × 31 columns\n\n\n\n\n\ndf_filtered1[df_filtered1['Amount']==0]\n\n\n\n\n\n\n\n\n\nTime\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n...\nV21\nV22\nV23\nV24\nV25\nV26\nV27\nV28\nAmount\nClass\n\n\n\n\n\n\n0 rows × 31 columns\n\n\n\n\n\nLabel값(이상거래 비중) 확인\n\nImbalance한 경우, Accuracy는 성능측정에 한계가 있으므로, 다른 지표를 사용\nF1-Score 사용 예정\n\n\n\ndf_filtered1[\"Class\"].value_counts(normalize=True)\n\nClass\n0    0.998357\n1    0.001643\nName: proportion, dtype: float64\n\n\n\nX와 Y로 나누고, Scaler 적용(StandardScaler, MinMaxScaler)\n\n\ndf_x = df_filtered1.drop(['Time', 'Class'], axis=1).copy()\ndf_y = df_filtered1['Class'].copy()\n\n\ndf_x.shape, df_y.shape\n\n((282982, 29), (282982,))\n\n\n\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\n\nscaler_minmax = MinMaxScaler()\ndf_x_scaled = scaler_minmax.fit_transform(df_x)\n\nscaler_std = StandardScaler()\ndf_x_scaled = scaler_std.fit_transform(df_x_scaled)\n\n\ndf_x_scaled\n\narray([[-0.6947547 , -0.04287463,  1.67720049, ...,  0.33079262,\n        -0.06431265,  0.24200481],\n       [ 0.60928   ,  0.16247803,  0.11211972, ..., -0.02292114,\n         0.0439881 , -0.34378459],\n       [-0.6940121 , -0.81075824,  1.17321784, ..., -0.13798659,\n        -0.18145722,  1.15515532],\n       ...,\n       [ 0.98117703, -0.18130206, -2.14391593, ...,  0.01042466,\n        -0.08098516, -0.08388116],\n       [-0.12269922,  0.32263185,  0.46611873, ...,  0.26940666,\n         0.31584664, -0.31464064],\n       [-0.27242357, -0.11373381,  0.46666497, ..., -0.0066233 ,\n         0.04073321,  0.51063947]])\n\n\n\ntrain, test데이터 나누기\n\n\nfrom sklearn.model_selection import train_test_split\n\n# train + test\nx_train, x_test = train_test_split(df_x_scaled, test_size=0.3)\ny_train, y_test = train_test_split(df_y, test_size=0.3)\n\nprint('Train과 Test로 나누기')\nprint(x_train.shape, x_test.shape)\nprint(x_train.shape, y_test.shape)\n\n# train + validation\nx_train, x_validate = train_test_split(x_train, test_size=0.3)\ny_train, y_validate = train_test_split(y_train, test_size=0.3)\n\nprint()\nprint('Train과 Validation으로 나누기')\nprint(x_train.shape, x_validate.shape, x_test.shape)\nprint(y_train.shape, y_validate.shape, y_test.shape)\n\nTrain과 Test로 나누기\n(198087, 29) (84895, 29)\n(198087, 29) (84895,)\n\nTrain과 Validation으로 나누기\n(138660, 29) (59427, 29) (84895, 29)\n(138660,) (59427,) (84895,)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240711/index.html#모델링",
    "href": "posts/meta-dl-creditcard-20240711/index.html#모델링",
    "title": "[M_Study_최종과제] 신용카드 이상거래 탐지 모델링",
    "section": "모델링",
    "text": "모델링\n\n모델링 (기초 딥러닝)\n\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n\n# 모델링\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Input((29,1)),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation='relu'),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(1, activation='sigmoid') # 이진분류이므로 Sigmoid사용\n])\n\nmodel.compile(optimizer='adam',\n              loss='binary_crossentropy', # 0과 1의 이진분류이므로 binary_crossentropy 사용\n              metrics=['F1Score'])\n\n# 모델 학습\nhistory = model.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 4s 763us/step - F1Score: 0.0037 - loss: 0.0360\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 776us/step - F1Score: 0.0036 - loss: 0.0140\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 761us/step - F1Score: 0.0035 - loss: 0.0129\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 730us/step - F1Score: 0.0033 - loss: 0.0123\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 718us/step - F1Score: 0.0036 - loss: 0.0131\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 728us/step - F1Score: 0.0033 - loss: 0.0119\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 740us/step - F1Score: 0.0036 - loss: 0.0128\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 730us/step - F1Score: 0.0033 - loss: 0.0118\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 726us/step - F1Score: 0.0033 - loss: 0.0114\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 3s 729us/step - F1Score: 0.0035 - loss: 0.0122\n* 모델평가\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n\n\n\n모델링 (Keras tuner[Hyper parameter세팅])\n\nHidden Layer의 수\nNeuron의 수\nActivation fuction : ReLU, ELU 중 택1\n\nReaky ReLU도 고려대상에 넣고싶었지만, String이 아닌 별도 함수로 적용해야해서 제외\n\nOptimizer : 같은 조건으로 2개의 Optimizer(Adam, Nadam)로 먼저 돌렸다가 Tuner에게 추천받은 Nadam으로 설정\n\n\nimport keras_tuner as kt\n\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # Input & Flatten\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n\n    # Hidden Layers\n    for i in range(hp.Int('num_layers',min_value=1,max_value=20)):\n\n        # For Dense\n        units = hp.Int('units',min_value=5,max_value=150,step=5) # For Neurons\n        activation = hp.Choice('activation'+str(i),values=['relu','elu']) # For Activation\n\n        model.add(tf.keras.layers.Dense(units, activation=activation))\n\n        # For Dropout\n        dropout_rate = hp.Choice('dropout'+str(i),values=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])\n\n        model.add(tf.keras.layers.Dropout(dropout_rate))\n\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n        \n    \n    optimizer=hp.Choice('optimizer',values=['Nadam'])\n    model.compile(optimizer=optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\nwith tf.device('/device:GPU:0'):\n    tuner=kt.RandomSearch(build_model,\n                        objective=kt.Objective('val_F1Score', direction='max'),# accuracy 미사용\n                        overwrite=True,\n                        max_trials=9,\n                        project_name='randomsearch_model')\n\n\n    tuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 01m 10s]\nval_F1Score: 0.0028702165000140667\n\nBest val_F1Score So Far: 0.0028861388564109802\nTotal elapsed time: 00h 18m 28s\n\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'num_layers': 12,\n 'units': 90,\n 'activation0': 'relu',\n 'dropout0': 0.9,\n 'optimizer': 'Nadam',\n 'activation1': 'relu',\n 'dropout1': 0.1,\n 'activation2': 'relu',\n 'dropout2': 0.1,\n 'activation3': 'relu',\n 'dropout3': 0.1,\n 'activation4': 'relu',\n 'dropout4': 0.1,\n 'activation5': 'relu',\n 'dropout5': 0.1,\n 'activation6': 'relu',\n 'dropout6': 0.1,\n 'activation7': 'relu',\n 'dropout7': 0.1,\n 'activation8': 'relu',\n 'dropout8': 0.1,\n 'activation9': 'relu',\n 'dropout9': 0.1,\n 'activation10': 'relu',\n 'dropout10': 0.1,\n 'activation11': 'relu',\n 'dropout11': 0.1}\n\n\n\nmodel_2= tuner.get_best_models(num_models=1)[0]\nmodel_2.summary()\n\nc:\\Users\\kibok\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\keras\\src\\saving\\saving_lib.py:576: UserWarning: Skipping variable loading for optimizer 'nadam', because it has 2 variables whereas the saved optimizer has 55 variables. \n  saveable.load_own_variables(weights_store.get(inner_path))\n\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ flatten (Flatten)               │ (None, 29)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 90)             │         2,700 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout (Dropout)               │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_1 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_2 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_2 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_3 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_3 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_4 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_4 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_5 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_5 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_6 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_6 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_7 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_7 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_8 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_8 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_9 (Dense)                 │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_9 (Dropout)             │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_10 (Dense)                │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_10 (Dropout)            │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_11 (Dense)                │ (None, 90)             │         8,190 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_11 (Dropout)            │ (None, 90)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_12 (Dense)                │ (None, 1)              │            91 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 92,881 (362.82 KB)\n\n\n\n Trainable params: 92,881 (362.82 KB)\n\n\n\n Non-trainable params: 0 (0.00 B)\n\n\n\n\n# 모델 학습\nhistory = model_2.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_2.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_2.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 15s 2ms/step - F1Score: 0.0031 - loss: 0.0463\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0222\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0031 - loss: 0.0144\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0032 - loss: 0.0202\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0200\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0166\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0036 - loss: 0.0167\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 12s 3ms/step - F1Score: 0.0032 - loss: 0.0131\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 11s 3ms/step - F1Score: 0.0033 - loss: 0.0229\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 11s 3ms/step - F1Score: 0.0032 - loss: 0.0216\n* 모델평가\n4334/4334 - 4s - 1ms/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 787us/step - F1Score: 0.0029 - loss: 0.0113\n\n\n\nF1Score 및 Loss 개선 비교\n\n모델평가(기본) \n\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n모델평가(Tuner) \n\n4334/4334 - 4s - 860us/step - F1Score: 0.0034 - loss: 0.0175\n2653/2653 - 2s - 862us/step - F1Score: 0.0029 - loss: 0.0164\n\n\n\n\n\n모델링 (Keras tuner + Initialization 추가)\n\nHeNormal (Kaiming) 적용\n\n수업시간에 배운 Random/Xavier/ Kaiming/MSRA Initialization for ReLU에 대해 검색해 봄\n\n미설정시 기본값은 Xavier(GlorotNormal)로 적용된다고 함\nPytorch와 Tensorflow에서의 Initialization 명칭이 다름\n\nHeNormal(Tensorflow) / Kaiming (Pytorch)\nGlorotNormal(Tensorflow) / XavierNormal (Pytorch)\nRandom Normall(Tensorflow) / Random(Pytorch)\n\nInnitialization은 kernel_initializer(Weight)뿐 아니라 bias_initializer(Bias)도 있음\n\n\n\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # Input & Flatten\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n\n    # Hidden Layers\n    for i in range(hp.Int('num_layers',min_value=1,max_value=20)):\n\n        # For Dense\n        units = hp.Int('units',min_value=5,max_value=150,step=5) # For Neurons\n        activation = hp.Choice('activation'+str(i),values=['relu','elu']) # For Activation\n\n        model.add(tf.keras.layers.Dense(units, activation=activation,\n                                        # 기본값은 glorot_uniform(Xavier), He(Kaiming)적용\n                                        kernel_initializer=tf.keras.initializers.HeNormal())) \n\n        # For Dropout\n        dropout_rate = hp.Choice('dropout'+str(i),values=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])\n\n        model.add(tf.keras.layers.Dropout(dropout_rate))\n\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n        \n    \n    optimizer=hp.Choice('optimizer',values=['Nadam'])\n    model.compile(optimizer=optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\nwith tf.device('/device:GPU:0'):\n    tuner=kt.RandomSearch(build_model,\n                        objective=kt.Objective('val_F1Score', direction='min'),# accuracy 미사용\n                        overwrite=True,\n                        max_trials=9,\n                        project_name='randomsearch_model_+initialize')\n\n\n    tuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 01m 32s]\nval_F1Score: 0.002870013704523444\n\nBest val_F1Score So Far: 0.0\nTotal elapsed time: 00h 21m 15s\n\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'num_layers': 17,\n 'units': 145,\n 'activation0': 'elu',\n 'dropout0': 0.9,\n 'optimizer': 'Nadam',\n 'activation1': 'relu',\n 'dropout1': 0.9,\n 'activation2': 'relu',\n 'dropout2': 0.8,\n 'activation3': 'elu',\n 'dropout3': 0.9,\n 'activation4': 'elu',\n 'dropout4': 0.6,\n 'activation5': 'elu',\n 'dropout5': 0.9,\n 'activation6': 'relu',\n 'dropout6': 0.4,\n 'activation7': 'relu',\n 'dropout7': 0.2,\n 'activation8': 'elu',\n 'dropout8': 0.7,\n 'activation9': 'relu',\n 'dropout9': 0.3,\n 'activation10': 'elu',\n 'dropout10': 0.4,\n 'activation11': 'relu',\n 'dropout11': 0.8,\n 'activation12': 'elu',\n 'dropout12': 0.2,\n 'activation13': 'relu',\n 'dropout13': 0.1,\n 'activation14': 'relu',\n 'dropout14': 0.1,\n 'activation15': 'relu',\n 'dropout15': 0.1,\n 'activation16': 'relu',\n 'dropout16': 0.1}\n\n\n\nmodel_3= tuner.get_best_models(num_models=1)[0]\nmodel_3.summary()\n\nc:\\Users\\kibok\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\keras\\src\\saving\\saving_lib.py:576: UserWarning: Skipping variable loading for optimizer 'nadam', because it has 2 variables whereas the saved optimizer has 75 variables. \n  saveable.load_own_variables(weights_store.get(inner_path))\n\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ flatten (Flatten)               │ (None, 29)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 145)            │         4,350 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout (Dropout)               │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_1 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_2 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_2 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_3 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_3 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_4 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_4 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_5 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_5 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_6 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_6 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_7 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_7 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_8 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_8 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_9 (Dense)                 │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_9 (Dropout)             │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_10 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_10 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_11 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_11 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_12 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_12 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_13 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_13 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_14 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_14 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_15 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_15 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_16 (Dense)                │ (None, 145)            │        21,170 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_16 (Dropout)            │ (None, 145)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_17 (Dense)                │ (None, 1)              │           146 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 343,216 (1.31 MB)\n\n\n\n Trainable params: 343,216 (1.31 MB)\n\n\n\n Non-trainable params: 0 (0.00 B)\n\n\n\n\n# 모델 학습\nhistory = model_3.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_3.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_3.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 26s 5ms/step - F1Score: 0.0031 - loss: 0.3784\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 21s 5ms/step - F1Score: 0.0033 - loss: 0.0700\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 19s 4ms/step - F1Score: 0.0031 - loss: 0.1938\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 20s 5ms/step - F1Score: 0.0032 - loss: 0.2460\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 18s 4ms/step - F1Score: 0.0035 - loss: 0.2332\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 19s 4ms/step - F1Score: 0.0038 - loss: 0.0661\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 18s 4ms/step - F1Score: 0.0033 - loss: 0.0123\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 20s 5ms/step - F1Score: 0.0033 - loss: 0.0124\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 20s 5ms/step - F1Score: 0.0031 - loss: 0.0583\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 20s 4ms/step - F1Score: 0.0033 - loss: 0.4909\n* 모델평가\n4334/4334 - 6s - 1ms/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 4s - 1ms/step - F1Score: 0.0029 - loss: 0.0109\n\n\n\nF1Score 및 Loss 개선 비교\n\n모델평가(기본) \n\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n모델평가(Tuner) \n\n4334/4334 - 4s - 860us/step - F1Score: 0.0034 - loss: 0.0175\n2653/2653 - 2s - 862us/step - F1Score: 0.0029 - loss: 0.0164\n\n모델평가(Tuner + Kaiming Initialization) \n\n4334/4334 - 6s - 1ms/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 4s - 1ms/step - F1Score: 0.0029 - loss: 0.0109\n\n\n\n\n\n모델링 (Keras tuner + Batch Normalization 추가)\n\nActivation layer 전에 Batch normalization 적용\n\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # Input & Flatten\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n\n    # Hidden Layers\n    for i in range(hp.Int('num_layers',min_value=1,max_value=20)):\n\n        # For Dense\n        units = hp.Int('units',min_value=5,max_value=150,step=5) # For Neurons\n        activation = hp.Choice('activation'+str(i),values=['relu','elu']) # For Activation\n\n        model.add(tf.keras.layers.Dense(units, activation=activation,\n                                        # 기본값은 glorot_uniform(Xavier), He는 Kaiming\n                                        kernel_initializer=tf.keras.initializers.HeNormal())) \n        \n        # Add Batch Normalization\n        model.add(tf.keras.layers.BatchNormalization()) # Layer통과후 & Activation 전\n        \n        # For Dropout\n        dropout_rate = hp.Choice('dropout'+str(i),values=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])\n\n        model.add(tf.keras.layers.Dropout(dropout_rate))\n\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n        \n    \n    optimizer=hp.Choice('optimizer',values=['Nadam'])\n    model.compile(optimizer=optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n    \n    return model\n\nwith tf.device('/device:GPU:0'):\n    tuner=kt.RandomSearch(build_model,\n                        objective=kt.Objective('val_F1Score', direction='min'),# accuracy 미사용\n                        overwrite=True,\n                        max_trials=9,\n                        project_name='randomsearch_model_+initialize+batchnormalize')\n\n\n    tuner.search(x_train,y_train,epochs=10,validation_data=(x_test,y_test))\n\nTrial 9 Complete [00h 05m 00s]\nval_F1Score: 0.003198833204805851\n\nBest val_F1Score So Far: 0.003198833204805851\nTotal elapsed time: 00h 25m 05s\n\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'num_layers': 3,\n 'units': 5,\n 'activation0': 'relu',\n 'dropout0': 0.2,\n 'optimizer': 'Nadam',\n 'activation1': 'relu',\n 'dropout1': 0.1,\n 'activation2': 'relu',\n 'dropout2': 0.1}\n\n\n\nmodel_4= tuner.get_best_models(num_models=1)[0]\nmodel_4.summary()\n\nc:\\Users\\kibok\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\keras\\src\\saving\\saving_lib.py:576: UserWarning: Skipping variable loading for optimizer 'nadam', because it has 2 variables whereas the saved optimizer has 31 variables. \n  saveable.load_own_variables(weights_store.get(inner_path))\n\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ flatten (Flatten)               │ (None, 29)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 5)              │           150 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization             │ (None, 5)              │            20 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout (Dropout)               │ (None, 5)              │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 5)              │            30 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_1           │ (None, 5)              │            20 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_1 (Dropout)             │ (None, 5)              │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_2 (Dense)                 │ (None, 5)              │            30 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_2           │ (None, 5)              │            20 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_2 (Dropout)             │ (None, 5)              │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_3 (Dense)                 │ (None, 1)              │             6 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 276 (1.08 KB)\n\n\n\n Trainable params: 246 (984.00 B)\n\n\n\n Non-trainable params: 30 (120.00 B)\n\n\n\n\n# 모델 학습\nhistory = model_4.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 13s 2ms/step - F1Score: 0.0038 - loss: 0.0143\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0030 - loss: 0.0116\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0033 - loss: 0.0125\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 9s 2ms/step - F1Score: 0.0034 - loss: 0.0130\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0126\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0035 - loss: 0.0132\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0130\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0036 - loss: 0.0133\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0029 - loss: 0.0111\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0035 - loss: 0.0131\n* 모델평가\n4334/4334 - 3s - 788us/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 757us/step - F1Score: 0.0029 - loss: 0.0110\n\n\n\nF1Score 및 Loss 개선 비교\n\n모델평가(기본) \n\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n모델평가(Tuner) \n\n4334/4334 - 4s - 860us/step - F1Score: 0.0034 - loss: 0.0175\n2653/2653 - 2s - 862us/step - F1Score: 0.0029 - loss: 0.0164\n\n모델평가(Tuner + Kaiming Initialization) \n\n4334/4334 - 6s - 1ms/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 4s - 1ms/step - F1Score: 0.0029 - loss: 0.0109\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization) \n\n4334/4334 - 3s - 788us/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 757us/step - F1Score: 0.0029 - loss: 0.0110\n\n\n\n\n\n모델 중간 저장\n\n이후 부터는 Learning rate 등의 변경만 있을 예정으로, Tuner를 사용하지 않고 모델을 저장했다가 사용\n\n\nmodel_4 = tuner.get_best_models(num_models=1)[0]\nmodel_4.save('model_4.keras')\n\n\n\n모델링 (현재 모델에서 Learning rate별 비교 : 0.1, 0.01, 0.05)\n\nLearning rate : 0.1\n\nLoss값이 튀는 상황으로 줄여야 할 것으로 보임\n\n\n# 새로운 학습률 설정\nnew_learning_rate = 0.1\n\nmodel_4 = keras.models.load_model('model_4.keras')\nnew_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\nmodel_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\nhistory = model_4.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 9s 2ms/step - F1Score: 0.0038 - loss: 0.0155\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0036 - loss: 0.0142\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0035 - loss: 0.0136\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0034 - loss: 0.0137\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0143\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0036 - loss: 0.0144\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0031 - loss: 0.0120\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0037 - loss: 0.0145\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0036 - loss: 0.0141\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0034 - loss: 0.0131\n* 모델평가\n4334/4334 - 3s - 639us/step - F1Score: 0.0034 - loss: 0.0130\n2653/2653 - 2s - 629us/step - F1Score: 0.0032 - loss: 0.0127\n\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nLearning rate : 0.01\n\nLoss값이 원만하게 하락\n\n\n# 새로운 학습률 설정\nnew_learning_rate = 0.01\n\nmodel_4 = keras.models.load_model('model_4.keras')\nnew_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\nmodel_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\nhistory = model_4.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 1ms/step - F1Score: 0.0034 - loss: 0.0137\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0031 - loss: 0.0122\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0037 - loss: 0.0137\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0029 - loss: 0.0114\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0128\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0127\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0126\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0033 - loss: 0.0123\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0037 - loss: 0.0134\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0033 - loss: 0.0122\n* 모델평가\n4334/4334 - 3s - 649us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 658us/step - F1Score: 0.0032 - loss: 0.0121\n\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nLearning rate : 0.05\n\nLoss값이 조금 위아래로 움직임.\n향후 현재의 10회가 아닌 1000회 epoch을 돌려볼 것이므로 학습시간을 고려새 0.01이 아닌 0.05로 적용하는 것을 고려\n\n\n# 새로운 학습률 설정\nnew_learning_rate = 0.05\n\nmodel_4 = keras.models.load_model('model_4.keras')\nnew_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\nmodel_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\nhistory = model_4.fit(x_train, y_train, epochs=10)\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 1ms/step - F1Score: 0.0032 - loss: 0.0137\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0120\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0119\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0130\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0131\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0033 - loss: 0.0124\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0033 - loss: 0.0126\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0128\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0038 - loss: 0.0141\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0032 - loss: 0.0119\n* 모델평가\n4334/4334 - 3s - 666us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 648us/step - F1Score: 0.0032 - loss: 0.0119\n\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n추가적용 : Learning rate scheduler\n\nLearning rate 0.05를 적용하기로 했으므로, 동일한 기준인 10 epoch중 loss가 증가했던 구간부터 rate 변경 적용 #### 기본 Learning rate scheduler\n적용 전과 비교했을 때, Loss가 전반적으로 우하향 하는 추세를 보여줌\n\n\nfrom tensorflow.keras.callbacks import LearningRateScheduler\nimport keras\nimport matplotlib.pyplot as plt\n\n\ndef scheduler(epoch, lr):\n    if epoch &lt; 5:\n        return float(lr)\n    else:\n        return float(lr * tf.exp(-0.1))\n\nlr_scheduler = LearningRateScheduler(scheduler, verbose=1)\n\n# 새로운 학습률 설정\nnew_learning_rate = 0.05\n\nmodel_4 = keras.models.load_model('model_4.keras')\nnew_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\nmodel_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\n# 모델 학습\nhistory = model_4.fit(x_train, y_train, epochs=10, \n                      callbacks=[lr_scheduler])\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\n\nEpoch 1: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 1ms/step - F1Score: 0.0032 - loss: 0.0134 - learning_rate: 0.0500\n\nEpoch 2: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0134 - learning_rate: 0.0500\n\nEpoch 3: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0031 - loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 4: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 5s 1ms/step - F1Score: 0.0033 - loss: 0.0125 - learning_rate: 0.0500\n\nEpoch 5: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0031 - loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 6: LearningRateScheduler setting learning rate to 0.04524187371134758.\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0129 - learning_rate: 0.0452\n\nEpoch 7: LearningRateScheduler setting learning rate to 0.04093654081225395.\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0031 - loss: 0.0119 - learning_rate: 0.0409\n\nEpoch 8: LearningRateScheduler setting learning rate to 0.037040915340185165.\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0037 - loss: 0.0137 - learning_rate: 0.0370\n\nEpoch 9: LearningRateScheduler setting learning rate to 0.03351600840687752.\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0127 - learning_rate: 0.0335\n\nEpoch 10: LearningRateScheduler setting learning rate to 0.030326539650559425.\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0127 - learning_rate: 0.0303\n* 모델평가\n4334/4334 - 3s - 643us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 611us/step - F1Score: 0.0032 - loss: 0.0120\n\n\n\n적용 전과 비교했을 때, Loss가 전반적으로 우하향 하는 추세를 보여줌\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nCosine Learning rate scheduler\n\nChatGPT의 도움을 받아 기존의 scheduler코드를 수업 때 배웠던 Cosine decay로 변경\nCosine decay 적용 전보다 더 부드럽게 우하향하는 추세를 보여줌\n\n\nimport numpy as np\n\ntotal_epoch_value = 10\n\ndef scheduler(epoch, lr):\n    # Compute the cosine decay factor\n    cosine_decay = 0.5 * (1 + np.cos(np.pi * epoch / total_epoch_value))\n    # Update learning rate\n    new_lr = lr * cosine_decay\n    return float(new_lr)\n\nlr_scheduler = LearningRateScheduler(scheduler, verbose=1)\n\n# 새로운 학습률 설정\nnew_learning_rate = 0.05\n\nmodel_4 = keras.models.load_model('model_4.keras')\nnew_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\nmodel_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\n# 모델 학습\nhistory = model_4.fit(x_train, y_train, epochs=total_epoch_value, \n                      callbacks=[lr_scheduler])\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\n\nEpoch 1: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 1/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 9s 1ms/step - F1Score: 0.0036 - loss: 0.0149 - learning_rate: 0.0500\n\nEpoch 2: LearningRateScheduler setting learning rate to 0.048776413634204034.\nEpoch 2/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0130 - learning_rate: 0.0488\n\nEpoch 3: LearningRateScheduler setting learning rate to 0.04411868114727063.\nEpoch 3/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0033 - loss: 0.0123 - learning_rate: 0.0441\n\nEpoch 4: LearningRateScheduler setting learning rate to 0.03502549477486741.\nEpoch 4/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0132 - learning_rate: 0.0350\n\nEpoch 5: LearningRateScheduler setting learning rate to 0.022924484773646628.\nEpoch 5/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0035 - loss: 0.0129 - learning_rate: 0.0229\n\nEpoch 6: LearningRateScheduler setting learning rate to 0.011462242342531681.\nEpoch 6/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0030 - loss: 0.0114 - learning_rate: 0.0115\n\nEpoch 7: LearningRateScheduler setting learning rate to 0.003960107332522642.\nEpoch 7/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 1ms/step - F1Score: 0.0032 - loss: 0.0119 - learning_rate: 0.0040\n\nEpoch 8: LearningRateScheduler setting learning rate to 0.0008162073473510564.\nEpoch 8/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0032 - loss: 0.0119 - learning_rate: 8.1621e-04\n\nEpoch 9: LearningRateScheduler setting learning rate to 7.794086367885386e-05.\nEpoch 9/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0032 - loss: 0.0120 - learning_rate: 7.7941e-05\n\nEpoch 10: LearningRateScheduler setting learning rate to 1.9073487425812585e-06.\nEpoch 10/10\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 6s 1ms/step - F1Score: 0.0034 - loss: 0.0126 - learning_rate: 1.9073e-06\n* 모델평가\n4334/4334 - 3s - 640us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 670us/step - F1Score: 0.0032 - loss: 0.0119\n\n\n\nCosine decay 적용 전보다 더 부드럽게 우하향하는 추세를 보여줌\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nF1Score 및 Loss 개선 비교\n\n모델평가(기본) \n\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n모델평가(Tuner) \n\n4334/4334 - 4s - 860us/step - F1Score: 0.0034 - loss: 0.0175\n2653/2653 - 2s - 862us/step - F1Score: 0.0029 - loss: 0.0164\n\n모델평가(Tuner + Kaiming Initialization) \n\n4334/4334 - 6s - 1ms/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 4s - 1ms/step - F1Score: 0.0029 - loss: 0.0109\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization) \n\n4334/4334 - 3s - 788us/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 757us/step - F1Score: 0.0029 - loss: 0.0110\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization + Learning rate Scheduling) \n\n4334/4334 - 3s - 640us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 670us/step - F1Score: 0.0032 - loss: 0.0119\n\n\n\n\n\n추가적용 : EarlyStopping with patience\n\nepoch 1000회로 세팅\npatience 200으로 세팅\n\n\nfrom tensorflow.keras.callbacks import EarlyStopping\nimport numpy as np\n\ntotal_epoch_value = 1000\n\ndef scheduler(epoch, lr):\n    # Compute the cosine decay factor\n    cosine_decay = 0.5 * (1 + np.cos(np.pi * epoch / total_epoch_value))\n    # Update learning rate\n    new_lr = lr * cosine_decay\n    return float(new_lr)\n\n\nwith tf.device('/device:GPU:0'):\n    lr_scheduler = LearningRateScheduler(scheduler, verbose=1)\n    es = EarlyStopping(monitor='F1Score', mode='max', verbose=1, patience=200)\n\n    # 새로운 학습률 설정\n    new_learning_rate = 0.05\n\n    model_4 = keras.models.load_model('model_4.keras')\n    new_optimizer = tf.keras.optimizers.Nadam(learning_rate=new_learning_rate)\n    model_4.compile(optimizer=new_optimizer, loss='binary_crossentropy',metrics=['F1Score'])\n\n    # 모델 학습\n    history = model_4.fit(x_train, y_train, epochs=total_epoch_value, \n                        callbacks=[lr_scheduler, es],\n                        validation_data=(x_test,y_test))\n\n# 모델 평가\nprint('* 모델평가')\nloss, f1score = model_4.evaluate(x_train, y_train, verbose=2)\nloss, f1score = model_4.evaluate(x_test, y_test, verbose=2)\n\n\nEpoch 1: LearningRateScheduler setting learning rate to 0.05000000074505806.\nEpoch 1/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0031 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0500\n\nEpoch 2: LearningRateScheduler setting learning rate to 0.049999877375102676.\nEpoch 2/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0500\n\nEpoch 3: LearningRateScheduler setting learning rate to 0.04999938433308759.\nEpoch 3/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0500\n\nEpoch 4: LearningRateScheduler setting learning rate to 0.04999827576351572.\nEpoch 4/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0038 - loss: 0.0142 - val_F1Score: 0.0032 - val_loss: 0.0126 - learning_rate: 0.0500\n\nEpoch 5: LearningRateScheduler setting learning rate to 0.04999630210880771.\nEpoch 5/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0138 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0500\n\nEpoch 6: LearningRateScheduler setting learning rate to 0.049993217571968625.\nEpoch 6/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 7: LearningRateScheduler setting learning rate to 0.04998877640343745.\nEpoch 7/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 8: LearningRateScheduler setting learning rate to 0.04998273291321625.\nEpoch 8/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0500\n\nEpoch 9: LearningRateScheduler setting learning rate to 0.04997484148299723.\nEpoch 9/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 10: LearningRateScheduler setting learning rate to 0.04996485285374156.\nEpoch 10/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0029 - loss: 0.0111 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0500\n\nEpoch 11: LearningRateScheduler setting learning rate to 0.049952525311787795.\nEpoch 11/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0500\n\nEpoch 12: LearningRateScheduler setting learning rate to 0.04993761352668951.\nEpoch 12/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0499\n\nEpoch 13: LearningRateScheduler setting learning rate to 0.04991987228817006.\nEpoch 13/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0499\n\nEpoch 14: LearningRateScheduler setting learning rate to 0.04989906024197024.\nEpoch 14/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0499\n\nEpoch 15: LearningRateScheduler setting learning rate to 0.04987493245373588.\nEpoch 15/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0499\n\nEpoch 16: LearningRateScheduler setting learning rate to 0.04984724786871271.\nEpoch 16/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0114 - val_F1Score: 0.0032 - val_loss: 0.0123 - learning_rate: 0.0498\n\nEpoch 17: LearningRateScheduler setting learning rate to 0.04981576932241795.\nEpoch 17/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0498\n\nEpoch 18: LearningRateScheduler setting learning rate to 0.049780256105761714.\nEpoch 18/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0137 - val_F1Score: 0.0032 - val_loss: 0.0123 - learning_rate: 0.0498\n\nEpoch 19: LearningRateScheduler setting learning rate to 0.049740471422997326.\nEpoch 19/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0497\n\nEpoch 20: LearningRateScheduler setting learning rate to 0.049696178679942346.\nEpoch 20/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0497\n\nEpoch 21: LearningRateScheduler setting learning rate to 0.049647145217296636.\nEpoch 21/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0496\n\nEpoch 22: LearningRateScheduler setting learning rate to 0.04959314232045517.\nEpoch 22/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0133 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0496\n\nEpoch 23: LearningRateScheduler setting learning rate to 0.04953394150819476.\nEpoch 23/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0495\n\nEpoch 24: LearningRateScheduler setting learning rate to 0.049469314543987404.\nEpoch 24/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0495\n\nEpoch 25: LearningRateScheduler setting learning rate to 0.04939904088730174.\nEpoch 25/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0494\n\nEpoch 26: LearningRateScheduler setting learning rate to 0.049322900261303024.\nEpoch 26/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0493\n\nEpoch 27: LearningRateScheduler setting learning rate to 0.0492406763828536.\nEpoch 27/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0039 - loss: 0.0144 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0492\n\nEpoch 28: LearningRateScheduler setting learning rate to 0.04915215697099108.\nEpoch 28/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0492\n\nEpoch 29: LearningRateScheduler setting learning rate to 0.04905713747321047.\nEpoch 29/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0135 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0491\n\nEpoch 30: LearningRateScheduler setting learning rate to 0.048955409918060896.\nEpoch 30/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0490\n\nEpoch 31: LearningRateScheduler setting learning rate to 0.04884677779609719.\nEpoch 31/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0137 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0488\n\nEpoch 32: LearningRateScheduler setting learning rate to 0.04873104491241159.\nEpoch 32/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0138 - val_F1Score: 0.0032 - val_loss: 0.0126 - learning_rate: 0.0487\n\nEpoch 33: LearningRateScheduler setting learning rate to 0.04860802282816687.\nEpoch 33/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0137 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0486\n\nEpoch 34: LearningRateScheduler setting learning rate to 0.048477530864382556.\nEpoch 34/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0038 - loss: 0.0141 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0485\n\nEpoch 35: LearningRateScheduler setting learning rate to 0.04833938867581208.\nEpoch 35/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0131 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0483\n\nEpoch 36: LearningRateScheduler setting learning rate to 0.048193427402064476.\nEpoch 36/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0125 - learning_rate: 0.0482\n\nEpoch 37: LearningRateScheduler setting learning rate to 0.04803948224003987.\nEpoch 37/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0480\n\nEpoch 38: LearningRateScheduler setting learning rate to 0.04787739244900734.\nEpoch 38/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0131 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0479\n\nEpoch 39: LearningRateScheduler setting learning rate to 0.04770701249149665.\nEpoch 39/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0029 - loss: 0.0111 - val_F1Score: 0.0032 - val_loss: 0.0133 - learning_rate: 0.0477\n\nEpoch 40: LearningRateScheduler setting learning rate to 0.04752819718190602.\nEpoch 40/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0124 - learning_rate: 0.0475\n\nEpoch 41: LearningRateScheduler setting learning rate to 0.04734080911500294.\nEpoch 41/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0473\n\nEpoch 42: LearningRateScheduler setting learning rate to 0.047144726085502936.\nEpoch 42/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0471\n\nEpoch 43: LearningRateScheduler setting learning rate to 0.04693982624336337.\nEpoch 43/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0469\n\nEpoch 44: LearningRateScheduler setting learning rate to 0.046726002933231724.\nEpoch 44/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0467\n\nEpoch 45: LearningRateScheduler setting learning rate to 0.04650315356208633.\nEpoch 45/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0465\n\nEpoch 46: LearningRateScheduler setting learning rate to 0.04627118701398982.\nEpoch 46/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0463\n\nEpoch 47: LearningRateScheduler setting learning rate to 0.04603002364280635.\nEpoch 47/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0460\n\nEpoch 48: LearningRateScheduler setting learning rate to 0.045779591559066454.\nEpoch 48/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0129 - learning_rate: 0.0458\n\nEpoch 49: LearningRateScheduler setting learning rate to 0.04551983403368002.\nEpoch 49/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0141 - learning_rate: 0.0455\n\nEpoch 50: LearningRateScheduler setting learning rate to 0.04525069467084936.\nEpoch 50/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0453\n\nEpoch 51: LearningRateScheduler setting learning rate to 0.04497213962521406.\nEpoch 51/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0450\n\nEpoch 52: LearningRateScheduler setting learning rate to 0.044684139069935486.\nEpoch 52/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0447\n\nEpoch 53: LearningRateScheduler setting learning rate to 0.04438667459485334.\nEpoch 53/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0113 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0444\n\nEpoch 54: LearningRateScheduler setting learning rate to 0.044079742893301965.\nEpoch 54/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0131 - val_F1Score: 0.0032 - val_loss: 0.0144 - learning_rate: 0.0441\n\nEpoch 55: LearningRateScheduler setting learning rate to 0.04376335204512589.\nEpoch 55/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0114 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0438\n\nEpoch 56: LearningRateScheduler setting learning rate to 0.04343751780458211.\nEpoch 56/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0434\n\nEpoch 57: LearningRateScheduler setting learning rate to 0.04310227467966714.\nEpoch 57/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0431\n\nEpoch 58: LearningRateScheduler setting learning rate to 0.04275766481926046.\nEpoch 58/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0029 - loss: 0.0108 - val_F1Score: 0.0032 - val_loss: 0.0137 - learning_rate: 0.0428\n\nEpoch 59: LearningRateScheduler setting learning rate to 0.04240374169564687.\nEpoch 59/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0424\n\nEpoch 60: LearningRateScheduler setting learning rate to 0.042040577473459635.\nEpoch 60/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0135 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0420\n\nEpoch 61: LearningRateScheduler setting learning rate to 0.04166825190326737.\nEpoch 61/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0029 - loss: 0.0112 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0417\n\nEpoch 62: LearningRateScheduler setting learning rate to 0.041286855998470276.\nEpoch 62/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0413\n\nEpoch 63: LearningRateScheduler setting learning rate to 0.040896499394979254.\nEpoch 63/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0409\n\nEpoch 64: LearningRateScheduler setting learning rate to 0.04049729925174605.\nEpoch 64/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0405\n\nEpoch 65: LearningRateScheduler setting learning rate to 0.04008939129741767.\nEpoch 65/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0401\n\nEpoch 66: LearningRateScheduler setting learning rate to 0.03967291873571355.\nEpoch 66/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0397\n\nEpoch 67: LearningRateScheduler setting learning rate to 0.03924803959794496.\nEpoch 67/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0039 - loss: 0.0142 - val_F1Score: 0.0032 - val_loss: 0.0223 - learning_rate: 0.0392\n\nEpoch 68: LearningRateScheduler setting learning rate to 0.03881492302789103.\nEpoch 68/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0139 - val_F1Score: 0.0032 - val_loss: 0.0125 - learning_rate: 0.0388\n\nEpoch 69: LearningRateScheduler setting learning rate to 0.038373756621834496.\nEpoch 69/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0384\n\nEpoch 70: LearningRateScheduler setting learning rate to 0.03792473166260165.\nEpoch 70/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0379\n\nEpoch 71: LearningRateScheduler setting learning rate to 0.03746805782613492.\nEpoch 71/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0135 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0375\n\nEpoch 72: LearningRateScheduler setting learning rate to 0.03700395210292682.\nEpoch 72/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0370\n\nEpoch 73: LearningRateScheduler setting learning rate to 0.036532649808634195.\nEpoch 73/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0365\n\nEpoch 74: LearningRateScheduler setting learning rate to 0.036054393511249797.\nEpoch 74/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0361\n\nEpoch 75: LearningRateScheduler setting learning rate to 0.035569436681775514.\nEpoch 75/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0133 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0356\n\nEpoch 76: LearningRateScheduler setting learning rate to 0.03507804366240132.\nEpoch 76/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0031 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0351\n\nEpoch 77: LearningRateScheduler setting learning rate to 0.034580493306341685.\nEpoch 77/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0346\n\nEpoch 78: LearningRateScheduler setting learning rate to 0.03407706792429393.\nEpoch 78/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0341\n\nEpoch 79: LearningRateScheduler setting learning rate to 0.03356806794275915.\nEpoch 79/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0028 - loss: 0.0108 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0336\n\nEpoch 80: LearningRateScheduler setting learning rate to 0.03305380085029894.\nEpoch 80/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0114 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0331\n\nEpoch 81: LearningRateScheduler setting learning rate to 0.0325345775020496.\nEpoch 81/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0325\n\nEpoch 82: LearningRateScheduler setting learning rate to 0.03201072309373603.\nEpoch 82/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0320\n\nEpoch 83: LearningRateScheduler setting learning rate to 0.03148256978963389.\nEpoch 83/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0315\n\nEpoch 84: LearningRateScheduler setting learning rate to 0.030950456692133768.\nEpoch 84/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0137 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0310\n\nEpoch 85: LearningRateScheduler setting learning rate to 0.030414729810794083.\nEpoch 85/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0133 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0304\n\nEpoch 86: LearningRateScheduler setting learning rate to 0.029875742030884136.\nEpoch 86/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0299\n\nEpoch 87: LearningRateScheduler setting learning rate to 0.029333851252558933.\nEpoch 87/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0115 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0293\n\nEpoch 88: LearningRateScheduler setting learning rate to 0.028789420362314282.\nEpoch 88/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0127 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0288\n\nEpoch 89: LearningRateScheduler setting learning rate to 0.028242819031350504.\nEpoch 89/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0282\n\nEpoch 90: LearningRateScheduler setting learning rate to 0.027694420029314302.\nEpoch 90/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0277\n\nEpoch 91: LearningRateScheduler setting learning rate to 0.027144599198612736.\nEpoch 91/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0271\n\nEpoch 92: LearningRateScheduler setting learning rate to 0.026593733603646846.\nEpoch 92/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0266\n\nEpoch 93: LearningRateScheduler setting learning rate to 0.026042203332819286.\nEpoch 93/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0260\n\nEpoch 94: LearningRateScheduler setting learning rate to 0.025490389649056783.\nEpoch 94/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0255\n\nEpoch 95: LearningRateScheduler setting learning rate to 0.02493867678984359.\nEpoch 95/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0249\n\nEpoch 96: LearningRateScheduler setting learning rate to 0.0243874446546497.\nEpoch 96/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0028 - loss: 0.0105 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0244\n\nEpoch 97: LearningRateScheduler setting learning rate to 0.02383707607775812.\nEpoch 97/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0238\n\nEpoch 98: LearningRateScheduler setting learning rate to 0.0232879495225387.\nEpoch 98/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0233\n\nEpoch 99: LearningRateScheduler setting learning rate to 0.022740442709790577.\nEpoch 99/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0227\n\nEpoch 100: LearningRateScheduler setting learning rate to 0.022194928963840378.\nEpoch 100/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0222\n\nEpoch 101: LearningRateScheduler setting learning rate to 0.021651780837725836.\nEpoch 101/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0217\n\nEpoch 102: LearningRateScheduler setting learning rate to 0.021111362830849738.\nEpoch 102/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0211\n\nEpoch 103: LearningRateScheduler setting learning rate to 0.020574038650582698.\nEpoch 103/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0206\n\nEpoch 104: LearningRateScheduler setting learning rate to 0.020040162123402632.\nEpoch 104/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0115 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0200\n\nEpoch 105: LearningRateScheduler setting learning rate to 0.019510082641125054.\nEpoch 105/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0036 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0195\n\nEpoch 106: LearningRateScheduler setting learning rate to 0.01898414334111084.\nEpoch 106/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0135 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0190\n\nEpoch 107: LearningRateScheduler setting learning rate to 0.018462677481004153.\nEpoch 107/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0185\n\nEpoch 108: LearningRateScheduler setting learning rate to 0.017946012067510217.\nEpoch 108/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0179\n\nEpoch 109: LearningRateScheduler setting learning rate to 0.01743446604557586.\nEpoch 109/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0174\n\nEpoch 110: LearningRateScheduler setting learning rate to 0.0169283466852938.\nEpoch 110/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0169\n\nEpoch 111: LearningRateScheduler setting learning rate to 0.016427951403963508.\nEpoch 111/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0164\n\nEpoch 112: LearningRateScheduler setting learning rate to 0.015933567776404835.\nEpoch 112/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0159\n\nEpoch 113: LearningRateScheduler setting learning rate to 0.015445473545956377.\nEpoch 113/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0154\n\nEpoch 114: LearningRateScheduler setting learning rate to 0.014963933929296461.\nEpoch 114/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0150\n\nEpoch 115: LearningRateScheduler setting learning rate to 0.014489202538243347.\nEpoch 115/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0145\n\nEpoch 116: LearningRateScheduler setting learning rate to 0.014021520496817624.\nEpoch 116/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0140\n\nEpoch 117: LearningRateScheduler setting learning rate to 0.013561116462970584.\nEpoch 117/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0127 - learning_rate: 0.0136\n\nEpoch 118: LearningRateScheduler setting learning rate to 0.013108206651183544.\nEpoch 118/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0131\n\nEpoch 119: LearningRateScheduler setting learning rate to 0.012662993956245575.\nEpoch 119/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0127\n\nEpoch 120: LearningRateScheduler setting learning rate to 0.012225667081091017.\nEpoch 120/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0123 - learning_rate: 0.0122\n\nEpoch 121: LearningRateScheduler setting learning rate to 0.01179640236465126.\nEpoch 121/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0118\n\nEpoch 122: LearningRateScheduler setting learning rate to 0.011375362011883477.\nEpoch 122/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0114\n\nEpoch 123: LearningRateScheduler setting learning rate to 0.010962693228735833.\nEpoch 123/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0110\n\nEpoch 124: LearningRateScheduler setting learning rate to 0.01055853005235644.\nEpoch 124/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0106\n\nEpoch 125: LearningRateScheduler setting learning rate to 0.010162992486406664.\nEpoch 125/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0030 - loss: 0.0112 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0102\n\nEpoch 126: LearningRateScheduler setting learning rate to 0.009776186536514266.\nEpoch 126/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0098\n\nEpoch 127: LearningRateScheduler setting learning rate to 0.00939820335139082.\nEpoch 127/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0094\n\nEpoch 128: LearningRateScheduler setting learning rate to 0.009029121052566404.\nEpoch 128/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0090\n\nEpoch 129: LearningRateScheduler setting learning rate to 0.008669002981605245.\nEpoch 129/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0087\n\nEpoch 130: LearningRateScheduler setting learning rate to 0.00831789863593302.\nEpoch 130/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0083\n\nEpoch 131: LearningRateScheduler setting learning rate to 0.007975844602221773.\nEpoch 131/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0080\n\nEpoch 132: LearningRateScheduler setting learning rate to 0.00764286280991781.\nEpoch 132/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0076\n\nEpoch 133: LearningRateScheduler setting learning rate to 0.007318962806057378.\nEpoch 133/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0073\n\nEpoch 134: LearningRateScheduler setting learning rate to 0.007004140902813916.\nEpoch 134/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0070\n\nEpoch 135: LearningRateScheduler setting learning rate to 0.006698380665480482.\nEpoch 135/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0067\n\nEpoch 136: LearningRateScheduler setting learning rate to 0.006401653399573791.\nEpoch 136/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0115 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0064\n\nEpoch 137: LearningRateScheduler setting learning rate to 0.006113918192281751.\nEpoch 137/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0061\n\nEpoch 138: LearningRateScheduler setting learning rate to 0.00583512239919073.\nEpoch 138/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0058\n\nEpoch 139: LearningRateScheduler setting learning rate to 0.005565202574146112.\nEpoch 139/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0056\n\nEpoch 140: LearningRateScheduler setting learning rate to 0.005304084064791188.\nEpoch 140/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0053\n\nEpoch 141: LearningRateScheduler setting learning rate to 0.005051681497723035.\nEpoch 141/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0051\n\nEpoch 142: LearningRateScheduler setting learning rate to 0.004807899705742073.\nEpoch 142/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0127 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0048\n\nEpoch 143: LearningRateScheduler setting learning rate to 0.004572634652071941.\nEpoch 143/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0046\n\nEpoch 144: LearningRateScheduler setting learning rate to 0.004345772581226123.\nEpoch 144/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0131 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0043\n\nEpoch 145: LearningRateScheduler setting learning rate to 0.0041271918277528885.\nEpoch 145/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0041\n\nEpoch 146: LearningRateScheduler setting learning rate to 0.003916761966443078.\nEpoch 146/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0039\n\nEpoch 147: LearningRateScheduler setting learning rate to 0.0037143456165374526.\nEpoch 147/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0037\n\nEpoch 148: LearningRateScheduler setting learning rate to 0.003519798694295597.\nEpoch 148/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0035\n\nEpoch 149: LearningRateScheduler setting learning rate to 0.0033329702241221442.\nEpoch 149/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0119 - learning_rate: 0.0033\n\nEpoch 150: LearningRateScheduler setting learning rate to 0.003153703693298654.\nEpoch 150/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0032\n\nEpoch 151: LearningRateScheduler setting learning rate to 0.002981837080382247.\nEpoch 151/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0122 - learning_rate: 0.0030\n\nEpoch 152: LearningRateScheduler setting learning rate to 0.002817203763890849.\nEpoch 152/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0028\n\nEpoch 153: LearningRateScheduler setting learning rate to 0.002659632548117222.\nEpoch 153/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0027\n\nEpoch 154: LearningRateScheduler setting learning rate to 0.002508948787459685.\nEpoch 154/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0025\n\nEpoch 155: LearningRateScheduler setting learning rate to 0.0023649744086335148.\nEpoch 155/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0024\n\nEpoch 156: LearningRateScheduler setting learning rate to 0.002227528810319298.\nEpoch 156/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0022\n\nEpoch 157: LearningRateScheduler setting learning rate to 0.002096428882420658.\nEpoch 157/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0021\n\nEpoch 158: LearningRateScheduler setting learning rate to 0.0019714901202732477.\nEpoch 158/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0020\n\nEpoch 159: LearningRateScheduler setting learning rate to 0.0018525268586946407.\nEpoch 159/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0038 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0019\n\nEpoch 160: LearningRateScheduler setting learning rate to 0.001739352177175322.\nEpoch 160/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0017\n\nEpoch 161: LearningRateScheduler setting learning rate to 0.0016317790070494893.\nEpoch 161/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0016\n\nEpoch 162: LearningRateScheduler setting learning rate to 0.0015296205786924965.\nEpoch 162/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0015\n\nEpoch 163: LearningRateScheduler setting learning rate to 0.0014326904304467975.\nEpoch 163/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0014\n\nEpoch 164: LearningRateScheduler setting learning rate to 0.0013408029622755352.\nEpoch 164/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0013\n\nEpoch 165: LearningRateScheduler setting learning rate to 0.0012537739867035033.\nEpoch 165/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0113 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0013\n\nEpoch 166: LearningRateScheduler setting learning rate to 0.0011714208419180048.\nEpoch 166/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0012\n\nEpoch 167: LearningRateScheduler setting learning rate to 0.0010935627215877873.\nEpoch 167/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 0.0011\n\nEpoch 168: LearningRateScheduler setting learning rate to 0.0010200213286971748.\nEpoch 168/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 0.0010\n\nEpoch 169: LearningRateScheduler setting learning rate to 0.0009506207664891017.\nEpoch 169/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0037 - loss: 0.0133 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 9.5062e-04\n\nEpoch 170: LearningRateScheduler setting learning rate to 0.0008851880802090808.\nEpoch 170/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 8.8519e-04\n\nEpoch 171: LearningRateScheduler setting learning rate to 0.0008235533085124968.\nEpoch 171/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 8.2355e-04\n\nEpoch 172: LearningRateScheduler setting learning rate to 0.0007655498590444079.\nEpoch 172/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 7.6555e-04\n\nEpoch 173: LearningRateScheduler setting learning rate to 0.000711014611544236.\nEpoch 173/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 7.1101e-04\n\nEpoch 174: LearningRateScheduler setting learning rate to 0.0006597882362160549.\nEpoch 174/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0029 - loss: 0.0109 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 6.5979e-04\n\nEpoch 175: LearningRateScheduler setting learning rate to 0.0006117152403282328.\nEpoch 175/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 6.1172e-04\n\nEpoch 176: LearningRateScheduler setting learning rate to 0.0005666441221124275.\nEpoch 176/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 9s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 5.6664e-04\n\nEpoch 177: LearningRateScheduler setting learning rate to 0.0005244275774159951.\nEpoch 177/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 5.2443e-04\n\nEpoch 178: LearningRateScheduler setting learning rate to 0.0004849225434646702.\nEpoch 178/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0036 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 4.8492e-04\n\nEpoch 179: LearningRateScheduler setting learning rate to 0.0004479903496044815.\nEpoch 179/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 4.4799e-04\n\nEpoch 180: LearningRateScheduler setting learning rate to 0.00041349667884561114.\nEpoch 180/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0030 - loss: 0.0111 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 4.1350e-04\n\nEpoch 181: LearningRateScheduler setting learning rate to 0.00038131174396874263.\nEpoch 181/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.8131e-04\n\nEpoch 182: LearningRateScheduler setting learning rate to 0.00035131022098520786.\nEpoch 182/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.5131e-04\n\nEpoch 183: LearningRateScheduler setting learning rate to 0.000323371316538639.\nEpoch 183/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.2337e-04\n\nEpoch 184: LearningRateScheduler setting learning rate to 0.0002973788077995383.\nEpoch 184/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.9738e-04\n\nEpoch 185: LearningRateScheduler setting learning rate to 0.00027322094806250124.\nEpoch 185/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 2.7322e-04\n\nEpoch 186: LearningRateScheduler setting learning rate to 0.0002507905060636847.\nEpoch 186/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 2.5079e-04\n\nEpoch 187: LearningRateScheduler setting learning rate to 0.00022998472463185788.\nEpoch 187/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0038 - loss: 0.0136 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.2998e-04\n\nEpoch 188: LearningRateScheduler setting learning rate to 0.00021070525252817312.\nEpoch 188/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0127 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 2.1071e-04\n\nEpoch 189: LearningRateScheduler setting learning rate to 0.00019285808961416642.\nEpoch 189/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0133 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.9286e-04\n\nEpoch 190: LearningRateScheduler setting learning rate to 0.00017635351865172405.\nEpoch 190/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.7635e-04\n\nEpoch 191: LearningRateScheduler setting learning rate to 0.00016110605041721006.\nEpoch 191/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0030 - loss: 0.0111 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.6111e-04\n\nEpoch 192: LearningRateScheduler setting learning rate to 0.00014703428907961074.\nEpoch 192/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0127 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.4703e-04\n\nEpoch 193: LearningRateScheduler setting learning rate to 0.00013406090414221943.\nEpoch 193/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.3406e-04\n\nEpoch 194: LearningRateScheduler setting learning rate to 0.00012211248289829325.\nEpoch 194/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.2211e-04\n\nEpoch 195: LearningRateScheduler setting learning rate to 0.00011111943637018841.\nEpoch 195/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.1112e-04\n\nEpoch 196: LearningRateScheduler setting learning rate to 0.00010101588562002027.\nEpoch 196/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.0102e-04\n\nEpoch 197: LearningRateScheduler setting learning rate to 9.173956161771835e-05.\nEpoch 197/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 9.1740e-05\n\nEpoch 198: LearningRateScheduler setting learning rate to 8.323166577470412e-05.\nEpoch 198/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 8.3232e-05\n\nEpoch 199: LearningRateScheduler setting learning rate to 7.543677716041947e-05.\nEpoch 199/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 7.5437e-05\n\nEpoch 200: LearningRateScheduler setting learning rate to 6.830270726935913e-05.\nEpoch 200/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 6.8303e-05\n\nEpoch 201: LearningRateScheduler setting learning rate to 6.178038169635723e-05.\nEpoch 201/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 6.1780e-05\n\nEpoch 202: LearningRateScheduler setting learning rate to 5.5823715672683846e-05.\nEpoch 202/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0031 - loss: 0.0115 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 5.5824e-05\n\nEpoch 203: LearningRateScheduler setting learning rate to 5.038949665635076e-05.\nEpoch 203/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 5.0389e-05\n\nEpoch 204: LearningRateScheduler setting learning rate to 4.543725097729416e-05.\nEpoch 204/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0031 - loss: 0.0114 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 4.5437e-05\n\nEpoch 205: LearningRateScheduler setting learning rate to 4.0929124160673104e-05.\nEpoch 205/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 4.0929e-05\n\nEpoch 206: LearningRateScheduler setting learning rate to 3.682975847646033e-05.\nEpoch 206/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0131 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.6830e-05\n\nEpoch 207: LearningRateScheduler setting learning rate to 3.31061677502092e-05.\nEpoch 207/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.3106e-05\n\nEpoch 208: LearningRateScheduler setting learning rate to 2.9727622537092672e-05.\nEpoch 208/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0117 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.9728e-05\n\nEpoch 209: LearningRateScheduler setting learning rate to 2.6665534176340642e-05.\nEpoch 209/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.6666e-05\n\nEpoch 210: LearningRateScheduler setting learning rate to 2.3893339378491008e-05.\nEpoch 210/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0115 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 2.3893e-05\n\nEpoch 211: LearningRateScheduler setting learning rate to 2.138639024030536e-05.\nEpoch 211/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.1386e-05\n\nEpoch 212: LearningRateScheduler setting learning rate to 1.9121844781739403e-05.\nEpoch 212/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0119 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.9122e-05\n\nEpoch 213: LearningRateScheduler setting learning rate to 1.70785645133303e-05.\nEpoch 213/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.7079e-05\n\nEpoch 214: LearningRateScheduler setting learning rate to 1.5237012502896017e-05.\nEpoch 214/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0031 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.5237e-05\n\nEpoch 215: LearningRateScheduler setting learning rate to 1.357915519287874e-05.\nEpoch 215/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.3579e-05\n\nEpoch 216: LearningRateScheduler setting learning rate to 1.2088370381438874e-05.\nEpoch 216/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0035 - loss: 0.0127 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.2088e-05\n\nEpoch 217: LearningRateScheduler setting learning rate to 1.0749355670971902e-05.\nEpoch 217/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.0749e-05\n\nEpoch 218: LearningRateScheduler setting learning rate to 9.548043047235348e-06.\nEpoch 218/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0126 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 9.5480e-06\n\nEpoch 219: LearningRateScheduler setting learning rate to 8.4715155183082e-06.\nEpoch 219/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 8.4715e-06\n\nEpoch 220: LearningRateScheduler setting learning rate to 7.507931450634886e-06.\nEpoch 220/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0035 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 7.5079e-06\n\nEpoch 221: LearningRateScheduler setting learning rate to 6.646446085543275e-06.\nEpoch 221/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0032 - loss: 0.0116 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 6.6464e-06\n\nEpoch 222: LearningRateScheduler setting learning rate to 5.877143136087781e-06.\nEpoch 222/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0134 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 5.8771e-06\n\nEpoch 223: LearningRateScheduler setting learning rate to 5.190965951257081e-06.\nEpoch 223/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0031 - loss: 0.0113 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 5.1910e-06\n\nEpoch 224: LearningRateScheduler setting learning rate to 4.579655882737102e-06.\nEpoch 224/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 4.5797e-06\n\nEpoch 225: LearningRateScheduler setting learning rate to 4.035690191498989e-06.\nEpoch 225/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 4.0357e-06\n\nEpoch 226: LearningRateScheduler setting learning rate to 3.5522267110029194e-06.\nEpoch 226/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.5522e-06\n\nEpoch 227: LearningRateScheduler setting learning rate to 3.123050022982594e-06.\nEpoch 227/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.1230e-06\n\nEpoch 228: LearningRateScheduler setting learning rate to 2.7425225352732546e-06.\nEpoch 228/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0037 - loss: 0.0132 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 2.7425e-06\n\nEpoch 229: LearningRateScheduler setting learning rate to 2.4055370383374177e-06.\nEpoch 229/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0129 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.4055e-06\n\nEpoch 230: LearningRateScheduler setting learning rate to 2.1074729261271663e-06.\nEpoch 230/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0039 - loss: 0.0139 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 2.1075e-06\n\nEpoch 231: LearningRateScheduler setting learning rate to 1.8441558584291099e-06.\nEpoch 231/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0123 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.8442e-06\n\nEpoch 232: LearningRateScheduler setting learning rate to 1.611819649663071e-06.\nEpoch 232/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0036 - loss: 0.0130 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.6118e-06\n\nEpoch 233: LearningRateScheduler setting learning rate to 1.4070711650071392e-06.\nEpoch 233/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0121 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 1.4071e-06\n\nEpoch 234: LearningRateScheduler setting learning rate to 1.2268571134422569e-06.\nEpoch 234/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0033 - loss: 0.0120 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.2269e-06\n\nEpoch 235: LearningRateScheduler setting learning rate to 1.0684341126453187e-06.\nEpoch 235/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0124 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 1.0684e-06\n\nEpoch 236: LearningRateScheduler setting learning rate to 9.293406181791023e-07.\nEpoch 236/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0034 - loss: 0.0125 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 9.2934e-07\n\nEpoch 237: LearningRateScheduler setting learning rate to 8.073707546410956e-07.\nEpoch 237/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0028 - loss: 0.0103 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 8.0737e-07\n\nEpoch 238: LearningRateScheduler setting learning rate to 7.005507269301096e-07.\nEpoch 238/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 8s 2ms/step - F1Score: 0.0040 - loss: 0.0143 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 7.0055e-07\n\nEpoch 239: LearningRateScheduler setting learning rate to 6.071166600852295e-07.\nEpoch 239/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 10s 2ms/step - F1Score: 0.0035 - loss: 0.0128 - val_F1Score: 0.0032 - val_loss: 0.0120 - learning_rate: 6.0712e-07\n\nEpoch 240: LearningRateScheduler setting learning rate to 5.254945474903442e-07.\nEpoch 240/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 5.2549e-07\n\nEpoch 241: LearningRateScheduler setting learning rate to 4.542818008736369e-07.\nEpoch 241/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0033 - loss: 0.0122 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 4.5428e-07\n\nEpoch 242: LearningRateScheduler setting learning rate to 3.9223019466086514e-07.\nEpoch 242/1000\n4334/4334 ━━━━━━━━━━━━━━━━━━━━ 7s 2ms/step - F1Score: 0.0032 - loss: 0.0118 - val_F1Score: 0.0032 - val_loss: 0.0121 - learning_rate: 3.9223e-07\nEpoch 242: early stopping\n* 모델평가\n4334/4334 - 3s - 594us/step - F1Score: 0.0034 - loss: 0.0121\n2653/2653 - 2s - 584us/step - F1Score: 0.0032 - loss: 0.0121\n\n\n\n# Loss 및 F1-Score 시각화\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15,4))\nax1.plot(history.history['loss'], label='Loss')\nax2.plot(history.history['F1Score'], label='F1-score')\nax1.legend(), ax2.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nF1Score 및 Loss 개선 비교\n\n모델평가(기본) \n\n4334/4334 - 2s - 531us/step - F1Score: 0.0034 - loss: 0.0114\n2653/2653 - 1s - 511us/step - F1Score: 0.0029 - loss: 0.0123\n\n모델평가(Tuner) \n\n4334/4334 - 4s - 860us/step - F1Score: 0.0034 - loss: 0.0175\n2653/2653 - 2s - 862us/step - F1Score: 0.0029 - loss: 0.0164\n\n모델평가(Tuner + Kaiming Initialization) \n\n4334/4334 - 6s - 1ms/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 4s - 1ms/step - F1Score: 0.0029 - loss: 0.0109\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization) \n\n4334/4334 - 3s - 788us/step - F1Score: 0.0034 - loss: 0.0125\n2653/2653 - 2s - 757us/step - F1Score: 0.0029 - loss: 0.0110\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization + Learning rate Scheduling) \n\n4334/4334 - 3s - 640us/step - F1Score: 0.0034 - loss: 0.0124\n2653/2653 - 2s - 670us/step - F1Score: 0.0032 - loss: 0.0119\n\n모델평가(Tuner + Kaiming Initialization + Batch Normalization + Learning rate Scheduling + Early Stopping) \n\n4334/4334 - 3s - 594us/step - F1Score: 0.0034 - loss: 0.0121\n2653/2653 - 2s - 584us/step - F1Score: 0.0032 - loss: 0.0121\n\n\n\n\n\n결론\n\nLoss는 지속적인 개선이 되고 있으나 F1score는 계속 비슷한 수치를 보임\n\nLearning rate Scheduling 적용시에만 약간의 개선이 있음\n\n과제 발표 후 관련 내용 질의 및 개선 예정\n과제 진행 중 생긴 궁금한 점들에 대해서도 추가 질의 예정\n\n이런 모델은 결국 사용하고자 만드는 것인데, PCA로 만든 모델이면 새로운 거래가 생성된 경우 그대로 넣어도 모델이 판별 가능한지\nepoch 수 대비 적절한 Early stopping patience값이 있는지"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240714/index.html",
    "href": "posts/meta-dl-creditcard-20240714/index.html",
    "title": "[M_Study_최종과제 피드백/이론] 신용카드 이상거래 탐지 모델링",
    "section": "",
    "text": "Kaggle CreditCard Fraud Detection (과제 피드백 및 관련 이론, 개선계획)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240714/index.html#내-제출과제에-대한-피드백",
    "href": "posts/meta-dl-creditcard-20240714/index.html#내-제출과제에-대한-피드백",
    "title": "[M_Study_최종과제 피드백/이론] 신용카드 이상거래 탐지 모델링",
    "section": "내 제출과제에 대한 피드백",
    "text": "내 제출과제에 대한 피드백\n\nTrain, Validation, Test 데이터의 비율은 8:1:1 정도가 보통 \nFlatten은 사진 등 이미지에 많이 사용, 필요 없을 수 있다\nmodel.compile의 metric\n\nf1-score는 여러 종류가 있음\n\nimbalance한 상황에서 이상거래 등에 가중치를 주는 weighted f1-score\nclass별로 하는 macro f1-score\nmicro f1-score\n\n이런 상황에서 지원되는 metric이 vanila f1-score라면 점수가 안좋게 나온 것일수도 있다\n\nweighted f1-score와 같은 것을 사용하는 편이 적절히 평가될 수 있음\nrecall, precision을 모두 넣고 볼 수도 있음\nmodel build 대비 점수가 낮게 나와서, metric 문제일 가능성이 높아보임 \n\n\nHyper parameter Optimizer (발표과제에서는 Keras Tuner 사용)\n\n개념\n\n예를 들어 10개 파라미터에 100개 선택지가 있다면 \\(100^{10}\\)과 같이 계산량이 많음\n\n(Brute force방식) 모든 조합을 계산하여 최적조합을 찾는 방식은 계산량 문제로 어려움\n\n전체 계산 중 일부만 계산하는 방식으로, 전문가만큼의 성능은 안나오지만 초보의 수준에서는 좋음\n\nRandom search, Grid search\n\nGrid search : 나머지 파라미터를 고정시킨 채 최적 파라미터를 도출하는 것을 반복하여, 최적 파라미터만 조합\n\n최적이 아닌 파라미터들의 조합으로 최적 성능이 나올 수 있다는 단점\n\nRandom Search : 파라미터들의 ’조합’이라는 부분을 Grid search보다 좀 더 보기위한 방법\n\n추가용도\n\n모델을 확정한 후, 모델의 성능을 좀 더 높이기 위해서도 사용 가능\n\n예를 들면 모델을 분석하고 보고서를 쓰는 코딩테스트도 있는데, 이럴 때 조금이라도 성능을 올리기 위해 사용가능\n\n\nHyper parameter관련 보고서를 쓴다면, 어떤 기법을 추가하여 유용하고 좋았는지 비교하는 것이 좋음 \n\nEarly stopping 설정\n\nepoch수 대비 3%정도로 설정하기도 함\n실질적으로는 전체 epoch을 돌리고, 가장 성능이 좋았던 포인트를 사용하는 방법을 사용(모든 포인트의 고려) \n\n참고\n\n이후 새로운 거래가 생겨 모델로 판별하려면, 학습데이터와 같이 PCA처리 후 input 해야함\n매번 현재의 과제처럼 튜닝을 새로하기보다는, 전 모델의 튜닝을 지속하는 것이 효율적임\n\nLayer수, Activation function 등은 변경 불가한 요소\nLearning rate scheduler, early stopping 등의 변경 가능"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240714/index.html#과제-보완-계획",
    "href": "posts/meta-dl-creditcard-20240714/index.html#과제-보완-계획",
    "title": "[M_Study_최종과제 피드백/이론] 신용카드 이상거래 탐지 모델링",
    "section": "과제 보완 계획",
    "text": "과제 보완 계획\n\nData set 분석\n\nt-sne를 통해 데이터의 분포 등을 시각화하여 파악해봄\n내가 어느정도의 분류는 가능하겠다는 정도를 파악할 수 있음\n\n\n\nData set 구성\n\nTrain/Validation/Test를 8:1:1로 구성\ntrain_test_split(stratify=실제Label)을 통한 Label 비중 맞추기 검토\nValidation set은 StratifiedKFold 적용 검토\n컬럼별 이상치 처리 : Box plot의 Upperbound나 Underbound값으로 대체 고려(제거X)\n\nRobust scaler 고려\n\n\n\n\nParameter 등 모델구성\n\noptuna적용고려, Randomsearch, GridSearch 확인 후 선택\nmetric을 weighted f1-score나 recall&precision 등을 고려\n\n예시 : metrics = [f1_score, Precision(), Recall()]\n\n  import tensorflow_addons as tfa\n  f1_score = tfa.metrics.F1Score(num_classes=1, threshold=0.5)\n  model.compile(loss=SigmoidFocalCorssEntropy(),\n                optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001),\n                metrics=[f1_score, Pricision(), Recall()])\nEarly stopping은 코드구현은 하되 실질적으로는 무효가되는 patience인 경우도 추가로 설정\n\n전체 epoch을 돌려 가장 성능이 좋은 포인트도 확인한 후 대조\n\nLearning rate scheduling은 기존의 별도 함수를 만드는 방식 외, ReduceLROnPlateau 함수 이용도 고려\n\n  from tf.keras.callbacks import ReduceLROnPlateau\n  reduce_lr = ReduceLROnPlateau(monitor='val_loss',\n                factor=0.2, # lr감소치. 현재 lr이 0.01이라면 0.01*0.2를 적용\n                patience=10, # 개선에 대한 허용치. 10 epoch까지 개선이 없다면 적용\n                mode='min', # auto, max, min 옵션 있음\n                min_lr=0.001)\n  model.fit(x_train, y_train, callbacks=[reduce_lr])\n\nBatch size는 가능한 선에서는 늘려서 빠른 학습을 도모\n평가시 ROC Curve나 PR Curve 시각화도 고려\nCross validation 활용시, 여러번의 모델Score가 나오므로 Box plot을 통해 안정적인 모델인지 시각화\n\n\n\n기타\n\n시각화를 통해 데이터 설명 보강\n\nROC Curve나 PR Curve 등의 사용\n\n\n\n\n추가진행\n\n머신러닝 기법 활용\n\n모델 : XGB, Random forest 고려\n데이터셋 : 샘플링(오버 또는 언더) 적용 검토\n\n오버샘플링 한다면 SMOTE대신 ADASYN적용검토\n샘플링 적용/미적용 성능 비교\n\n위의 모델 또는 Logistic regression으로 비교\n\n\n모델학습 : Cross validation을 통한 과적합 방지\nThreshold adjustment 고려"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240714/index.html#주차-발표과제들-보완에-필요한-추가지식",
    "href": "posts/meta-dl-creditcard-20240714/index.html#주차-발표과제들-보완에-필요한-추가지식",
    "title": "[M_Study_최종과제 피드백/이론] 신용카드 이상거래 탐지 모델링",
    "section": "7주차 발표과제들 보완에 필요한 추가지식",
    "text": "7주차 발표과제들 보완에 필요한 추가지식\n\n불균형한 데이터를 맞춰주는 샘플링 기법 : 오버샘플링, 언더샘플링\n\n주의점 : 두 기법 모두 Test data를 먼저 분리해둔 후 나머지에 대해 적용. Test data는 건드리지 않는다\n언더샘플링과 오버샘플링은 둘 중 하나만 사용하는게 나음(함께 사용시 둘의 단점을 모두 가질수도 있다)\n참고사항\n\n가급적이면 언더샘플링보다는 오버샘플링을 많이 씀 (데이터는 자산이라는 관점에서, 손실 방지)\n추세는 발전된 알고리즘의 모델에 맡기고, 샘플링을 적용하지 않는 방향\n\n다만 상황에 따라서는 오버샘플링이 훨씬 좋을 때가 있음\n\n로지스틱회귀는 최신의 복잡한 알고리즘이 아닌 단순한 모델로, 편중된 데이터에 취약한데 여기에는 궁합이 좋음\nXGBoost나 Neural Network같은 복잡한 모델에는 오히려 안좋을 수 있음\n\n\n\n오버샘플링 & 언더샘플링\n\n오버샘플링 : 부족한 데이터를 늘림\n\n장점 : 데이터의 손실이 없음\n단점 : 데이터를 늘리기 위해 같은 데이터를 반복하면서 노이즈 발생 : Precision이 낮아진다(Recall은 높아진다)\n\nSMOTE가 이를 보완하기 위한 오버샘플링 기법이지만 근본적으로는 데이터가 반복되는 것은 같음\n(별도확인) ADASYN으로 SMOTE의 단점을 보완가능(SMOTE와 달리 다른 클래스의 데이터 수도 고려하여 증강)\n\nfrom imblearn.over_sampling import SMOTE, ADASYN\n\n언더샘플링 : 많은 쪽의 데이터를 부족한 데이터만큼 남기고 버림\n\n단점 : 데이터를 버린다는 손실\nfunction이 아니라 직접 구현한다면, 순서대로 가져오지 않고 Random하게 가져오도록 구현\n\n샘플링을 통해, 이상거래에 더 잘 반응할 수 있는 모델로 만들어 줄 수 있음\n\n다만 고객 입장에서는 정상거래인데 이상거래로 판단되게 되는 불편함이 생길 수 있음\n\n\n\nStratifiedKFold : 특정 Label이 많거나 적어서 분포가 Imbalance한 경우 활용\n\nValidation set을 나누는 기법이므로, Test set 분리 후 적용\nfold: 같은 Data set에서, 각 부분을 모두 Validation으로 활용할 수 있도록 반복\n\n데이터가 적을 때, 있는 데이터를 최대한 활용해, Validation set을 다양하게 만들 수 있다\n예를 들어 100개 데이터에 5 fold를 적용한다면, 아래와 같이 구성됨(굵은 부분이 validation set)\n\n120, 21~100 / 1~20, 2140, 41~100 / 1~40, 4160, 61~100 / 1~60, 6180, 81~100 / 1~80, 81~100\n\n\n참고 코드\n\n  skfold = StratifiedKFold(n_split=5, random_state=None, Shuffle=False)\n  for train_index, test_index in skfold.split(X,Y):\n    X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n    Y_train, Y_test = Y.iloc[train_index], Y.iloc[test_index]\n이상치 데이터에 대한 처리 : 제거 vs 대체\n\n제거는 데이터의 손실이므로 대체가 더 좋을 때도 있음\n\nBox plot 기준으로 Upper bound이상의 값들은 Upper bound값으로 치환하는 것도 방법\n\n\n차원축소(t-sne, PCA , SVD등)\n\n차원축소 : Feature들을 상관관계가 없는 Feature로 바꾸는 것을, 수학적인 방법으로 적용\n\n예를 들어 100개의 feature 중 연봉과 월급은 중복(상관관계있음)이므로 차원축소 적용 후 10개의 feature로 mapping\n\n대표적으로 PCA가 있음, 현재의 데이터는 이미 PCA가 적용되어 있음\n종류\n\nPCA : 상관관계를 없애며 전처리 가능\nSVD(간단하게 PCA를 확장한 것으로 볼 수 있음. 전처리 가능)\nt-sne : 저차원으로 mapping 하여 시각화 용이 (전처리는 불가)\n\n유의사항 : PCA나 SVD는 선형적인 관계가 있을때만 적용한다(비선형적인 정보는 손실되므로 모델성능하락이 있을 수 있다)\n\nPlot을 그렸을 때 fold의 수만큼 점으로 나오게 됨(5fold면 5개)  \nRecall, Precision은 Trade-off, 2개 모두 준수한 Sweet spot을 찾기 위해 함께 볼 수 있는 방법\n\nf1-score : 조화평균을 활용한 하나의 숫자로 판단 가능\nROC Curve : TP와 FP를 x, y축으로 두고 면적으로 판단 가능(넓을수록 좋음, 0~1값 가짐)\nPR(Precision-Recall) Curve : Precision과 Recall을 x, y축으로 두고 면적으로 판단 (넓을수록 좋음)\n\nBinary 문제의 경우, Simoid 대신 2개 뉴런의 Softmax도 가능함\nBatch size는 관례(2의 배수)를 맞추는 것이 좋음 (보고서 확인의 관점에서는 안좋은 시선으로 보게될 수 있다)\n이상치 Robustscaler\ntrain_test_split(stratify=실제Label)옵션으로 Label의 비율을 비슷하게 샘플링 가능\n오버샘플링의 단점 : precision이 낮아진다\n\nprecision은 판정한 건 중 실제의 비율이고, 오버샘플링으로 정상거래를 이상거래로 판정하는건이 많아짐\nrecall의 측면에서는 오버샘플링을 통해 판정을 늘리는게 나을 수 있음(암환자 사례)\n\n데이터 불균형에서의 가중치 설정 : Class(label)분포 기반 가중치 설정\n\n더 중요하게 보는 것에 패널티를 더 크게 줌\n정상거래(0) 284315건, 이상거래(1) 492건인 경우의 예시\n  total_samples = 284315 + 492\n  weight_for_0 = total_samples / ( 2 * 284315)\n  weight_for_1 = total_samples / (2 * 492)\n  class_weights = {0:weight_for_0, 1:weight_for_1}\n\n  model.fit(x_train, y_train, class_weight=class_weights)\nNeural network에서 해결할 수 있는 부분이어서 오히려 혼동을 줄 수도 있다\n\n모델 알고리즘이 복잡한 경우는, Weight에서 패널티를 다르게 주는 focal loss나 오버샘플링을 잘 쓰지 않음\n\nNeural network에 Sigmoid focal CrossEntrophy를 통해 패널티를 높게 주어 긍정적 효과를 기대했지만, 오히려 성능하락될 수 있음\n\n모델 알고리즘이 단순한 Logistic regression 등은, 이러한 Weighted loss가 효과가 좋을 수 있음\n\n\nLearning rate scheduler 함수로 구현 예시\n\n  from tf.keras.callbacks import ReduceLROnPlateau\n  reduce_lr = ReduceLROnPlateau(monitor='val_loss',\n                factor=0.2, # lr감소치. 현재 lr이 0.01이라면 0.01*0.2를 적용\n                patience=10, # 개선에 대한 허용치. 10 epoch까지 개선이 없다면 적용\n                mode='min', # auto, max, min 옵션 있음\n                min_lr=0.001)\n  model.fit(x_train, y_train, callbacks=[reduce_lr])\n\nDropout은 간단한 모델이라면 높게 설정할지 않아도 괜찮음\nBatch size는 데이터가 적거나 장비(메모리) 상황이 좋다면 늘려서 빠르게 학습\n과적합(Overfitting)의 원인\n\n모델 자체의 문제, 앞단계인 데이터 전처리나 샘플링, Data split 등의 문제일 수 있음\n단순히 성능이 안나왔다해서 과적합으로 판단은 금물\n\nLDA (Linear discriminant Anaylsis) : 분류문제에서는 Logistic Regression 좋은 성능\nKNN (K-Nearest Neighbor) : 근접(이웃)한 데이터들을 분류\nCart : 의사결정나무(Decision Tree)의 기본 모델\nRandom forest : 여러개의 트리 모델을 만들고, 다수결로 정함. 앙상블 모델\nBoosting 계열 모델 : 학습 후, 틀린 부분에 가중치를 두면서 학습 반복\n\n처음에는 이상거래에 대해 많이 틀리다가, 점점 잘 잡아내도록 학습됨.\nXGB를 많이 사용\n\n이외에 Catboost 등도 있음\n현재와 같은 20만건 정도의 데이터는, 최신계열의 복잡한 머신러닝에서 더 성능이 좋을 수 있음\nCross validation 활용시, 여러번의 모델Score가 나오므로 Box plot을 통해 안정적인 모델인지 확인 가능\n모델의 선택 (SOTA가 기준이 되어야 하는지에 대한 질문)\n\n문제 정의(상황이 어떤 문제인지 정의할 능력 필요)\n어떤 계열의 모델이 적합한지 선택 (전반적인 머신러닝 등 모델 지식 필요)\nSOTA(State of the art)는 이후의 문제\n\n논문 등을 볼 때는 문제 Setup까지 본 후, 바로 풀이보지말고 먼저 고민 후 보기\nRandom forest모델 사용시 두가지 고려사항\n\nCross validation을 통한 과적합 방지\n\n앙상블모델은 복잡한 머신러닝 기법에 속하고, XGB나 Random forest는 과적합 일어날 수 있음\n\nHyper parameter tuning을 통한 개선\n\nThresholding(임계값 조정)\n\nPrecision과 recall은 trade-off. 원하는 것은 둘 다 높은 Spot\n\n이러한 Sweet spot을 시각적으로는 ROC/PR Curve로 확인, 코드로는 Threshold adjustment 조절\nThreshold 예시 일부\n\n  y_scores = model.predict_proba(X_test)[:, 1]\n  precision, recall, thresholds = precision_recall_curve(y_test, y_scores)\n\n  f1_score = 2 * precision * recall / (precision + recall)\n  optimal_idx = np.argmax(f1_scores)\n  optimal_threshold = thresholds[optimal_idx]"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240715/index.html",
    "href": "posts/meta-dl-creditcard-20240715/index.html",
    "title": "[MStudy_과제개선1] 신용카드 이상거래 탐지 모델링",
    "section": "",
    "text": "Kaggle CreditCard Fraud Detection (개선1 : Stratify 및 fold 적용에 따른 비교, weighted f1-score)\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240715/index.html#데이터-확인",
    "href": "posts/meta-dl-creditcard-20240715/index.html#데이터-확인",
    "title": "[MStudy_과제개선1] 신용카드 이상거래 탐지 모델링",
    "section": "데이터 확인",
    "text": "데이터 확인\n\n전체 데이터 : Null값 없음을 확인\n\nTime 컬럼 : 첫번째 거래와의 단순 시간차이이므로 삭제 예정\nV1 ~ V28 컬럼 : 익명화된 데이터. 전부 사용\nAmount 컬럼\n\n특이사항 : 결제액이 0인 데이터가 있어, 월정액 등록 전 Validation용 결제가 아닐까 추정\n이상거래(Class 1)도 데이터로 포함되어있지만, 실질적 돈 이동이 없어 의미가 있는지 의문\n\n위 이유로 처음에는 결제액 0인 데이터를 제거할까 고민\n몇 없는 이상거래 데이터이므로 유지하는 것으로 결정 (전체 492개 이상거래 중 27건 제거시 약 5%의 데이터 손실)\n\n\nClass 컬럼\n\n특이사항 : 98%가 정상거래(Class 0)인 데이터로 편중이 심함\n데이터가 Imbalance한 경우, Accuracy는 성능측정에 한계가 있으므로, F1-Score를 사용\n\n\n\n\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('creditcard.db')\ndf = pd.read_sql_query(\"SELECT * FROM creditcard\", conn)\nconn.close()\ndf\n\n\n\n\n\n\n\n\n\nTime\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n...\nV21\nV22\nV23\nV24\nV25\nV26\nV27\nV28\nAmount\nClass\n\n\n\n\n0\n0.0\n-1.359807\n-0.072781\n2.536347\n1.378155\n-0.338321\n0.462388\n0.239599\n0.098698\n0.363787\n...\n-0.018307\n0.277838\n-0.110474\n0.066928\n0.128539\n-0.189115\n0.133558\n-0.021053\n149.62\n0\n\n\n1\n0.0\n1.191857\n0.266151\n0.166480\n0.448154\n0.060018\n-0.082361\n-0.078803\n0.085102\n-0.255425\n...\n-0.225775\n-0.638672\n0.101288\n-0.339846\n0.167170\n0.125895\n-0.008983\n0.014724\n2.69\n0\n\n\n2\n1.0\n-1.358354\n-1.340163\n1.773209\n0.379780\n-0.503198\n1.800499\n0.791461\n0.247676\n-1.514654\n...\n0.247998\n0.771679\n0.909412\n-0.689281\n-0.327642\n-0.139097\n-0.055353\n-0.059752\n378.66\n0\n\n\n3\n1.0\n-0.966272\n-0.185226\n1.792993\n-0.863291\n-0.010309\n1.247203\n0.237609\n0.377436\n-1.387024\n...\n-0.108300\n0.005274\n-0.190321\n-1.175575\n0.647376\n-0.221929\n0.062723\n0.061458\n123.50\n0\n\n\n4\n2.0\n-1.158233\n0.877737\n1.548718\n0.403034\n-0.407193\n0.095921\n0.592941\n-0.270533\n0.817739\n...\n-0.009431\n0.798278\n-0.137458\n0.141267\n-0.206010\n0.502292\n0.219422\n0.215153\n69.99\n0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n284802\n172786.0\n-11.881118\n10.071785\n-9.834783\n-2.066656\n-5.364473\n-2.606837\n-4.918215\n7.305334\n1.914428\n...\n0.213454\n0.111864\n1.014480\n-0.509348\n1.436807\n0.250034\n0.943651\n0.823731\n0.77\n0\n\n\n284803\n172787.0\n-0.732789\n-0.055080\n2.035030\n-0.738589\n0.868229\n1.058415\n0.024330\n0.294869\n0.584800\n...\n0.214205\n0.924384\n0.012463\n-1.016226\n-0.606624\n-0.395255\n0.068472\n-0.053527\n24.79\n0\n\n\n284804\n172788.0\n1.919565\n-0.301254\n-3.249640\n-0.557828\n2.630515\n3.031260\n-0.296827\n0.708417\n0.432454\n...\n0.232045\n0.578229\n-0.037501\n0.640134\n0.265745\n-0.087371\n0.004455\n-0.026561\n67.88\n0\n\n\n284805\n172788.0\n-0.240440\n0.530483\n0.702510\n0.689799\n-0.377961\n0.623708\n-0.686180\n0.679145\n0.392087\n...\n0.265245\n0.800049\n-0.163298\n0.123205\n-0.569159\n0.546668\n0.108821\n0.104533\n10.00\n0\n\n\n284806\n172792.0\n-0.533413\n-0.189733\n0.703337\n-0.506271\n-0.012546\n-0.649617\n1.577006\n-0.414650\n0.486180\n...\n0.261057\n0.643078\n0.376777\n0.008797\n-0.473649\n-0.818267\n-0.002415\n0.013649\n217.00\n0\n\n\n\n\n284807 rows × 31 columns\n\n\n\n\n\n# df.info()를 통한 null값 및 컬럼 확인\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 284807 entries, 0 to 284806\nData columns (total 31 columns):\n #   Column  Non-Null Count   Dtype  \n---  ------  --------------   -----  \n 0   Time    284807 non-null  float64\n 1   V1      284807 non-null  float64\n 2   V2      284807 non-null  float64\n 3   V3      284807 non-null  float64\n 4   V4      284807 non-null  float64\n 5   V5      284807 non-null  float64\n 6   V6      284807 non-null  float64\n 7   V7      284807 non-null  float64\n 8   V8      284807 non-null  float64\n 9   V9      284807 non-null  float64\n 10  V10     284807 non-null  float64\n 11  V11     284807 non-null  float64\n 12  V12     284807 non-null  float64\n 13  V13     284807 non-null  float64\n 14  V14     284807 non-null  float64\n 15  V15     284807 non-null  float64\n 16  V16     284807 non-null  float64\n 17  V17     284807 non-null  float64\n 18  V18     284807 non-null  float64\n 19  V19     284807 non-null  float64\n 20  V20     284807 non-null  float64\n 21  V21     284807 non-null  float64\n 22  V22     284807 non-null  float64\n 23  V23     284807 non-null  float64\n 24  V24     284807 non-null  float64\n 25  V25     284807 non-null  float64\n 26  V26     284807 non-null  float64\n 27  V27     284807 non-null  float64\n 28  V28     284807 non-null  float64\n 29  Amount  284807 non-null  float64\n 30  Class   284807 non-null  int64  \ndtypes: float64(30), int64(1)\nmemory usage: 67.4 MB\n\n\n\n# Class데이터 : 일반거래(0)와 이상거래(1) 건수\ndf['Class'].value_counts()\n\nClass\n0    284315\n1       492\nName: count, dtype: int64\n\n\n\n# Class데이터 : 일반거래(0)와 이상거래(1) 비중\ndf[df['Amount']==0]['Class'].value_counts(normalize=True)\n\nClass\n0    0.985205\n1    0.014795\nName: proportion, dtype: float64\n\n\n\n# Amount = 0인 데이터\ndf[df['Amount']==0]['Class'].value_counts()\n\nClass\n0    1798\n1      27\nName: count, dtype: int64\n\n\n\n# t-sne 구현 샘플 (분류 분포를 확인해보고자 했으나, 차원 및 데이터가 많아서인지 너무 오래걸려서 코드만 보존)\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Assume we have a high-dimensional dataset X\nX = df[['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10',\n       'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20',\n       'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']]\n\n# Create a t-SNE model with 2 components (for 2D visualization)\ntsne = TSNE(n_components=2, random_state=0)\n\n# Fit and transform the data\nX_tsne = tsne.fit_transform(X)\n\n# Visualize the results\nplt.scatter(X_tsne[:, 0], X_tsne[:, 1])\nplt.show()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240715/index.html#dataframe의-데이터-확인",
    "href": "posts/meta-dl-creditcard-20240715/index.html#dataframe의-데이터-확인",
    "title": "[M_Study_최종과제_개선1] 신용카드 이상거래 탐지 모델링",
    "section": "DataFrame의 데이터 확인",
    "text": "DataFrame의 데이터 확인\n\n전체 데이터 : Null값 없음을 확인\n\nTime 컬럼 : 첫번째 거래와의 단순 시간차이이므로 삭제 예정\nV1 ~ V28 컬럼 : 익명화된 데이터. 전부 사용\nAmount 컬럼\n\n특이사항 : 결제액이 0인 데이터가 있어, 월정액 등록 전 Validation용 결제가 아닐까 추정\n이상거래(Class 1)도 데이터로 포함되어있지만, 실질적 돈 이동이 없어 의미가 있는지 의문\n\n위 이유로 처음에는 결제액 0인 데이터를 제거할까 고민\n몇 없는 이상거래 데이터이므로 유지하는 것으로 결정 (전체 492개 이상거래 중 27건 제거시 약 5%의 데이터 손실)\n\n\nClass 컬럼\n\n특이사항 : 98%가 정상거래(Class 0)인 데이터로 편중이 심함\n데이터가 Imbalance한 경우, Accuracy는 성능측정에 한계가 있으므로, F1-Score를 사용\n\n\n\n\n# df.info()를 통한 null값 및 컬럼 확인\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 284807 entries, 0 to 284806\nData columns (total 31 columns):\n #   Column  Non-Null Count   Dtype  \n---  ------  --------------   -----  \n 0   Time    284807 non-null  float64\n 1   V1      284807 non-null  float64\n 2   V2      284807 non-null  float64\n 3   V3      284807 non-null  float64\n 4   V4      284807 non-null  float64\n 5   V5      284807 non-null  float64\n 6   V6      284807 non-null  float64\n 7   V7      284807 non-null  float64\n 8   V8      284807 non-null  float64\n 9   V9      284807 non-null  float64\n 10  V10     284807 non-null  float64\n 11  V11     284807 non-null  float64\n 12  V12     284807 non-null  float64\n 13  V13     284807 non-null  float64\n 14  V14     284807 non-null  float64\n 15  V15     284807 non-null  float64\n 16  V16     284807 non-null  float64\n 17  V17     284807 non-null  float64\n 18  V18     284807 non-null  float64\n 19  V19     284807 non-null  float64\n 20  V20     284807 non-null  float64\n 21  V21     284807 non-null  float64\n 22  V22     284807 non-null  float64\n 23  V23     284807 non-null  float64\n 24  V24     284807 non-null  float64\n 25  V25     284807 non-null  float64\n 26  V26     284807 non-null  float64\n 27  V27     284807 non-null  float64\n 28  V28     284807 non-null  float64\n 29  Amount  284807 non-null  float64\n 30  Class   284807 non-null  int64  \ndtypes: float64(30), int64(1)\nmemory usage: 67.4 MB\n\n\n\n# Class데이터 : 일반거래(0)와 이상거래(1) 건수\ndf['Class'].value_counts()\n\nClass\n0    284315\n1       492\nName: count, dtype: int64\n\n\n\n# Class데이터 : 일반거래(0)와 이상거래(1) 비중\ndf[df['Amount']==0]['Class'].value_counts(normalize=True)\n\nClass\n0    0.985205\n1    0.014795\nName: proportion, dtype: float64\n\n\n\n# Amount = 0인 데이터\ndf[df['Amount']==0]['Class'].value_counts()\n\nClass\n0    1798\n1      27\nName: count, dtype: int64\n\n\n\ndf.columns\n\nIndex(['Time', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10',\n       'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20',\n       'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount',\n       'Class'],\n      dtype='object')\n\n\n\n# t-sne 구현 샘플 (분류 분포를 확인해보고자 했으나, 시간 오래걸림)\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Assume we have a high-dimensional dataset X\nX = df[['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10',\n       'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20',\n       'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']]\n\n# Create a t-SNE model with 2 components (for 2D visualization)\ntsne = TSNE(n_components=2, random_state=0)\n\n# Fit and transform the data\nX_tsne = tsne.fit_transform(X)\n\n# Visualize the results\nplt.scatter(X_tsne[:, 0], X_tsne[:, 1])\nplt.show()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240715/index.html#데이터셋-구성",
    "href": "posts/meta-dl-creditcard-20240715/index.html#데이터셋-구성",
    "title": "[MStudy_과제개선1] 신용카드 이상거래 탐지 모델링",
    "section": "데이터셋 구성",
    "text": "데이터셋 구성\n\n불필요한 컬럼 제거 및 X, Y 분할\n\ndf_x = df.drop(['Time', 'Class'], axis=1).copy()\ndf_y = df['Class'].copy()\n\ndf_x.shape, df_y.shape\n\n((284807, 29), (284807,))\n\n\n\n\nTrain, Validation, Test 데이터 나누기(stratify옵션 비교, 학습에 미사용)\n\nLabel 비율을 맞추는 stratify옵션에 따른 Label값 수 확인\n단순히 Train, Validation, Test를 나누는 것과, kfold로 나누고 모델링에서 비교해볼 예정\n\n비율은 Train, Validation, Test 8:1:1 가깝게 설정\n\nScikit learn의 train_test_split 사용\nTest data에서 약간의 차이가 있었다 (미적용시 40, 적용시 49)\n\n\n# stratify 미적용\n\nfrom sklearn.model_selection import train_test_split\n\nx_train, x_test, ty_train, y_test = train_test_split(df_x, df_y, test_size=0.1)\n\nprint(f\"{x_train.shape}, {x_test.shape}\")\nprint(f\"{y_train.shape}, {y_test.shape}\")\nprint()\nprint(f\"y_train {y_train.value_counts()}\")\nprint(f\"y_test {y_test.value_counts()}\")\n\n(256326, 29), (28481, 29)\n(256326,), (28481,)\n\ny_train Class\n0    255883\n1       443\nName: count, dtype: int64\ny_test Class\n0    28441\n1       40\nName: count, dtype: int64\n\n\n\n# stratify 적용\n\nfrom sklearn.model_selection import train_test_split\n\nx_train, x_test, y_train, y_test = train_test_split(df_x, df_y, test_size=0.1, stratify=df_y)\n\nprint(f\"{x_train.shape}, {x_test.shape}\")\nprint(f\"{y_train.shape}, {y_test.shape}\")\nprint()\nprint(f\"y_train {y_train.value_counts()}\")\nprint(f\"y_test {y_test.value_counts()}\")\n\n(256326, 29), (28481, 29)\n(256326,), (28481,)\n\ny_train Class\n0    255883\n1       443\nName: count, dtype: int64\ny_test Class\n0    28432\n1       49\nName: count, dtype: int64\n\n\n\n\nTrain, Validation, Test 나누기(학습에 사용)\n\nTest set 먼저 분리하여, 이후 평가에서 공통적으로 사용\nTrain, Validation은 각각 다른 방법으로 나누어 사용\n\n\nTest set 나누기(공통)\n\n단순히 비율로 나눈 데이터셋의 변수명\n\nx_train_2, x_validation_2, x_test\ny_train_2, y_validation_2, y_test\n\n\n\n# Train, Test 나누기\nfrom sklearn.model_selection import train_test_split\n\n# stratify 적용\nx_train, x_test, y_train, y_test = train_test_split(df_x, df_y, test_size=0.1, stratify=df_y)\n\nprint(f\"{x_train.shape}, {x_test.shape}\")\nprint(f\"{y_train.shape}, {y_test.shape}\")\nprint()\nprint(f\"y_train {y_train.value_counts()}\")\nprint(f\"y_test {y_test.value_counts()}\")\n\n(256326, 29), (28481, 29)\n(256326,), (28481,)\n\ny_train Class\n0    255883\n1       443\nName: count, dtype: int64\ny_test Class\n0    28432\n1       49\nName: count, dtype: int64\n\n\n\n\nTrain, Validation 나누기(단순히 비율만 고려)\n\n단순히 비율로 나눈 데이터셋의 변수명\n\nx_train_2, x_validation_2, x_test\ny_train_2, y_validation_2, y_test\n\n\n\n# Train, Validation 나누기\nx_train_2, x_validation_2, y_train_2, y_validation_2 = train_test_split(x_train, y_train, test_size=1/9, stratify=y_train)\nprint(f\"{x_train_2.shape}, {x_validation_2.shape}\")\nprint(f\"{y_train_2.shape}, {y_validation_2.shape}\")\nprint()\nprint(f\"y_train {y_train_2.value_counts()}\")\nprint(f\"validation {y_validation_2.value_counts()}\")\n\n(227845, 29), (28481, 29)\n(227845,), (28481,)\n\ny_train Class\n0    227451\n1       394\nName: count, dtype: int64\nvalidation Class\n0    28432\n1       49\nName: count, dtype: int64\n\n\n\n\nTrain, Validation 나누기(StratifiedKFold적용)\n\n분류문제인 경우 StratifiedKFold 적용, 회귀인 경우에는 사용하지 않음\nStratifiedKFold 적용 데이터셋의 변수명\n\nkfold_dataset[idx][‘x_train’], kfold_dataset[idx][‘x_validation’], x_test\nkfold_dataset[idx][‘y_train’], kfold_dataset[idx][‘y_validation’], y_test\n\n\n\nfrom sklearn.model_selection import StratifiedKFold\n\n# Train, Validation 나누기\nkfold_dataset = {}\n\ns_kfold = StratifiedKFold(n_splits=9)\nfor i, (train_index, validation_index) in enumerate(s_kfold.split(x_train, y_train)):\n    kfold_dataset[i] = {'x_train': x_train.iloc[train_index], # Scaler 적용시 .iloc삭제\n                        'y_train': y_train.iloc[train_index], # Scaler 적용시 .iloc삭제\n                        'x_validation' : x_train.iloc[validation_index], # Scaler 적용시 .iloc삭제\n                        'y_validation' : y_train.iloc[validation_index]  # Scaler 적용시 .iloc삭제\n                        }\n    \nfor idx in kfold_dataset.keys():\n    print(f\"Train set{idx} : {kfold_dataset[idx]['x_train'].shape}, {kfold_dataset[idx]['y_train'].shape}\")\n    print(f\"Validation set{idx} : {kfold_dataset[idx]['x_validation'].shape}, {kfold_dataset[idx]['y_validation'].shape}\")\n    print()\n\nTrain set0 : (227845, 29), (227845,)\nValidation set0 : (28481, 29), (28481,)\n\nTrain set1 : (227845, 29), (227845,)\nValidation set1 : (28481, 29), (28481,)\n\nTrain set2 : (227845, 29), (227845,)\nValidation set2 : (28481, 29), (28481,)\n\nTrain set3 : (227845, 29), (227845,)\nValidation set3 : (28481, 29), (28481,)\n\nTrain set4 : (227845, 29), (227845,)\nValidation set4 : (28481, 29), (28481,)\n\nTrain set5 : (227845, 29), (227845,)\nValidation set5 : (28481, 29), (28481,)\n\nTrain set6 : (227846, 29), (227846,)\nValidation set6 : (28480, 29), (28480,)\n\nTrain set7 : (227846, 29), (227846,)\nValidation set7 : (28480, 29), (28480,)\n\nTrain set8 : (227846, 29), (227846,)\nValidation set8 : (28480, 29), (28480,)"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240715/index.html#모델-구성",
    "href": "posts/meta-dl-creditcard-20240715/index.html#모델-구성",
    "title": "[MStudy_과제개선1] 신용카드 이상거래 탐지 모델링",
    "section": "모델 구성",
    "text": "모델 구성\n\n기존에 f1 score를 위해 사용하려던 tensorflow_addons는 개발종료되어 다른 패키지로 대체\n단순 f1 score가 아닌 weighted f1 score사용\n\n\n기초 딥러닝 모델(비율로 단순히 나눈 데이터셋 vs StratifiedKFold 비교)\n\n딥러닝 모델(StratifiedKFold 미적용)\n\nimport tensorflow as tf\nfrom tensorflow.keras.metrics import Precision, Recall, F1Score\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# 모델링\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Input((29,1)),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation='relu'),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(1, activation='sigmoid') # 또는 2, Softmax 사용가능\n])\n\nmodel.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=[F1Score(average=\"weighted\"), Precision(), Recall()])\n\n# 학습 및 평가\n## 모델 학습\nmodel_history = model.fit(x_train_2, y_train_2, \n                    epochs=10, verbose=0,\n                    validation_data=(x_validation_2, y_validation_2))\n\n## 모델 평가\nprint('* 모델평가')\nresult_train = model.evaluate(x_train_2, y_train_2, verbose=2)\nresult_validate = model.evaluate(x_test, y_test, verbose=2)\n\n* 모델평가\n7121/7121 - 4s - 562us/step - f1_score: 0.0035 - loss: 0.0041 - precision_6: 0.9545 - recall_6: 0.7462\n891/891 - 1s - 568us/step - f1_score: 0.0035 - loss: 0.0037 - precision_6: 0.9211 - recall_6: 0.7143\n\n\n\n# 시각화 (Train, Validation score)\nfig, axs = plt.subplots(nrows=4, ncols=1, figsize=(10,20))\n\nfor idx, key in enumerate(model_history.history.keys()):\n    if idx == 4:\n        break\n    axs[idx].plot(model_history.history[key], label=f\"train_{key}\")\n    axs[idx].plot(model_history.history[f\"val_{key}\"], label=f\"val_{key}\")\n    axs[idx].legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n딥러닝 모델(StratifiedKFold 적용)\n\nimport tensorflow as tf\nfrom tensorflow.keras.metrics import Precision, Recall, F1Score\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# 모델링\nmodel_2 = tf.keras.models.Sequential([\n    tf.keras.layers.Input((29,1)),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation='relu'),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(1, activation='sigmoid') # 또는 2, Softmax 사용가능\n])\n\nmodel_2.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=[F1Score(average=\"weighted\"), Precision(), Recall()])\n\n# 학습 및 평가\nkfold_result_train = {}\nkfold_result_validate = {}\nkfold_model_history = {}\n\nfor idx in kfold_dataset.keys():\n    ## 모델 학습\n    kfold_model_history[idx] = model_2.fit(kfold_dataset[idx]['x_train'],  kfold_dataset[idx]['y_train'], \n                        epochs=10, verbose=0,\n                        validation_data=(kfold_dataset[idx]['x_validation'], kfold_dataset[idx]['y_validation']))\n\n    ## 모델 평가\n    print(f'* 모델평가_{idx}')\n    kfold_result_train[idx] = model_2.evaluate(kfold_dataset[idx]['x_train'],kfold_dataset[idx]['y_train'], verbose=2)\n    kfold_result_validate[idx] = model_2.evaluate(x_test, y_test, verbose=2)\n\n* 모델평가_0\n7121/7121 - 4s - 574us/step - f1_score: 0.0037 - loss: 0.0081 - precision_7: 0.8941 - recall_7: 0.7284\n891/891 - 1s - 583us/step - f1_score: 0.0037 - loss: 0.0059 - precision_7: 0.8421 - recall_7: 0.6531\n* 모델평가_1\n7121/7121 - 4s - 570us/step - f1_score: 0.0039 - loss: 0.0065 - precision_7: 0.9078 - recall_7: 0.7995\n891/891 - 1s - 590us/step - f1_score: 0.0038 - loss: 0.0053 - precision_7: 0.9000 - recall_7: 0.7347\n* 모델평가_2\n7121/7121 - 4s - 579us/step - f1_score: 0.0042 - loss: 0.0053 - precision_7: 0.9050 - recall_7: 0.8223\n891/891 - 1s - 603us/step - f1_score: 0.0042 - loss: 0.0047 - precision_7: 0.9024 - recall_7: 0.7551\n* 모델평가_3\n7121/7121 - 4s - 574us/step - f1_score: 0.0046 - loss: 0.0048 - precision_7: 0.9440 - recall_7: 0.8122\n891/891 - 1s - 595us/step - f1_score: 0.0045 - loss: 0.0054 - precision_7: 0.8974 - recall_7: 0.7143\n* 모델평가_4\n7121/7121 - 4s - 574us/step - f1_score: 0.0048 - loss: 0.0066 - precision_7: 0.9493 - recall_7: 0.8092\n891/891 - 1s - 601us/step - f1_score: 0.0048 - loss: 0.0055 - precision_7: 0.9000 - recall_7: 0.7347\n* 모델평가_5\n7121/7121 - 4s - 565us/step - f1_score: 0.0042 - loss: 0.0027 - precision_7: 0.9149 - recall_7: 0.8753\n891/891 - 1s - 580us/step - f1_score: 0.0042 - loss: 0.0027 - precision_7: 0.8636 - recall_7: 0.7755\n* 모델평가_6\n7121/7121 - 4s - 571us/step - f1_score: 0.0054 - loss: 0.0050 - precision_7: 0.9016 - recall_7: 0.8604\n891/891 - 1s - 598us/step - f1_score: 0.0054 - loss: 0.0047 - precision_7: 0.8444 - recall_7: 0.7755\n* 모델평가_7\n7121/7121 - 4s - 567us/step - f1_score: 0.0061 - loss: 0.0047 - precision_7: 0.9387 - recall_7: 0.8553\n891/891 - 1s - 599us/step - f1_score: 0.0060 - loss: 0.0047 - precision_7: 0.9231 - recall_7: 0.7347\n* 모델평가_8\n7121/7121 - 4s - 573us/step - f1_score: 0.0071 - loss: 0.0024 - precision_7: 0.9479 - recall_7: 0.8782\n891/891 - 1s - 598us/step - f1_score: 0.0072 - loss: 0.0033 - precision_7: 0.9000 - recall_7: 0.7347\n\n\n\n# 시각화\nfig, axs = plt.subplots(nrows=4, ncols=1, figsize=(10,20))\n\nfor idx, key in enumerate(kfold_model_history[8].history.keys()):\n    if idx == 4:\n        break\n    axs[idx].plot(kfold_model_history[8].history[key], label=f\"train_{key}\")\n    axs[idx].plot(kfold_model_history[8].history[f\"val_{key}\"], label=f\"val_{key}\")\n    axs[idx].legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nStratifiedKFold 적용유무에 따른 수치 비교\n\n적용 후 Precision을 제외한 Test지표 향상됨\n\n모델평가(적용X)\n\n7121/7121 - 4s - 562us/step - f1_score: 0.0035 - loss: 0.0041 - precision_6: 0.9545 - recall_6: 0.7462\n891/891 - 1s - 568us/step - f1_score: 0.0035 - loss: 0.0037 - precision_6: 0.9211 - recall_6: 0.7143\n\n모델평가(적용O)\n\n7121/7121 - 4s - 573us/step - f1_score: 0.0071 - loss: 0.0024 - precision_7: 0.9479 - recall_7: 0.8782\n891/891 - 1s - 598us/step - f1_score: 0.0072 - loss: 0.0033 - precision_7: 0.9000 - recall_7: 0.7347\n\n\n적용 후 Precision을 제외한 Train, Validation지표 향상\n\n\nimport koreanize_matplotlib\n\n# 시각화\nfig, axs = plt.subplots(nrows=4, ncols=2, figsize=(16,30))\n\n# 그래프간 비교를 위해, y축 고정을 위한 최대/최소값 계산\ngraph_min = {'f1_score':0.003,\n'loss':0.002,\n'precision':0.3,\n'recall':0.5}\ngraph_max = {'f1_score':0.009,\n'loss':0.04,\n'precision':1,\n'recall':0.9}\n\n\n# 그래프1\nfor idx, key in enumerate(model_history.history.keys()):\n    if idx == 4:\n        break\n    axs[idx, 0].plot(model_history.history[key], label=f\"train_{key}\")\n    axs[idx, 0].plot(model_history.history[f\"val_{key}\"], label=f\"val_{key}\")\n    axs[idx, 0].set_title(f\"fold적용전_{key}\")\n    axs[idx, 0].set_ylim([graph_min[key.replace('_6','').replace('_7','')], graph_max[key.replace('_6','').replace('_7','')] ])\n    axs[idx, 0].legend()\n\n# 그래프2\nfor idx, key in enumerate(kfold_model_history[8].history.keys()):\n    if idx == 4:\n        break\n\n    axs[idx, 1].plot(kfold_model_history[8].history[key], label=f\"train_{key}\")\n    axs[idx, 1].plot(kfold_model_history[8].history[f\"val_{key}\"], label=f\"val_{key}\")\n    axs[idx, 1].set_title(f\"fold적용후_{key}\")\n    axs[idx, 1].set_ylim([graph_min[key.replace('_6','').replace('_7','')], graph_max[key.replace('_6','').replace('_7','')]])\n    axs[idx, 1].legend()\n\nplt.show()"
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240716/index.html",
    "href": "posts/meta-dl-creditcard-20240716/index.html",
    "title": "[MStudy_과제개선2] 신용카드 이상거래 탐지 모델링",
    "section": "",
    "text": "Kaggle CreditCard Fraud Detection (개선2 : Keras tuner, Hyperband search)\n\n개요\n\n딥러닝 스터디에 제출했던 과제에 대한 피드백 반영 및 개선(지속 개선예정)\n원본데이터 : Kaggle CreditCard Fraud Detection\n적용한 피드백\n\nKeras tuner 사용시 처음부터 Learning rate를 Test대상에 포함\nEarly stopping이 아닌 전체 epoch 수행 후 최적포인트를 적용하는 방법도 해보려했으나, 학습자체에 시간이 오래걸려 제외\n\n추가 테스트\n\n다른 Adam계열 Optimizer를 Keras tuner후보군에 추가\nEarly stopping에 대해 Keras callback의 ReduceLROnPlateau도 사용해봄\nRandom search, Grid Search 를 알아보다가 Hyperband라는 것도 있어서 사용해봄\n\nRandom search는 무작위 탐색으로 효율적이지만 최적일수도 있고 아닐수도 있음\nGrid search는 가능한 모든 조합을 탐색하여 오래 걸림\n효율적이지만 최적이 아닐 확률이 있다는 점과 가정용 컴퓨터에서 계산효율적이지 못한 방법론이 맞는지에 대한 고민\nHyperband가 정해진 시간내에 중간 결과를 기준으로 조합 후보를 버리는 등 결합된 방법론으로 보여 적용해봄\n\n수업에 나온 Leaky ReLU도 적용해보고 싶었지만, Tuner호환 등 여러 문제가 있어 제외함\n학습한 모델은 저장해두고 향후 다른 것도 해보기\n\n결과\n\n초보 수준에서는 Tuner가 좋은 파라미터를 정해줄 것을 기대하여 막연히 점수가 개선될 것을 기대했으나, 실험 결과로는 유의미한 개선점이 보이지는 않았음\n\n모델평가(Stratified Fold만 적용)\n\n[Train]7121/7121 - 4s - 573us/step - f1_score: 0.0071 - loss: 0.0024 - precision_7: 0.9479 - recall_7: 0.8782\n[Test]891/891 - 1s - 598us/step - f1_score: 0.0072 - loss: 0.0033 - precision_7: 0.9000 - recall_7: 0.7347\n\n모델평가(Tuner + Learning rate scheduler + Early stopping 추가 적용)\n\n[Train]8011/8011 - 6s - 741us/step - f1_score: 0.0035 - loss: 0.0151 - precision: 0.8372 - recall: 0.8126\n[Test]891/891 - 1s - 772us/step - f1_score: 0.0034 - loss: 0.0216 - precision: 0.7600 - recall: 0.7755\n\n\nOptimizer나 Hyperband 등 세부적인 내용의 고려 없이 적용되어 긍정적인 결과가 나오지 않은 것으로 추정\n\n\n\n\n개선과제 진행\n\nKeras Tuner 사용한 딥러닝 모델 개선\n\nLearning rate를 처음 튜닝부터 포함\nOptimizer를 다양하게 고려 (Adam계열)\nLeaky ReLU를 Activation 후보군에 포함하려했으나, Tuner지원하지않는 것으로 보여 제외\n\nChoice 함수에는 int, float, str, bool만 가능하여 아래와 같이 추가했음\n\n  from keras.utils import get_custom_objects\n  from keras.layers import LeakyReLU\n\n  get_custom_objects().update({'leaky-relu': LeakyReLU()}) # Add LeakyReLU\n  activation = hp.Choice('activation'+str(i),values=['relu','elu','leaky-relu']) # For Activation\n\n그러나 아래의 오류가 계속 발생하여 제외함\n\n  &gt;&gt;&gt; ValueError: Could not interpret activation function identifier: leaky-relu\n\n\nimport keras_tuner as kt\nimport tensorflow as tf\nfrom tensorflow.keras.metrics import Precision, Recall, F1Score\nimport matplotlib.pyplot as plt\n\n\ndef build_model(hp):\n    model = tf.keras.models.Sequential()\n\n    # Input & Flatten\n    model.add(tf.keras.layers.Input((29,1)))\n    model.add(tf.keras.layers.Flatten())\n\n    # Hidden Layers\n    for i in range(hp.Int('num_layers',min_value=1,max_value=20)):\n\n        # For Dense\n        units = hp.Int('units',min_value=10,max_value=150,step=5) # For Neurons\n        activation = hp.Choice('activation'+str(i),values=['relu','elu']) # For Activation\n\n        model.add(tf.keras.layers.Dense(units, activation=activation,\n                                        # 기본값은 glorot_uniform(Xavier), He는 Kaiming\n                                        kernel_initializer=tf.keras.initializers.HeNormal())) \n        \n        # Add Batch Normalization\n        model.add(tf.keras.layers.BatchNormalization()) # Layer통과후 & Activation 전\n        \n        # For Dropout\n        dropout_rate = hp.Choice('dropout'+str(i),values=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9])\n        model.add(tf.keras.layers.Dropout(dropout_rate))\n\n    model.add(tf.keras.layers.Dense(1, activation='sigmoid')) # 이진분류이므로 Sigmoid사용\n    \n    # Model setting\n    hp_learning_rate = hp.Choice('learning_rate', values = [0.05, 0.01, 0.001]) \n    dict_optimizers_with_lr = {\n        'Adam': tf.keras.optimizers.Adam(learning_rate=hp_learning_rate),\n        'Nadam': tf.keras.optimizers.Nadam(learning_rate=hp_learning_rate),\n        'AdamW': tf.keras.optimizers.AdamW(learning_rate=hp_learning_rate),\n        'Adamax': tf.keras.optimizers.Adamax(learning_rate=hp_learning_rate)\n        }\n    hp_optimizer=hp.Choice('optimizer',values=['Adam','Nadam','AdamW','Adamax'])\n\n    model.compile(optimizer=dict_optimizers_with_lr[hp_optimizer], \n                  loss='binary_crossentropy',\n                  metrics=[F1Score(average=\"weighted\"), Precision(), Recall()])\n    \n    return model\n\n\nwith tf.device('/device:GPU:0'):    \n    tuner = kt.Hyperband(build_model,\n                     objective = kt.Objective('val_f1_score', direction='max'), \n                     max_epochs = 10,\n                     project_name = 'test_hyperband')\n    \n    for idx in kfold_dataset.keys():\n    ## 모델 학습\n        tuner.search(kfold_dataset[idx]['x_train'],  kfold_dataset[idx]['y_train'],\n                                            epochs=10,\n                                            validation_data=(kfold_dataset[idx]['x_validation'], kfold_dataset[idx]['y_validation']))\n\nTrial 30 Complete [00h 02m 29s]\nval_f1_score: 0.00343498052097857\n\nBest val_f1_score So Far: 0.4999999403953552\nTotal elapsed time: 00h 45m 46s\n\n\n\ntuner.get_best_hyperparameters()[0].values\n\n{'num_layers': 4,\n 'units': 105,\n 'activation0': 'elu',\n 'dropout0': 0.5,\n 'learning_rate': 0.05,\n 'optimizer': 'Nadam',\n 'activation1': 'relu',\n 'dropout1': 0.6,\n 'activation2': 'relu',\n 'dropout2': 0.9,\n 'activation3': 'elu',\n 'dropout3': 0.3,\n 'activation4': 'relu',\n 'dropout4': 0.9,\n 'activation5': 'elu',\n 'dropout5': 0.4,\n 'activation6': 'elu',\n 'dropout6': 0.3,\n 'activation7': 'elu',\n 'dropout7': 0.2,\n 'activation8': 'elu',\n 'dropout8': 0.5,\n 'activation9': 'elu',\n 'dropout9': 0.6,\n 'activation10': 'elu',\n 'dropout10': 0.5,\n 'activation11': 'relu',\n 'dropout11': 0.9,\n 'activation12': 'elu',\n 'dropout12': 0.6,\n 'activation13': 'elu',\n 'dropout13': 0.3,\n 'activation14': 'relu',\n 'dropout14': 0.5,\n 'activation15': 'elu',\n 'dropout15': 0.8,\n 'activation16': 'elu',\n 'dropout16': 0.2,\n 'activation17': 'elu',\n 'dropout17': 0.1,\n 'activation18': 'elu',\n 'dropout18': 0.2,\n 'activation19': 'elu',\n 'dropout19': 0.5,\n 'tuner/epochs': 10,\n 'tuner/initial_epoch': 0,\n 'tuner/bracket': 0,\n 'tuner/round': 0}\n\n\n\nmodel_by_tuner= tuner.get_best_models(num_models=1)[0]\nmodel_by_tuner.summary()\n\nModel: \"sequential\"\n\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ Layer (type)                    ┃ Output Shape           ┃       Param # ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ flatten (Flatten)               │ (None, 29)             │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense (Dense)                   │ (None, 105)            │         3,150 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization             │ (None, 105)            │           420 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout (Dropout)               │ (None, 105)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_1 (Dense)                 │ (None, 105)            │        11,130 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_1           │ (None, 105)            │           420 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_1 (Dropout)             │ (None, 105)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_2 (Dense)                 │ (None, 105)            │        11,130 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_2           │ (None, 105)            │           420 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_2 (Dropout)             │ (None, 105)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_3 (Dense)                 │ (None, 105)            │        11,130 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ batch_normalization_3           │ (None, 105)            │           420 │\n│ (BatchNormalization)            │                        │               │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dropout_3 (Dropout)             │ (None, 105)            │             0 │\n├─────────────────────────────────┼────────────────────────┼───────────────┤\n│ dense_4 (Dense)                 │ (None, 1)              │           106 │\n└─────────────────────────────────┴────────────────────────┴───────────────┘\n\n\n\n Total params: 38,326 (149.71 KB)\n\n\n\n Trainable params: 37,486 (146.43 KB)\n\n\n\n Non-trainable params: 840 (3.28 KB)\n\n\n\n\n\n딥러닝 모델에 Learning rate scheduler와 Early stopping 적용\n\nLearning rate scheduler와 Early stopping 모두 weighted f1-score는 지원하지 않아, val_f1-score로 사용\n\n    UserWarning: Learning rate reduction is conditioned on metric `&lt;F1Score name=f1_score&gt;` \n    which is not available. Available metrics are\n    : f1_score,loss,precision,recall,val_f1_score,val_loss,val_precision,val_recall,learning_rate.\n    UserWarning: Early stopping conditioned on metric `&lt;F1Score name=f1_score&gt;` \n    which is not available. Available metrics are\n    : f1_score,loss,precision,recall,val_f1_score,val_loss,val_precision,val_recall,learning_rate\n\nfrom tensorflow.keras.callbacks import EarlyStopping\nfrom tensorflow.keras.callbacks import LearningRateScheduler\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau\nimport numpy as np\nimport keras\nimport matplotlib.pyplot as plt\n\n\ntotal_epoch_value = 1000\n\nwith tf.device('/device:GPU:0'):\n    reduce_lr = ReduceLROnPlateau(monitor='val_f1_score',\n                factor=0.2, # lr감소치. 현재 lr이 0.01이라면 0.01*0.2를 적용\n                patience=10, # 개선에 대한 허용치. 10 epoch까지 개선이 없다면 적용\n                mode='max', # auto, max, min 옵션 있음\n                min_lr=0.001)\n    es = EarlyStopping(monitor='val_f1_score', mode='max', verbose=1, patience=200)\n\n    # 모델 학습\n    for idx in kfold_dataset.keys():\n        history_tuner = model_by_tuner.fit(kfold_dataset[idx]['x_train'],  kfold_dataset[idx]['y_train'], \n                                        epochs=total_epoch_value,\n                                        callbacks=[reduce_lr, es],\n                                        validation_data=(kfold_dataset[idx]['x_validation'], kfold_dataset[idx]['y_validation']))\n\n\n# 시각화\nfig, axs = plt.subplots(nrows=4, ncols=1, figsize=(10,20))\n\nfor idx, key in enumerate(history_tuner.history.keys()):\n    if idx == 4:\n        break\n    axs[idx].plot(history_tuner.history[key], label=f\"train_{key}\")\n    axs[idx].plot(history_tuner.history[f\"val_{key}\"], label=f\"val_{key}\")\n    axs[idx].legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# 모델 평가\nprint('* 모델평가')\nmodel_by_tuner.evaluate(x_train, y_train, verbose=2)\nmodel_by_tuner.evaluate(x_test, y_test, verbose=2)\n\n* 모델평가\n8011/8011 - 6s - 741us/step - f1_score: 0.0035 - loss: 0.0151 - precision: 0.8372 - recall: 0.8126\n891/891 - 1s - 772us/step - f1_score: 0.0034 - loss: 0.0216 - precision: 0.7600 - recall: 0.7755\n\n\n[0.02163444086909294,\n 0.00343498052097857,\n 0.7599999904632568,\n 0.7755101919174194]\n\n\n\n모델평가(Stratified Fold만 적용)\n\n7121/7121 - 4s - 573us/step - f1_score: 0.0071 - loss: 0.0024 - precision_7: 0.9479 - recall_7: 0.8782\n891/891 - 1s - 598us/step - f1_score: 0.0072 - loss: 0.0033 - precision_7: 0.9000 - recall_7: 0.7347\n\n모델평가(Tuner + Learning rate scheduler + Early stopping 추가 적용)\n\n8011/8011 - 6s - 741us/step - f1_score: 0.0035 - loss: 0.0151 - precision: 0.8372 - recall: 0.8126\n891/891 - 1s - 772us/step - f1_score: 0.0034 - loss: 0.0216 - precision: 0.7600 - recall: 0.7755\n\n\n\n\n학습한 모델 저장\n\nmodel_by_tuner.save('model_by_tuner_fitted.keras')\n\n\nloadedm_model = keras.models.load_model('model_by_tuner.keras')\nprint('* 모델평가')\nloadedm_model.evaluate(x_train, y_train, verbose=2)\nloadedm_model.evaluate(x_test, y_test, verbose=2)\n\n* 모델평가\n8011/8011 - 8s - 1ms/step - f1_score: 0.0035 - loss: 0.0151 - precision: 0.8372 - recall: 0.8126\n891/891 - 1s - 786us/step - f1_score: 0.0034 - loss: 0.0216 - precision: 0.7600 - recall: 0.7755\n\n\n[0.02163444086909294,\n 0.00343498052097857,\n 0.7599999904632568,\n 0.7755101919174194]\n\n\n\n\n\n\n\nCopyright © 2024 Kibok Park All rights reserved."
  },
  {
    "objectID": "posts/meta-dl-creditcard-20240716/index.html#모델-구성-및-학습머신러닝",
    "href": "posts/meta-dl-creditcard-20240716/index.html#모델-구성-및-학습머신러닝",
    "title": "[MStudy_과제개선2] 신용카드 이상거래 탐지 모델링",
    "section": "모델 구성 및 학습(머신러닝)",
    "text": "모델 구성 및 학습(머신러닝)\n\nXGB, Random forest\noptuna"
  }
]