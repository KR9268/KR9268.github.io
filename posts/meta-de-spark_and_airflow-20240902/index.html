<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kibok Park">
<meta name="dcterms.date" content="2024-09-02">

<title>[DE스터디/4주차강의] 다양한 데이터처리 플랫폼을 사용한 데이터 수집~모니터링 – Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.jpg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-04dd6a5ca28aac96903e51a8fbffbcaa.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-eadd22555550656e957725f4adb214c0.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/watermark-1.0.11/watermark.min.js"></script>
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LPL499WQBH"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LPL499WQBH', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index_dashboards.html"> 
<span class="menu-text">Dashboards</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index_miniprojects.html"> 
<span class="menu-text">Mini Projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/KR9268"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/%EA%B8%B0%EB%B3%B5-%EB%B0%95-573a68268/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[DE스터디/4주차강의] 다양한 데이터처리 플랫폼을 사용한 데이터 수집~모니터링</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Spark</div>
                <div class="quarto-category">PySpark</div>
                <div class="quarto-category">Elasticsearch</div>
                <div class="quarto-category">202408Study_DataEngineering</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Kibok Park </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 2, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#개요" id="toc-개요" class="nav-link active" data-scroll-target="#개요">개요</a></li>
  <li><a href="#주차-과제리뷰" id="toc-주차-과제리뷰" class="nav-link" data-scroll-target="#주차-과제리뷰">3주차 과제리뷰</a>
  <ul class="collapse">
  <li><a href="#정제코드-작성해보기" id="toc-정제코드-작성해보기" class="nav-link" data-scroll-target="#정제코드-작성해보기">정제코드 작성해보기</a></li>
  <li><a href="#spark-submit" id="toc-spark-submit" class="nav-link" data-scroll-target="#spark-submit">spark-submit</a></li>
  </ul></li>
  <li><a href="#주차-수업정리" id="toc-주차-수업정리" class="nav-link" data-scroll-target="#주차-수업정리">4주차 수업정리</a>
  <ul class="collapse">
  <li><a href="#elasticsearch" id="toc-elasticsearch" class="nav-link" data-scroll-target="#elasticsearch">Elasticsearch</a></li>
  <li><a href="#elasticsearch-index" id="toc-elasticsearch-index" class="nav-link" data-scroll-target="#elasticsearch-index">Elasticsearch index</a></li>
  <li><a href="#queryes에서-쿼리하는법" id="toc-queryes에서-쿼리하는법" class="nav-link" data-scroll-target="#queryes에서-쿼리하는법">Query(ES에서 쿼리하는법)</a></li>
  <li><a href="#optimization" id="toc-optimization" class="nav-link" data-scroll-target="#optimization">Optimization</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>데이터 엔지니어링 스터디 내용정리 - Elasticsearch</p>
<section id="개요" class="level1">
<h1>개요</h1>
<ul>
<li>참여중인 데이터 엔지니어링 스터디에서 배우는 내용 정리
<ul>
<li>데이터 수집, 정제 : pyspark, airflow</li>
<li>저장 : elasticsearch</li>
<li>시각화 : kibana</li>
</ul></li>
</ul>
</section>
<section id="주차-과제리뷰" class="level1">
<h1>3주차 과제리뷰</h1>
<section id="정제코드-작성해보기" class="level2">
<h2 class="anchored" data-anchor-id="정제코드-작성해보기">정제코드 작성해보기</h2>
<ul>
<li>jobs
<ul>
<li>main.py
<ul>
<li><p>Spark initialization + filter(정제) + 저장</p></li>
<li><p>공통기능</p></li>
<li><p>추후 자동화될 부분 고려되어있는 코드</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  parser <span class="op">=</span> argparse.ArgumentParser()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  parser.add_argument(<span class="st">"--target_date"</span>, default<span class="op">=</span><span class="va">None</span>, <span class="bu">help</span><span class="op">=</span><span class="st">"optional:target date(yyyy-mm-dd)"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  args <span class="op">=</span> parser.parse_args()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...(생략)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> args.target_date <span class="kw">is</span> <span class="va">None</span>: <span class="co"># 정제실패시 다시돌릴 때 편의를 위함</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      args.target_date <span class="op">=</span> (datetime.now() <span class="op">-</span> timedelta(<span class="dv">1</span>)).strftime(<span class="st">'%Y-%m-</span><span class="sc">%d</span><span class="st">'</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  args.input_path <span class="op">=</span> <span class="ss">f"/opt/bitnami/spark/data/</span><span class="sc">{</span>args<span class="sc">.</span>target_date<span class="sc">}</span><span class="ss">-*.json"</span> <span class="co"># 데이터명이 날짜일 예정</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li>filter.py
<ul>
<li>정제코드(BaseFilter + TopRepoFilter)</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> base <span class="im">import</span> BaseFilter <span class="co"># base.py에서 가져옴</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TopRepoFilter(BaseFilter):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">filter</span>(<span class="va">self</span>, df):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Top 10 Repo: Push Count</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        repo_cnt_df <span class="op">=</span> df.groupBy(<span class="st">'repository_id'</span>, <span class="st">'repo_name'</span>).pivot(<span class="st">'type'</span>).count()</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        repo_cnt_df.where((F.col(<span class="st">'repository_id'</span>).isNotNull())) <span class="op">\</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                    .orderBy(F.desc(<span class="st">'PushEvent'</span>)) <span class="op">\</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                    .limit(<span class="dv">10</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> repo_cnt_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>정제코드(BaseFilter + DailyStatFilter)</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> base <span class="im">import</span> BaseFilter <span class="co"># base.py에서 가져옴</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DailyStatFilter(BaseFilter):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> hit_count(<span class="va">self</span>, df, cond, col_name):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># is_cond 컬럼을 만든 후, </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># F.col('type') == 'PushEvent' 와 같은 조건을 F.when(cond, 1)에 넣어 값이 조건에 맞으면(PushEvent) 1, 아니면(otherwise) 0</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># .agg(F.sum('is_cond').alias(col_name) 으로 합산 후 alias지정</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> df.withColumn(<span class="st">'is_cond'</span>, F.when(cond, <span class="dv">1</span>).otherwise(<span class="dv">0</span>)).agg(F.<span class="bu">sum</span>(<span class="st">'is_cond'</span>).alias(col_name))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">filter</span>(<span class="va">self</span>, df):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># daily stats</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">## 유니크한 유저  :  d_user_count  | 1000</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> df.agg(F.countDistinct(<span class="st">'user_name'</span>).alias(<span class="st">'d_user_count'</span>))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">## d_repo_count | 500 데이터프레임을 만든 후, crossjoin으로 합침  :  d_user_count, d_repo_count | 1000, 500</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> stat_df.crossJoin(df.agg(F.countDistinct(<span class="st">'repository_id'</span>).alias(<span class="st">'d_repo_count'</span>)))</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># push counts</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">## where절로 숫자를 구한 후 데이터프레임 생성작업이 필요없도록, hit_count함수로 구현</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">## </span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        push_cnt_df <span class="op">=</span> <span class="va">self</span>.hit_count(df, F.col(<span class="st">'type'</span>) <span class="op">==</span> <span class="st">'PushEvent'</span>, <span class="st">'push_count'</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        push_cnt_df <span class="op">=</span> push_cnt_df.cache() <span class="co"># 캐시를 호출하여 최적화에 도움</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> stat_df.crossJoin(push_cnt_df)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        pr_cnt_df <span class="op">=</span> <span class="va">self</span>.hit_count(df, F.col(<span class="st">'type'</span>) <span class="op">==</span> <span class="st">'PullRequestEvent'</span>, <span class="st">'pr_count'</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        pr_cnt_df <span class="op">=</span> pr_cnt_df.cache() <span class="co"># 캐시를 호출하여 최적화에 도움</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> stat_df.crossJoin(pr_cnt_df)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        fork_cnt_df <span class="op">=</span> <span class="va">self</span>.hit_count(df, F.col(<span class="st">'type'</span>) <span class="op">==</span> <span class="st">'ForkEvent'</span>, <span class="st">'fork_count'</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        fork_cnt_df <span class="op">=</span> fork_cnt_df.cache() <span class="co"># 캐시를 호출하여 최적화에 도움</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> stat_df.crossJoin(fork_cnt_df)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        commit_comment_cnt_df <span class="op">=</span> <span class="va">self</span>.hit_count(df, F.col(<span class="st">'type'</span>) <span class="op">==</span> <span class="st">'CommitCommentEvent'</span>, <span class="st">'commit_comment_count'</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        commit_comment_cnt_df <span class="op">=</span> commit_comment_cnt_df.cache()</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        stat_df <span class="op">=</span> stat_df.crossJoin(commit_comment_cnt_df)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        stat_df.show(<span class="dv">10</span>, <span class="va">False</span>)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> stat_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li>base.py
<ul>
<li>executor세팅 관련코드</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> read_input(spark, input_path):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _input_exists(input_path):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> glob.glob(input_path)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _input_exists(input_path):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> spark.read.json(input_path)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        df.printSchema()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 파티션의 수가 EXECUTOR보다 적으면 리파티션 (노는 EXECUTOR방지)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        max_executor_num <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> df.rdd.getNumPartitions() <span class="op">&lt;</span> max_executor_num:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> df.repartition(max_executor_num)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> df</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>메타정보 추가코드</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> df_with_meta(df, datetime):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.withColumn(<span class="st">"@timestamp"</span>, F.lit(datetime)) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
</ul>
</section>
<section id="spark-submit" class="level2">
<h2 class="anchored" data-anchor-id="spark-submit">spark-submit</h2>
<ul>
<li>참고사항
<ul>
<li>memory옵션(driver, executor), num-executors, executor-cores를 만져보기</li>
<li>gh archive데이터를 기준으로 메모리 3기가 정도가 원활해보임</li>
</ul>
<pre><code>spark-submit \
--name main.py \
--master spark://spark-master:7077 \
--jars "/opt/bitnami/spark/resources/elasticsearch-spark-30_2.12-8.4.3.jar" \
--conf spark.dynamicAllocation.enabled=true \
--conf spark.dynamicAllocation.executorIdleTimeout=2m \
--conf spark.dynamicAllocation.minExecutors=1 \
--conf spark.dynamicAllocation.maxExecutors=3 \
--conf spark.dynamicAllocation.initialExecutors=1 \
--conf spark.memory.offHeap.enabled=true \
--conf spark.memory.offHeap.size=2G \
--conf spark.shuffle.service.enabled=true \
--conf spark.executor.memory=2G \
--conf spark.driver.memory=2G \
--conf spark.driver.maxResultSize=0 \
--num-executors 2 \
--executor-cores 1 \
${SCRIPT}</code></pre></li>
</ul>
</section>
</section>
<section id="주차-수업정리" class="level1">
<h1>4주차 수업정리</h1>
<section id="elasticsearch" class="level2">
<h2 class="anchored" data-anchor-id="elasticsearch">Elasticsearch</h2>
<ul>
<li>Elasticsearch은 검색엔진인데 왜 저장용도로 사용하는가
<ul>
<li>ELK스택 : Elasticsearch + Logstash + Kibana를 같이 사용. 로그데이터 관리/모니터링 등에 많이 사용(스타트업부터~대기업까지도)</li>
<li>검색엔진이 아닌 ELK스택과 같은 활용으로 이해</li>
<li>키바나와 같이 사용할 수 있는 매력(편리함)
<ul>
<li>데이터의 저장/커넥션/export 등의 과정없이, ES의 호스트네임 입력만으로 쉽게 연동 가능<br>
<br></li>
</ul></li>
</ul></li>
<li>Elasticsearch
<ul>
<li>distributed, RESTful search and analytics engine
<ul>
<li>RESTful : REST API형태로 호출해서 검색가능(서버에 쿼리를 날리면 검색이 가능)</li>
</ul></li>
<li>Apache Lucene을 기반으로 만든 분산 검색 엔진</li>
<li>Analyzer가 내장되어있어 document를 저장하게되면, 검색되도록 해줌 <br></li>
</ul></li>
<li>Elasticsearch 특징(Characteristics)
<ul>
<li>transaction, join 지원되지 않음
<ul>
<li>join을 사용해야하는 경우는 ES를 쓰지 않도록 해야 함</li>
</ul></li>
<li>(검색을 위한)색인작업 시간이 필요
<ul>
<li>색인을 위한 Scoring 알고리즘(제일 적합한 문서임을 점수를 매김) : TF-IDF→BM25로 변경됨
<ul>
<li>BM25는 대기업 검색엔진에도 들어있음</li>
</ul></li>
</ul></li>
<li>버전업이 빠르고/잦고/많음. 이에 따라 (버전별) UI나 API차이가 클 수 있음 <br></li>
</ul></li>
<li>Elasticsearch 구조 (Structure)
<ul>
<li>document : 하나의 기본 구조. json 형태로된 문서</li>
<li>field : document의 필드 (jon의 필드, dataframe에서의 컬럼과 같음)</li>
<li>index : document가 모인 단위, 여러 노드에 분산 저장됨(분산 검색엔진이므로)
<ul>
<li>RDBMS의 index와는 다른 역할. index를 만들어 빠르게 쿼리를 가능하게 하지 않음</li>
</ul></li>
<li>_id : index내 문서에 부여된 unique id (<code>ES가 unique함을 보장하지는 않으며</code> 사용자의 책임 하에 사용)
<ul>
<li>다른 index의 _id라면 같을 수 있음</li>
<li>같은 index 내의 문서라고, 다른 shard에 있어 동일 _id 를 가질 가능성 있음
<ul>
<li>강제하고, 체크하고 있지 않기 때문 <br></li>
</ul></li>
</ul></li>
</ul></li>
<li>Shard
<ul>
<li>Primay와 Replica가 있음. 아래 그림기준 같은 색 칠해진 것들이 같은 Shard <img src="index_files/figure-html/20c586c7-1-class_w4-1.jpg" class="img-fluid" alt="class_w4-1.jpg"> <br></li>
</ul></li>
<li>Search과정(저장<sub>쿼리</sub>결과도출까지 ES내부적으로 일어나는 일) 및 용어
<ul>
<li>document를 분석해서 Lucene(루신)이 inverted index(역색인)를 생성
<ul>
<li>아파치 루신이 (메모리에서) 역색인을 생성</li>
</ul></li>
<li>document의 insert/update/delete 변경을 메모리에 들고 있다가 주기적으로(batch단위로) disk에 flush
<ul>
<li>refresh: 디스크에 내려 검색가능해짐</li>
</ul></li>
<li>disk에 flush(들어간)된 segment들이 중간중간 적절히 segment merge됨
<ul>
<li>segment: 디스크에 기록된 파일들의 단위</li>
</ul></li>
<li>(여러 segment가 모인) lucene index
<ul>
<li>루신엔진의 역할은 모인 segment에서 결과를 검색하여 결과를 줌(Lucene은 index 내에서만 검색 가능)</li>
<li>루신엔진이 준 결과를 ES가 모아 merge에서 리턴함</li>
</ul></li>
<li>shard(lucene index를 모은[wrapping] 단위)</li>
<li>eleasticsearch index : 여러 shard 가 모인 단위.
<ul>
<li>ES에서 높은 highlevel에서 부르는 index</li>
<li>ES검색을 하면 각 shard에 명령이 내려가 내부에서 검색한 후, 결과를 merge해서 줌</li>
</ul></li>
<li>commit : fsync()를 통해, 커널시스템 캐시내용 ↔︎ 실제 디스크내용의 sync를 맞춤 (⇒ 비싼 작업)
<ul>
<li>커널시스템 캐시내용 : lucene flush 시킨 것</li>
<li>commit주기는 옵션으로 지정 가능</li>
</ul></li>
<li>Elasticsearch의 flush는 내부적으로 Lucene commit을 수행
<ul>
<li>flush가 일어나면 commit을 수행 (디스크를 내리고 싱크를 맞추는 작업의 반복)</li>
</ul></li>
<li>translog : commit 되기 전의 작업 기록 (로딩실패 등의 경우 shard recovery 에 이용)
<ul>
<li>commit되었다면 fail해도 내용을 잃어버리지 않겠지만, commit되지 않은 기록은 translog로 보존</li>
</ul></li>
<li>참조 이미지<br> <img src="index_files/figure-html/20c586c7-2-class_w4-2.jpg" class="img-fluid" alt="class_w4-2.jpg"> <br></li>
</ul></li>
<li>nodes
<ul>
<li>master node: 데이터의 저장보다는 관리의 역할
<ul>
<li>클러스터를 관리 - 인덱스 생성이나 삭제, 샤드 할당</li>
<li>master-eligible node : master node 가 될 수 있는 후보들. 지정할 수도 있음
<ul>
<li>master-eligible node끼리 voting해서 master node를 뽑게 됨</li>
</ul></li>
</ul></li>
<li>data node: 데이터가 저장되는 노드. CRUD/Search/Aggregation 등이 일어남</li>
<li>ingest node: 색인 전처리(ingest pipeline) 수행</li>
<li>coordinating node: role이 전부 지정되지 않은 노드(master/data/ingest 모두 아님)
<ul>
<li>클라이언트 요청만 처리(coordinating만 함). data nodes에 요청을 포워딩하고 결과를 모아서 클라이언트에게 응답</li>
</ul></li>
<li>기본적으로는 모든 노드가 coordinating 역할을 수행 <br></li>
</ul></li>
<li>ES Install
<ul>
<li>설치링크 : https://www.elastic.co/kr/downloads/elasticsearch</li>
<li>최신 ES에는 이미 JDK 내장되어 있음
<ul>
<li>ES_JAVA_HOME 옵션을 지정해서 JDK 변경 가능 <br></li>
</ul></li>
</ul></li>
<li>ES 실습환경 설정관련 유의사항(사용중인 docker-compose.yml 수정하는 경우)
<ul>
<li><p>ES의 버전에 맞춰 Kibana의 버전도 맞추어야 함 (같이 사용하려면)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    es:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>      image: docker.elastic.co<span class="op">/</span>elasticsearch<span class="op">/</span>elasticsearch:<span class="fl">8.4.3</span> <span class="co"># Kibana연동시 이 버전과 맞춰야 함</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      networks:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> default<span class="op">-</span>network</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      environment:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> node.name<span class="op">=</span>es <span class="co"># 노드이름 설정</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> discovery.<span class="bu">type</span><span class="op">=</span>single<span class="op">-</span>node</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> discovery.seed_hosts<span class="op">=</span>es</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> xpack.security.enabled<span class="op">=</span>false</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> xpack.security.enrollment.enabled<span class="op">=</span>false</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> xpack.security.http.ssl.enabled<span class="op">=</span>false</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> xpack.security.transport.ssl.enabled<span class="op">=</span>false</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> cluster.routing.allocation.disk.threshold_enabled<span class="op">=</span>false</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> ELASTIC_PASSWORD<span class="op">=</span>password</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>      mem_limit: <span class="dv">1073741824</span> <span class="co"># 환경에 따라 미지원될 수 있음. 삭제해도 무방</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>      ulimits:</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        memlock:</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>          soft: <span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>          hard: <span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>      volumes:</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> .<span class="op">/</span>es<span class="op">-</span>data:<span class="op">/</span>usr<span class="op">/</span>share<span class="op">/</span>es<span class="op">/</span>data <span class="co"># es-data폴더로 지정. 로그작성 등에 사용</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      ports:</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> <span class="dv">9200</span>:<span class="dv">9200</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>localhost:9200/?query=’키워드’와 같은 느낌으로도 실행가능 (REST API이므로)</p></li>
</ul></li>
</ul>
</section>
<section id="elasticsearch-index" class="level2">
<h2 class="anchored" data-anchor-id="elasticsearch-index">Elasticsearch index</h2>
<ul>
<li>Elasticsearch index
<ul>
<li>Lucene index와 elasticsearch index는 다름을 참고</li>
</ul></li>
<li>Settings
<ul>
<li>number_of_replicas(동적으로 변경 가능) : primary shard 1개 당 replica shard 개수</li>
<li>number_of_shard(<strong>reindex없이 변경 불가</strong>) : index 에 지정된 shards 의 수
<ul>
<li>RDBMS의 index와 달리 어렵고 비용이 많이 드는 작업(Scoring알고리즘 등의 재실행)</li>
<li>reindex는 서비스가 돌고 있으면 서비스를 내려야 하는 등 하기 어려움 <br></li>
</ul></li>
</ul></li>
<li>set index
<ul>
<li>PUT &lt;실제index-name&gt; : index 만들기</li>
<li>GET &lt;실제index-name&gt; : 만든 index확인하기</li>
<li>refresh_interval : 검색대상이 되도록 얼마나 자주 refresh(새로운 데이터의 색인 생성에 대한 주기)
<ul>
<li>index.search.idle.after (default는 30)
<ul>
<li>-1일 경우 refresh하지 않음 (현재 실습처럼 검색하지 않고 쓰는 경우에 사용가능) <br></li>
</ul></li>
</ul></li>
</ul></li>
<li>field type
<ul>
<li>field의 타입
<ul>
<li>simple(기본) 타입 : text, keyword, date, long, double, boolean, ip
<ul>
<li>text vs keyword
<ul>
<li>text : analyzer가 적용된 후 색인
<ul>
<li>analyzer가 각 단어를 분석했기 때문에 full-text search 가능</li>
</ul></li>
<li>keyword : analyzer가 적용되지 않고 색인
<ul>
<li>analyzer가 토큰별 분석을 하지 않아 전체문장 일치해야 검색 가능(즉 search용도가 아님)</li>
<li>search대상이 아닌 sorting/aggregation대상인 경우 많이 사용</li>
<li>(analyzer가 적용되지 않으므로) text보다 빠르다</li>
</ul></li>
</ul></li>
</ul></li>
<li>계층 구조있는 타입 : object, nested</li>
<li>그 외 타입 : geo_point, geo_shape, completion</li>
</ul></li>
<li><strong>한번 지정되면 reindex하지 않으면 변경 불가</strong>. (설계시 신중하게) <br></li>
</ul></li>
<li>index mapping
<ul>
<li>dynamic mapping : 새로운 field name으로 데이터가 들어오면 적당한 타입을 부여</li>
<li>explicit mapping : 명시적으로 mapping을 사전에 지정 (<strong>실제 서비스 등에서 주로 사용</strong>) <br></li>
</ul></li>
<li>custom analyzer
<ul>
<li>사용자가 원하는 analyzer(서드파티 포함) 지정 가능</li>
<li>html_strip, standard, lowercase, stop-token(욕설 등 특정 토큰 색인X) 등</li>
<li>여러 analyzer 등을 완료하면 색인이 가능해짐 <br></li>
</ul></li>
<li>multifields
<ul>
<li>한 필드의 데이터를 여러 설정으로 색인 가능
<ul>
<li>(서비스 요구사항이 fix되어)매핑이 지정되었는데 추가 요구사항이 있는 경우, 반영하기 위해 사용</li>
<li>reindex는 비용이 많이 듦 <br></li>
</ul></li>
</ul></li>
<li>옵션 index:false
<ul>
<li>해당 필드 역색인을 만들지 여부(default:true)
<ul>
<li>주의 : index를 만들지 않으므로 검색대상이 되지 않음</li>
</ul></li>
<li>ES 8.1 부터 필드가 doc_values를 사용한 경우는 index없이도 검색 가능(검색 성능은 떨어짐)</li>
<li>역색인을 생성하지 않을 뿐 정렬이나 집계 가능
<ul>
<li>text와 annotated_text 타입을 제외하고 지원</li>
<li>sorting, aggregations, script 이 필요없으면 disable 가능 <br></li>
</ul></li>
</ul></li>
<li>옵션 enabled:false(object 필드에 적용)
<ul>
<li>false지정시, 파싱도 수행하지 않음</li>
<li>_source에 들어가지만 검색/저장되지 않음
<ul>
<li>데이터 명세상 잘 오고 있는지 확인하는 정도로만 갖고 싶을 때(_source에서 확인만)</li>
<li>API로 받은 데이터를 모두 사용하지 않고, 특정 데이터만 확인하고 싶을 때 <br></li>
</ul></li>
</ul></li>
<li>fielddata(<strong>잘쓰지 않음</strong>)
<ul>
<li>text 필드에 대해 sorting, aggregations, 혹은 script 작업을 수행해야할 때 사용</li>
<li><strong>text 필드를 sorting하고 싶을때</strong> fielddata:enable로 적용
<ul>
<li>text필드이므로 analyzer 적용되고 색인이 생성됨 (예를 들면 문장단위의 sorting 실행됨)</li>
<li>sorting을 하려면 메모리에 올려야 하므로, <strong>heap메모리 사용이 순간적으로 커진다</strong></li>
</ul></li>
<li>기본적으로 disable <br></li>
</ul></li>
<li>analyzer
<ul>
<li>원하는 <strong>여러 필터</strong>를 순서대로 적용 가능</li>
<li>적용순서 : character filters → tokenizer → token filters</li>
<li>종류 : HTML Strip Character Filter, Mapping Character Filter, Pattern Replace Character Filter <br></li>
</ul></li>
<li>tokenizer
<ul>
<li>character stream에서 stream of tokens로 바꿈</li>
<li>1개의 tokenizer만 지정 가능 (토큰 생성방법에 따라 후속이 많이 달라지므로)</li>
<li>기본제공 토크나이저 중 한글전용 토크나이저는 없음 (별도 형태소 분석기 등을 붙여 사용해야 함)</li>
<li>종류 : standard tokenizer, etter tokenizer, whitespace tokenizer, ngram tokenizer 등
<ul>
<li>ngram tokenizer예시) min 2, max 3: hello → he, hel, el, ell, ll, llo <br></li>
</ul></li>
</ul></li>
<li>token filter
<ul>
<li>token stream에서 token을 추가/변경/삭제</li>
<li>0개 이상(미지정 가능)</li>
<li>종류 : lowercase/uppercase, stop words, synonym, pattern_replace, stemmer(어간 추출, 한글불가), trim, truncate <br></li>
</ul></li>
<li>normalizer
<ul>
<li>keyword 필드(text필드와 달리 analyzer미적용)에만 적용. analyzer와 비슷</li>
<li>analyzer는 stream of charactor를 stream of token으로 만들어줌
<ul>
<li>character filters → tokenizer → token filters</li>
</ul></li>
<li>normalizer는 단일 토큰만 생성.
<ul>
<li>character filters, token filters를 적용가능하게 해줌
<ul>
<li>예를 들어, 특정 문자만 지우는 등의 기능으로 사용 <br></li>
</ul></li>
</ul></li>
</ul></li>
<li>_routing
<ul>
<li>document가 어떤 shard에 배정될지 지정</li>
<li>shard number를 결정할 때 보통 hash알고리즘으로 되어있음
<ul>
<li>shard_num = hash(_routing) % num_primary_shards</li>
</ul></li>
<li>기본값으로 _id를 사용(유니크값이므로 각 데이터별로 어느 shard에 넣을지 결정하기에 용이)</li>
<li>색인시에 routing지정했다면 update, delete, get, search 시에도 지정해야 함
<ul>
<li>update 할 때 등도 shard를 찾아 갈 수 있도록 지정해야 함</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="queryes에서-쿼리하는법" class="level2">
<h2 class="anchored" data-anchor-id="queryes에서-쿼리하는법">Query(ES에서 쿼리하는법)</h2>
<ul>
<li>Elasticsearch Query
<ul>
<li>get/put/delete 등 Restful API같은 구조 <br></li>
</ul></li>
<li>get API
<ul>
<li>_doc
<ul>
<li>GET <index>/_doc/&lt;_id&gt;
<ul>
<li>그냥 _id만 넣으면 어느 index에서 찾아야할지 ES가 판단 불가</li>
<li>translog에만 기록이 된 것도 조회가 가능하다(<strong>get은 검색은 아니라는 뜻</strong>)</li>
</ul></index></li>
<li>HEAD <index>/_doc/&lt;_id&gt;
<ul>
<li>존재여부를 bool로 반환</li>
</ul></index></li>
</ul></li>
<li>_source/ (object필드에 enabled:false 적용한 경우 rawdata저장되는 곳)
<ul>
<li>GET <index>/_source/&lt;_id&gt;</index></li>
<li>HEAD <index>/_source/&lt;_id&gt;
<ul>
<li>존재여부 확인 가능 <br></li>
</ul></index></li>
</ul></li>
</ul></li>
<li>_source 추가 설명
<ul>
<li>원본 JSON document body를 저장</li>
<li>색인되지 않으므로 검색대상이 아닌 원본 데이터임</li>
<li>주의사항 : <code>_source: disable</code> 할 경우 update, reindex 등을 사용할 수 없다
<ul>
<li>다른 데이터는 analyzer를 통과한(색인된) 데이터이므로, 재색인할 때는 활용불가하며 원본 있어야함</li>
<li>원본으로 _source에 넣어두므로, disable해두면 reindex나 update를 통한 버전업 불가 <br></li>
</ul></li>
</ul></li>
<li>delete API
<ul>
<li>DELETE <index>/_doc/&lt;_id&gt;
<ul>
<li>삭제flag만 올려두고, 실제 삭제는 Licene segment의 주기적으로 merge될 때 진행됨</li>
<li>내부적으로는 최근 삭제된 문서를 일정기간 보존(shard복구시 삭제 작업을 재처리하기 위함) <br></li>
</ul></index></li>
</ul></li>
<li>update API
<ul>
<li>POST <index>/_update/&lt;_id&gt;
<ul>
<li>일부 필드 업데이트(doc_as_upsert가능)</li>
<li>detect_noop: 실질적으로 어떠한 값도 변경하지 않을 경우 수행 X
<ul>
<li>아무값 변경이 없는데 POST명령이 들어간 경우, 업데이트를 수행하지 않도록 하는 기능 <br></li>
</ul></li>
</ul></index></li>
</ul></li>
<li>multiget API
<ul>
<li>GET /_mget { “docs”: [ ] } <br></li>
</ul></li>
<li>bulk API
<ul>
<li>POST /_bulk
<ul>
<li>index, create, delete, update를 한번에 모아보낼 수 있음</li>
<li>으로 데이터 구분</li>
<li>Content-Type: application/x-ndjson, 마지막 라인 으로 종결</li>
<li><strong>대량 색인 작업 시에 필수로 사용(처음 ES구축시 대량색인해야할 때)</strong></li>
<li>실제 적용 순서가 보장되지 않음 (여러 bulk 작업 간의 순서 보장 X)
<ul>
<li>분산 작업이므로(여러 노드가 작업하므로)</li>
</ul></li>
<li>한 bulk request 안의 같은 _index + _id 조합은 순서 보장 <br></li>
</ul></li>
</ul></li>
<li>Delete by query
<ul>
<li>조건에 맞는 document 삭제</li>
<li>주의사항
<ul>
<li>쿼리 조건에 맞는 document가 여러개일 경우, 삭제하려던 것이 삭제되어있거나 업데이터 되어 쿼리에 맞지 않을 수 있음
<ul>
<li>index 스냅샷을 찍고 스냅샷을 기준으로 작업 진행</li>
<li>스냅샷 이후 변경이 확인되면, 삭제 실패로 끝남</li>
</ul></li>
<li><code>wait_for_completion: false</code> : async 작업 가능
<ul>
<li>delete될 쿼리를 날려두고 다른 작업ㅇ르 할 수 있음</li>
</ul></li>
<li>작업 결과가 .tasks index에 document 로 남음
<ul>
<li>Delete by query가 잘못되었을 때 복구할 수 있도록</li>
</ul></li>
</ul></li>
<li>update by query도 있음 <br></li>
</ul></li>
<li><strong>search</strong> (중요)
<ul>
<li><p><code>GET &lt;index&gt;/_search</code> or <code>POST &lt;index&gt;/_search</code></p></li>
<li><p>특징</p>
<ul>
<li>색인 생성한 것에 대해 맞는 문서를 리턴(scoring순서에 맞게 나옴)</li>
<li>(index 여러 곳에서 검색하기 위해)index는 ,로 구분하여 지정 가능</li>
<li>index 이름에 wildcard * 지정 가능</li>
<li>query string 인자를 이용하는 검색도 존재
<ul>
<li>ex) GET /test/_search?q=fieldName:queryText</li>
</ul></li>
</ul></li>
<li><p>match_all(모두 만족) / match(하나의 필드가 만족)</p>
<pre><code>  {“query”: {
      “match_all”: {}
      “match”: {       “mytext”: “Hello, World!”     }
    } }</code></pre></li>
<li><p>term / terms</p>
<ul>
<li>query string 을 analyze하지 않음(exact term을 포함한 문서를 찾음)</li>
<li>keyword 필드의 경우 normalizer 가 적용되었으면 쿼리에도 적용</li>
<li>terms: 여러 query string (조건) 에 의해 검색 <br></li>
</ul></li>
</ul></li>
<li>prefix query
<ul>
<li>필드가 특정한 prefix로 시작하는 document 검색</li>
<li>명시적 매핑(explicit mapping)시 index_prefixes옵션을 미리 준 경우,
<ul>
<li>속도가 높일 수 있으나(analyzer와 관계없이), 그렇지 않았다면 expensive query
<ul>
<li>많은 DB에서는 사실상 prefix query는 expensive query</li>
</ul></li>
</ul></li>
<li>ES는 비싼 쿼리를 가능하게할지 말지도 옵션 지정 가능
<ul>
<li><code>search.allow_expensive_queries: false</code>라면 expensive query불가 <br></li>
</ul></li>
</ul></li>
<li>range/exists
<ul>
<li>range: 필드가 특정 range 이내의 값인 document
<ul>
<li>gt(greater than), gte, lt, lte로 range를 지정</li>
<li>date field 에 대해서도 지원</li>
<li>text / keyword 필드에 대한 range query는 expensive query
<ul>
<li><code>search.allow_expensive_queries: false</code>라면 사용불가</li>
</ul></li>
</ul></li>
<li>exists: 필드에 값이 색인되어 있는 document
<ul>
<li>empty string 도 값이 있는 것으로 판단</li>
<li>JSON 이 null 이거나 [], [null, null] 등일 경우 값이 없는 것으로 판단</li>
<li>mapping 에 index: false 여서 색인되지 않은 경우에도 값이 없는 것으로 판단bool query <br></li>
</ul></li>
</ul></li>
<li>bool query(여러 쿼리를 조합하는 쿼리)
<ul>
<li>must: 지정된 모든 쿼리 조건을 만족해야 함</li>
<li>must_not: 지정된 모든 쿼리 조건을 만족하지 않아야 함</li>
<li><strong>should</strong>: 지정된 쿼리 중 적어도 minimum_should_match 개수 만큼 만족해야 함
<ul>
<li>filter는 모두 만족해야 함
<ul>
<li>filter : 쿼리 외의 true/false로 답이 나오는 것들
<ul>
<li>query는 relevance score를 계산(리턴값이 score)해 얼마나 문서와 잘 매칭되는지 판단</li>
<li>filter와 query 중 우선순위는 없음
<ul>
<li>should query(bool)라면, filter는 만족하는 query중에서 minimum_should_match를 count <br></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>sort
<ul>
<li>필드를 지정해서 검색 결과를 정렬(보통 score는 계산하지 않고 정렬만 함)</li>
<li>정렬 중에는 필드 값이 메모리에 올라감
<ul>
<li>text 타입은 일반적으로 정렬 대상이 될 수 없음 (성능이슈, 비싼작업) <br></li>
</ul></li>
</ul></li>
<li>from / size
<ul>
<li>기초적인 pagination.</li>
<li>1만개를 초과한 document를 pagination할 수 없으며, 이로 인해 잘 사용되지 않음
<ul>
<li>index.max_result_window settings로 기본값이 1만개로 되어있음</li>
</ul></li>
<li>메모리 &amp; 시간이 from + size 의 값에 비례 <br></li>
</ul></li>
<li>scroll / search_after
<ul>
<li>from, size 대신 사용되는 pagination방법</li>
<li>scroll: search context를 유지하며 대량 데이터를 처리
<ul>
<li>검색이 수행된 그 상태를 스냅샷처럼 찍어 검색 결과를 스크롤링</li>
<li>(스냅샷 쓰므로)스크롤링 도중 변화되는 문서 내용은 반영되지 않음</li>
<li>옵션
<ul>
<li>size: 배치에 반환할 문서의 수</li>
<li>_scroll_id: 다음 배치의 검색 값 받을 수 있음</li>
</ul></li>
<li>scroll 인자로 넘겨준 시간만큼 search context를 유지</li>
<li>기준값이 동일한 document 사이에서는 일관된 순서를 보장하지는 않음(sort되어 나오지 않음)</li>
</ul></li>
<li><strong>search_after(제일 많이 사용)</strong>: 결과 문서 중 가장 마지막 문서의 sort 기준값을 사용
<ul>
<li>_id 필드는 doc value가 disabled되어 있기 때문에 이를 기준으로 하는 정렬은 많은 메모리를 사용
<ul>
<li>_id필드로 정렬하지는 않는다는 뜻</li>
</ul></li>
<li>scroll과 다른점 : 실시간 변경 데이터 반영 가능</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="optimization" class="level2">
<h2 class="anchored" data-anchor-id="optimization">Optimization</h2>
<ul>
<li>reindex
<ul>
<li>비싼 작업</li>
<li>원본 index내 문서의 _source를 읽어서 대상 index에 새로 색인</li>
<li>query를 지정하여 일부 문서만 reindex 가능</li>
<li>script 이용하여 throttling, slicing, 비동기 작업 가능</li>
<li>다른 Elasticsearch 클러스터에서 데이터를 가져와 reindex 가능
<ul>
<li>다른 Elasticsearch를 연결하려면 elasticsearch.yml에 reindex.remote.whitelist: “host:XXXX” 추가</li>
</ul>
<pre><code>POST _reindex
{“source”: …
   “dest”: …}</code></pre>
<br></li>
</ul></li>
<li>Index life cycle
<ul>
<li>종류
<ul>
<li>hot: 현재 업데이트가 수행되고 있고 읽기 작업도 가장 많은 상태</li>
<li>warm: 인덱스에 더 이상 업데이트가 수행되지는 않지만 읽기 작업은 들어오는 상태</li>
<li>cold: 인덱스에 더 이상 업데이트가 수행되지 않고 읽기 작업도 가끔씩만 들어오는 상태.
<ul>
<li>검색은 되어야 하나 속도가 느려도 괜찮은 상황.</li>
</ul></li>
<li>frozen: 인덱스에 더 이상 업데이트가 수행 되지 않고 읽기 작업도 거의 들어오지 않는 상태.
<ul>
<li>검색은 되어야 하나 속도가 상당히 느려도 괜찮은 상황.</li>
</ul></li>
<li>delete : 인덱스가 더 이상 필요없고 삭제되어도 무방한 상태</li>
</ul></li>
<li>index가 어느 cycle에 있는지 보면서 자원을 분배
<ul>
<li>이에 따라 검색속도 차이가 많이 남</li>
<li>검색이 느리다면 ’cold’로 간 것은 아닌지 유추 <br></li>
</ul></li>
</ul></li>
<li>Index strategies
<ul>
<li>time series로 만들기 (보통 추천)
<ul>
<li>(RDBMS처럼)데이터 종류별로 만드는 것이 아닌, 2024.01, 2024.02 등</li>
<li>보통은 최근 데이터로 분석하는 경우 많음</li>
<li>검색 범위를 좁히기 + index life cycle전략짜기 에 용이함</li>
<li>오래된 데이터 삭제에 편리</li>
</ul></li>
<li>데이터가 커질 경우 index mapping 직접 만들기</li>
<li>index template 활용하기 (비슷한 index mapping 사용하는 경우)</li>
<li>routing활용하기(어떤 shard에 데이터를 저장할지 지정)
<ul>
<li>성능 향상</li>
<li>index mappings _routing meta field 에 required: true 옵션을 부여해 강제할 수 있다</li>
</ul></li>
<li>field type은 기본적으로 변경 불가능함을 염두에 두기
<ul>
<li>같은 필드의 type 이 계속 변경될 수 있다면 ES특성상 ES가 적합하지 않음</li>
<li>해당 데이터가 들어와야 한다면 <code>enable: false</code>로 색인포기하고 에러발생하지 않게 할 수 있음</li>
</ul></li>
<li>운영도중 analyze 변경 필요성이 있다면, multi field를 고려한다 <br></li>
</ul></li>
<li>Shard Strategies
<ul>
<li>shard의 개수
<ul>
<li>shard 갯수를 노드 수의 n배로 둘 필요는 없음
<ul>
<li>hot/warm 등 index에 따라 리소스가 분배되므로, 성능향상에 꼭 도움이 되지 않음
<ul>
<li>활용중인 index가 많은 경우, 단일 index작업에 모든 노드가 참여하지 않음(고르게 분배되지 않음)</li>
</ul></li>
</ul></li>
<li>추후 추가 서버가 투입될 가능성이 있음</li>
</ul></li>
</ul></li>
</ul>


</section>
</section>

<p><br><strong>Copyright © 2024 Kibok Park All rights reserved.</strong><br></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kr9268\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kr9268/giscus_for_blog" data-repo-id="R_kgDOL0Sthw" data-category="General" data-category-id="DIC_kwDOL0Sth84Ce_5h" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<script>
    const baseFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
    const watermark = new XWatermark.XWatermark();
    watermark.init("Kibok Park", {
      parentSelector: "body",
      prevent: true,
      observer: true,
      mode: "normal",
      font: "system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', 'Noto Sans', 'Liberation Sans', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      fontsize: baseFontSize * 1.000000,
      angle: -15.000000,
      color: "#000000",
      alpha: 0.100000,
      cols: 10,
      rows: 50,
      xSpace: baseFontSize * 4.000000,
      ySpace: baseFontSize * 4.000000,
      zIndex: -1
    });
    </script>




</body></html>